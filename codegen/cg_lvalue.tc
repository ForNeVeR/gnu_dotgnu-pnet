%output "cg_lvalue.c"

%{
/*
 * cg_lvalue.tc - Identifier and l-value nodes.
 *
 * Copyright (C) 2001  Southern Storm Software, Pty Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include "cg_nodes.h"

%}

/*
 * Stub out identifier operations.  Identifier nodes must
 * be replaced with real l-value nodes prior to code generation.
 */
ILNode_GetType(ILNode_Identifier),
ILNode_GetType(ILNode_QualIdent),
ILNode_GenValue(ILNode_Identifier),
ILNode_GenValue(ILNode_QualIdent)
{
	return ILMachineType_Void;
}
ILNode_GenDiscard(ILNode_Identifier),
ILNode_GenDiscard(ILNode_QualIdent),
ILNode_GenThen(ILNode_Identifier),
ILNode_GenThen(ILNode_QualIdent),
ILNode_GenElse(ILNode_Identifier),
ILNode_GenElse(ILNode_QualIdent)
{
}
ILNode_EvalConst(ILNode_Identifier),
ILNode_EvalConst(ILNode_QualIdent)
{
	return 0;
}

/*
 * Get the type of a local or argument variable.
 */
ILNode_GetType(ILNode_LocalVar),
ILNode_GetType(ILNode_ArgumentVar)
{
	return node->machineType;
}

/*
 * Get the type of a field access operator.
 */
ILNode_GetType(ILNode_MemberAccess),
ILNode_GetType(ILNode_BaseAccess),
ILNode_GetType(ILNode_BaseElement),
ILNode_GetType(ILNode_DerefField)
{
	return node->machineType;
}

/*
 * Get the type of a static or member field reference.
 */
ILNode_GetType(ILNode_StaticField),
ILNode_GetType(ILNode_MemberField)
{
	return ILTypeToMachineType(ILField_Type(node->field));
}

/*
 * Get the type of a static or member property reference.
 */
ILNode_GetType(ILNode_StaticProperty),
ILNode_GetType(ILNode_MemberProperty)
{
	ILType *signature = ILProperty_Signature(node->property);
	return ILTypeToMachineType(signature->un.method.retType);
}

/*
 * Generate discard code for a local or argument variable.
 */
ILNode_GenDiscard(ILNode_LocalVar),
ILNode_GenDiscard(ILNode_ArgumentVar)
{
	/* Nothing needs to be done here */
}

/*
 * Generate discard code for a member access operator.
 */
ILNode_GenDiscard(ILNode_MemberAccess)
{
	/* Evaluate the object expression for its side-effects */
	ILNode_GenDiscard(node->expr1, info);
}

/*
 * Generate discard code for a base access operator.
 */
ILNode_GenDiscard(ILNode_BaseAccess)
{
	/* Nothing needs to be done here */
}

/*
 * Generate discard code for a field dereference operator.
 */
ILNode_GenDiscard(ILNode_DerefField)
{
	/* Evaluate the object expression for its side-effects */
	ILNode_GenDiscard(node->expr1, info);
}

/*
 * Generate discard code for a static field or property reference.
 */
ILNode_GenDiscard(ILNode_StaticField),
ILNode_GenDiscard(ILNode_StaticProperty)
{
	/* Nothing to do here */
}

/*
 * Generate value code for a local variable.
 */
ILNode_GenValue(ILNode_LocalVar)
{
	ILGenLoadLocal(info, node->index);
	ILGenAdjust(info, 1);
	return node->machineType;
}

/*
 * Generate value code for an argument variable.
 */
ILNode_GenValue(ILNode_ArgumentVar)
{
	ILGenLoadArg(info, node->index);
	ILGenAdjust(info, 1);
	return node->machineType;
}

/*
 * Generate value code for a member access operator.
 */
ILNode_GenValue(ILNode_MemberAccess)
{
	/* TODO */
	return node->machineType;
}

/*
 * Generate value code for a base access operator.
 */
ILNode_GenValue(ILNode_BaseAccess)
{
	/* TODO */
	return node->machineType;
}

/*
 * Generate value code for a base element operator.
 */
ILNode_GenValue(ILNode_BaseElement)
{
	/* TODO */
	return node->machineType;
}

/*
 * Generate value code for a field dereference operator.
 */
ILNode_GenValue(ILNode_DerefField)
{
	/* TODO */
	return node->machineType;
}

/*
 * Generate value code for a static field reference.
 */
ILNode_GenValue(ILNode_StaticField)
{
	ILGenFieldRef(info, IL_OP_LDSFLD, node->field);
	ILGenAdjust(info, 1);
	return ILTypeToMachineType(ILField_Type(node->field));
}

/*
 * Generate value code for a member field reference.
 */
ILNode_GenValue(ILNode_MemberField)
{
	ILGenCast(info, ILNode_GenValue(node->expr, info),
			  ILMachineType_ObjectRef);
	ILGenFieldRef(info, IL_OP_LDFLD, node->field);
	return ILTypeToMachineType(ILField_Type(node->field));
}

/*
 * Generate value code for a static property reference.
 */
ILNode_GenValue(ILNode_StaticProperty)
{
	ILMethod *getter = ILProperty_Getter(node->property);
	ILType *signature = ILProperty_Signature(node->property);
	ILGenCallByMethod(info, getter);
	ILGenAdjust(info, 1);
	return ILTypeToMachineType(signature->un.method.retType);
}

/*
 * Generate value code for a member property reference.
 */
ILNode_GenValue(ILNode_MemberProperty)
{
	ILMethod *getter = ILProperty_Getter(node->property);
	ILType *signature = ILProperty_Signature(node->property);
	ILGenCast(info, ILNode_GenValue(node->expr, info),
			  ILMachineType_ObjectRef);
	ILGenCallByMethod(info, getter);
	return ILTypeToMachineType(signature->un.method.retType);
}

/*
 * Prepare to store into a local or argument variable.
 */
ILNode_Prepare(ILNode_LocalVar),
ILNode_Prepare(ILNode_ArgumentVar)
{
	/* No preparation is needed for locals or arguments */
	return node->machineType;
}

/*
 * Prepare to store into a member access destination.
 */
ILNode_Prepare(ILNode_MemberAccess)
{
	/* TODO */
	return node->machineType;
}

/*
 * Prepare to store into a base access destination.
 */
ILNode_Prepare(ILNode_BaseAccess)
{
	/* TODO */
	return node->machineType;
}

/*
 * Prepare to store into a base element destination.
 */
ILNode_Prepare(ILNode_BaseElement)
{
	/* TODO */
	return node->machineType;
}

/*
 * Prepare to store into a field dereference destination.
 */
ILNode_Prepare(ILNode_DerefField)
{
	/* TODO */
	return node->machineType;
}

/*
 * Prepare to store into a static field reference.
 */
ILNode_Prepare(ILNode_StaticField)
{
	/* Nothing needs to be done here */
	return ILTypeToMachineType(ILField_Type(node->field));
}

/*
 * Prepare to store into a member field reference.
 */
ILNode_Prepare(ILNode_MemberField)
{
	node->tempVar = IL_MAX_UINT32;
	ILGenCast(info, ILNode_GenValue(node->expr, info),
			  ILMachineType_ObjectRef);
	return ILTypeToMachineType(ILField_Type(node->field));
}

/*
 * Prepare to store into a static property reference.
 */
ILNode_Prepare(ILNode_StaticProperty)
{
	ILType *signature = ILProperty_Signature(node->property);
	return ILTypeToMachineType(signature->un.method.retType);
}

/*
 * Prepare to store into a member property reference.
 */
ILNode_Prepare(ILNode_MemberProperty)
{
	ILType *signature = ILProperty_Signature(node->property);
	node->tempVar = IL_MAX_UINT32;
	ILGenCast(info, ILNode_GenValue(node->expr, info),
			  ILMachineType_ObjectRef);
	return ILTypeToMachineType(signature->un.method.retType);
}

/*
 * Get and prepare to store into a local variable.
 */
ILNode_GetAndPrepare(ILNode_LocalVar)
{
	ILGenLoadLocal(info, node->index);
	ILGenAdjust(info, 1);
	if(leave)
	{
		ILGenSimple(info, IL_OP_DUP);
		ILGenAdjust(info, 1);
	}
	return node->machineType;
}

/*
 * Get and prepare to store into an argument variable.
 */
ILNode_GetAndPrepare(ILNode_ArgumentVar)
{
	ILGenLoadArg(info, node->index);
	ILGenAdjust(info, 1);
	if(leave)
	{
		ILGenSimple(info, IL_OP_DUP);
		ILGenAdjust(info, 1);
	}
	return node->machineType;
}

/*
 * Get and prepare to store into a member access destination.
 */
ILNode_GetAndPrepare(ILNode_MemberAccess)
{
	/* TODO */
	return node->machineType;
}

/*
 * Get and prepare to store into a base access destination.
 */
ILNode_GetAndPrepare(ILNode_BaseAccess)
{
	/* TODO */
	return node->machineType;
}

/*
 * Get and prepare to store into a base element destination.
 */
ILNode_GetAndPrepare(ILNode_BaseElement)
{
	/* TODO */
	return node->machineType;
}

/*
 * Get and prepare to store into a field dereference destination.
 */
ILNode_GetAndPrepare(ILNode_DerefField)
{
	/* TODO */
	return node->machineType;
}

/*
 * Get and prepare to store into a static field reference.
 */
ILNode_GetAndPrepare(ILNode_StaticField)
{
	ILGenFieldRef(info, IL_OP_LDSFLD, node->field);
	ILGenAdjust(info, 1);
	if(leave)
	{
		ILGenSimple(info, IL_OP_DUP);
		ILGenAdjust(info, 1);
	}
	return ILTypeToMachineType(ILField_Type(node->field));
}

/*
 * Get and prepare to store into a member field reference.
 */
ILNode_GetAndPrepare(ILNode_MemberField)
{
	if(leave)
	{
		/* Generate the object reference */
		ILGenCast(info, ILNode_GenValue(node->expr, info),
				  ILMachineType_ObjectRef);

		/* Duplicate it and get the current value */
		ILGenSimple(info, IL_OP_DUP);
		ILGenAdjust(info, 1);
		ILGenFieldRef(info, IL_OP_LDFLD, node->field);

		/* Store the current value into a temporary local */
		node->tempVar = ILGenTempTypedVar(info, ILField_Type(node->field));
		ILGenSimple(info, IL_OP_DUP);
		ILGenStoreLocal(info, node->tempVar);
		ILGenExtend(info, 1);
	}
	else
	{
		/* Generate the object reference */
		ILGenCast(info, ILNode_GenValue(node->expr, info),
				  ILMachineType_ObjectRef);

		/* Duplicate it for the later store */
		ILGenSimple(info, IL_OP_DUP);
		ILGenAdjust(info, 1);

		/* Load the current value from the field */
		ILGenFieldRef(info, IL_OP_LDFLD, node->field);

		/* We don't need to reload a previous value in "Store" */
		node->tempVar = IL_MAX_UINT32;
	}
	return ILTypeToMachineType(ILField_Type(node->field));
}

/*
 * Get and prepare to store into a static property reference.
 */
ILNode_GetAndPrepare(ILNode_StaticProperty)
{
	ILMethod *getter = ILProperty_Getter(node->property);
	ILType *signature = ILProperty_Signature(node->property);
	ILGenCallByMethod(info, getter);
	ILGenAdjust(info, 1);
	if(leave)
	{
		ILGenSimple(info, IL_OP_DUP);
		ILGenAdjust(info, 1);
	}
	return ILTypeToMachineType(signature->un.method.retType);
}

/*
 * Get and prepare to store into a member property reference.
 */
ILNode_GetAndPrepare(ILNode_MemberProperty)
{
	ILMethod *getter = ILProperty_Getter(node->property);
	ILType *signature = ILProperty_Signature(node->property);
	ILType *propType = signature->un.method.retType;
	if(leave)
	{
		/* Generate the object reference */
		ILGenCast(info, ILNode_GenValue(node->expr, info),
				  ILMachineType_ObjectRef);

		/* Duplicate it and get the current value */
		ILGenSimple(info, IL_OP_DUP);
		ILGenAdjust(info, 1);
		ILGenCallByMethod(info, getter);

		/* Store the current value into a temporary local */
		node->tempVar = ILGenTempTypedVar(info, propType);
		ILGenSimple(info, IL_OP_DUP);
		ILGenStoreLocal(info, node->tempVar);
		ILGenExtend(info, 1);
	}
	else
	{
		/* Generate the object reference */
		ILGenCast(info, ILNode_GenValue(node->expr, info),
				  ILMachineType_ObjectRef);

		/* Duplicate it for the later store */
		ILGenSimple(info, IL_OP_DUP);
		ILGenAdjust(info, 1);

		/* Load the current value from the property */
		ILGenCallByMethod(info, getter);

		/* We don't need to reload a previous value in "Store" */
		node->tempVar = IL_MAX_UINT32;
	}
	return ILTypeToMachineType(propType);
}

/*
 * Store into a local variable.
 */
ILNode_Store(ILNode_LocalVar)
{
	if(leave)
	{
		ILGenSimple(info, IL_OP_DUP);
		ILGenAdjust(info, 1);
	}
	ILGenStoreLocal(info, node->index);
	ILGenAdjust(info, -1);
}

/*
 * Store into an argument variable.
 */
ILNode_Store(ILNode_ArgumentVar)
{
	if(leave)
	{
		ILGenSimple(info, IL_OP_DUP);
		ILGenAdjust(info, 1);
	}
	ILGenStoreArg(info, node->index);
	ILGenAdjust(info, -1);
}

/*
 * Store into a member access destination.
 */
ILNode_Store(ILNode_MemberAccess)
{
	/* TODO */
}

/*
 * Store into a base access destination.
 */
ILNode_Store(ILNode_BaseAccess)
{
	/* TODO */
}

/*
 * Store into a base element destination.
 */
ILNode_Store(ILNode_BaseElement)
{
	/* TODO */
}

/*
 * Store into a field dereference destination.
 */
ILNode_Store(ILNode_DerefField)
{
	/* TODO */
}

/*
 * Store into a static field reference.
 */
ILNode_Store(ILNode_StaticField)
{
	if(leave)
	{
		ILGenSimple(info, IL_OP_DUP);
		ILGenAdjust(info, 1);
	}
	ILGenFieldRef(info, IL_OP_STSFLD, node->field);
	ILGenAdjust(info, -1);
}

/*
 * Store into a member field reference.
 */
ILNode_Store(ILNode_MemberField)
{
	if(leave)
	{
		/* Copy the result into a temporary local */
		unsigned temp = ILGenTempTypedVar(info, ILField_Type(node->field));
		ILGenSimple(info, IL_OP_DUP);
		ILGenStoreLocal(info, temp);
		ILGenExtend(info, 1);

		/* Store the value into the field */
		ILGenFieldRef(info, IL_OP_STFLD, node->field);
		ILGenAdjust(info, -2);

		/* Do we need to restore a previous value to the stack top? */
		if(node->tempVar != IL_MAX_UINT32)
		{
			ILGenLoadLocal(info, node->tempVar);
			ILGenAdjust(info, 1);
			ILGenReleaseTempVar(info, node->tempVar);
		}

		/* Reload the contents of the temporary local */
		ILGenLoadLocal(info, temp);
		ILGenAdjust(info, 1);
		ILGenReleaseTempVar(info, temp);
	}
	else
	{
		/* Store the value into the field */
		ILGenFieldRef(info, IL_OP_STFLD, node->field);
		ILGenAdjust(info, -2);

		/* Do we need to restore a previous value to the stack top? */
		if(node->tempVar != IL_MAX_UINT32)
		{
			ILGenLoadLocal(info, node->tempVar);
			ILGenAdjust(info, 1);
			ILGenReleaseTempVar(info, node->tempVar);
		}
	}
}

/*
 * Store into a static property reference.
 */
ILNode_Store(ILNode_StaticProperty)
{
	ILMethod *setter = ILProperty_Setter(node->property);
	if(leave)
	{
		ILGenSimple(info, IL_OP_DUP);
		ILGenAdjust(info, 1);
	}
	ILGenCallByMethod(info, setter);
	ILGenAdjust(info, -1);
}

/*
 * Store into a member property reference.
 */
ILNode_Store(ILNode_MemberProperty)
{
	ILMethod *setter = ILProperty_Setter(node->property);
	ILType *signature = ILProperty_Signature(node->property);
	ILType *propType = signature->un.method.retType;
	if(leave)
	{
		/* Copy the result into a temporary local */
		unsigned temp = ILGenTempTypedVar(info, propType);
		ILGenSimple(info, IL_OP_DUP);
		ILGenStoreLocal(info, temp);
		ILGenExtend(info, 1);

		/* Store the value into the property */
		ILGenCallByMethod(info, setter);
		ILGenAdjust(info, -2);

		/* Do we need to restore a previous value to the stack top? */
		if(node->tempVar != IL_MAX_UINT32)
		{
			ILGenLoadLocal(info, node->tempVar);
			ILGenAdjust(info, 1);
			ILGenReleaseTempVar(info, node->tempVar);
		}

		/* Reload the contents of the temporary local */
		ILGenLoadLocal(info, temp);
		ILGenAdjust(info, 1);
		ILGenReleaseTempVar(info, temp);
	}
	else
	{
		/* Store the value into the property */
		ILGenCallByMethod(info, setter);
		ILGenAdjust(info, -2);

		/* Do we need to restore a previous value to the stack top? */
		if(node->tempVar != IL_MAX_UINT32)
		{
			ILGenLoadLocal(info, node->tempVar);
			ILGenAdjust(info, 1);
			ILGenReleaseTempVar(info, node->tempVar);
		}
	}
}

/*
 * Generate reference code for local variable nodes.
 */
ILNode_GenRef(ILNode_LocalVar)
{
	ILGenLoadLocalAddr(info, node->index);
	ILGenAdjust(info, 1);
}

/*
 * Generate reference code for argument nodes.
 */
ILNode_GenRef(ILNode_ArgumentVar)
{
	ILGenLoadArgAddr(info, node->index);
	ILGenAdjust(info, 1);
}

/*
 * Generate reference code for static fields.
 */
ILNode_GenRef(ILNode_StaticField)
{
	ILGenFieldRef(info, IL_OP_LDSFLDA, node->field);
	ILGenAdjust(info, 1);
}

/*
 * Generate reference code for member fields.
 */
ILNode_GenRef(ILNode_MemberField)
{
	ILGenFieldRef(info, IL_OP_LDFLDA, node->field);
	ILGenAdjust(info, 1);
}

/*
 * Generate reference code for a member access destination.
 */
ILNode_GenRef(ILNode_MemberAccess)
{
	/* TODO */
}

/*
 * Generate reference code for a base access destination.
 */
ILNode_GenRef(ILNode_BaseAccess)
{
	/* TODO */
}

/*
 * Generate reference code for a base element destination.
 */
ILNode_GenRef(ILNode_BaseElement)
{
	/* TODO */
}

/*
 * Generate reference code for a field dereference destination.
 */
ILNode_GenRef(ILNode_DerefField)
{
	/* TODO */
}

/*
 * Declare operations that can be used to manage identifiers.
 */
%decls %end %{

/*
 * Create a simple identifier node.  "name" must be intern'ed.
 */
ILNode *ILQualIdentSimple(char *name);

/*
 * Create a two-name identifier node.  The names do not need
 * to be intern'ed.
 */
ILNode *ILQualIdentTwo(const char *name1, const char *name2);

/*
 * Convert a qualified identifier node into a full string name,
 * and intern the string.  Returns NULL if not an identifier node.
 * If "asmForm" is non-zero, then quote the name to put it into
 * a form suitable for assembly code.
 */
char *ILQualIdentName(ILNode *node, int asmForm);

/*
 * Append two qualified identifier strings, with '.' between them.
 */
char *ILQualIdentAppend(char *name1, char *name2);

/*
 * Determine if a node is a qualified identifier.
 */
int ILIsQualIdent(ILNode *node);

%}

/*
 * Implement the identifier operations.
 */
%end %{

ILNode *ILQualIdentSimple(char *name)
{
	return ILNode_Identifier_create(name);
}

ILNode *ILQualIdentTwo(const char *name1, const char *name2)
{
	char *intern1 = ILInternString((char *)name1, -1).string;
	char *intern2 = ILInternString((char *)name2, -1).string;
	return ILNode_QualIdent_create(ILNode_Identifier_create(intern1),
								   ILNode_Identifier_create(intern2));
}

char *ILQualIdentName(ILNode *node, int asmForm)
{
	if(!node)
	{
		return 0;
	}
	else if(yykind(node) == yykindof(ILNode_Identifier))
	{
		/* Simple name */
		ILNode_Identifier *ident = (ILNode_Identifier *)node;
		if(asmForm && ident->name[0] >= 'a' && ident->name[0] <= 'z')
		{
			/* The name might clash with an assembler keyword
			   or instruction name, so we must quote it */
			ILIntString quote = ILInternString("'", 1);
			ILIntString name;
			name.string = ident->name;
			name.len = strlen(ident->name);
			return (ILInternAppendedString
						(quote, ILInternAppendedString(name, quote))).string;
		}
		return ident->name;
	}
	else if(yykind(node) == yykindof(ILNode_QualIdent))
	{
		/* Qualified name */
		ILNode_QualIdent *qident = (ILNode_QualIdent *)node;
		return ILQualIdentAppend(ILQualIdentName(qident->left, asmForm),
								 ILQualIdentName(qident->right, asmForm));
	}
	else
	{
		return 0;
	}
}

char *ILQualIdentAppend(char *name1, char *name2)
{
	ILIntString str1;
	ILIntString str2;
	ILIntString str3;
	if(!name1 || *name1 == '\0' || !name2 || *name2 == '\0')
	{
		return 0;
	}
	str1.string = name1;
	str1.len = strlen(name1);
	str2.string = ".";
	str2.len = 1;
	str3.string = name2;
	str3.len = strlen(name2);
	return (ILInternAppendedString
				(str1, ILInternAppendedString(str2, str3))).string;
}

int ILIsQualIdent(ILNode *node)
{
	if(!node)
	{
		return 0;
	}
	if(yykind(node) == yykindof(ILNode_Identifier))
	{
		return 1;
	}
	else if(yykind(node) == yykindof(ILNode_QualIdent))
	{
		return ILIsQualIdent(((ILNode_QualIdent *)node)->left) &&
		       ILIsQualIdent(((ILNode_QualIdent *)node)->right);
	}
	else
	{
		return 0;
	}
}

%}
