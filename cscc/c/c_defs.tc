/*
 * c_defs.tc - Treecc definitions for C.
 *
 * Copyright (C) 2002  Southern Storm Software, Pty Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/*
 * Inherit the common definitions.
 */
%include %readonly "../../codegen/cg_all.tc"

/*
 * Set a new header for definitions that follow.
 */
%header "c_defs.h"

/*
 * Copy the following definitions to the top of the "c_defs.h" file.
 */
%decls %{

#include <codegen/cg_nodes.h>
#include <codegen/cg_coerce.h>
#include <codegen/cg_resolve.h>
#include <codegen/cg_scope.h>
#include <cscc/common/cc_preproc.h>
#include <cscc/common/cc_options.h>
#include <cscc/c/c_declspec.h>

/*
 * Define the semantic analysis value for C nodes.
 */
typedef struct
{
	int		kind__;
	ILType *type__;
	void   *extra__;

} CSemValue;

/*
 * Semantic analysis value kinds.
 *
 * If the "DYN_CONSTANT" flag is set, then it indicates a
 * constant value that must be computed at runtime, because
 * it references a function, a static address, or a type
 * whose size is only known at runtime.
 *
 * If the "BOOLEAN" flag is set, then the compiler has inferred
 * that the correspond node will always be boolean true or false.
 */
#define	C_SEMKIND_VOID			(1<<0)
#define	C_SEMKIND_LVALUE		(1<<1)
#define	C_SEMKIND_RVALUE		(1<<2)
#define	C_SEMKIND_CONSTANT		(1<<3)
#define	C_SEMKIND_DYN_CONSTANT	(1<<4)
#define	C_SEMKIND_FUNCTION		(1<<5)
#define	C_SEMKIND_TYPE			(1<<6)
#define	C_SEMKIND_BOOLEAN		(1<<7)
#define	C_SEMKIND_ERROR			(1<<8)

/*
 * The default semantic value, which is always "void".
 */
extern CSemValue CSemValueDefault;

/*
 * A semantic value that represents a boolean r-value.
 */
extern CSemValue CSemValueBool;

/*
 * A semantic value that represents a semantic error.
 */
extern CSemValue CSemValueError;

/*
 * Test for various kinds of semantic values.
 */
#define	CSemIsVoid(value)		(((value).kind__ & C_SEMKIND_VOID) != 0)
#define	CSemIsLValue(value)		(((value).kind__ & C_SEMKIND_LVALUE) != 0)
#define	CSemIsRValue(value)			\
			(((value).kind__ & (C_SEMKIND_LVALUE | C_SEMKIND_RVALUE)) != 0)
#define	CSemIsConstant(value)	(((value).kind__ & C_SEMKIND_CONSTANT) != 0)
#define	CSemIsDynConstant(value)	\
			(((value).kind__ & C_SEMKIND_DYN_CONSTANT) != 0)
#define	CSemIsFunction(value)	(((value).kind__ & C_SEMKIND_FUNCTION) != 0)
#define	CSemIsType(value)		(((value).kind__ & C_SEMKIND_TYPE) != 0)
#define	CSemIsBoolean(value)	(((value).kind__ & C_SEMKIND_BOOLEAN) != 0)
#define	CSemIsError(value)		(((value).kind__ & C_SEMKIND_ERROR) != 0)

/*
 * Get the type field from a semantic value.
 */
#define	CSemGetType(value)		((value).type__)

/*
 * Get the constant value associated with a semantic value.
 */
#define	CSemGetConstant(value)	\
	((((value).kind__ & (C_SEMKIND_CONSTANT | C_SEMKIND_DYN_CONSTANT)) \
			== C_SEMKIND_CONSTANT) ? ((ILEvalValue *)((value).extra__)) \
								   : ((ILEvalValue *)0))

/*
 * Get the function name associated with a semantic value.
 */
#define	CSemGetFuncName(value)	((char *)((value).extra__))

/*
 * Set a semantic value to "void".
 */
#define	CSemSetVoid(value)	\
			do { \
				(value).kind__ = C_SEMKIND_VOID; \
				(value).type__ = ILType_Void; \
				(value).extra__ = 0; \
			} while (0)

/*
 * Set a semantic value to an l-value reference.
 */
#define	CSemSetLValue(value,type)	\
			do { \
				(value).kind__ = C_SEMKIND_LVALUE; \
				(value).type__ = (type); \
				(value).extra__ = 0; \
			} while (0)

/*
 * Set a semantic value to an r-value reference.
 */
#define	CSemSetRValue(value,type)	\
			do { \
				(value).kind__ = C_SEMKIND_RVALUE; \
				(value).type__ = (type); \
				(value).extra__ = 0; \
			} while (0)

/*
 * Set a semantic value to a constant reference.
 */
#define	CSemSetConstant(value,type,constValue)	\
			do { \
				(value).kind__ = C_SEMKIND_RVALUE | C_SEMKIND_CONSTANT; \
				(value).type__ = (type); \
				(value).extra__ = \
					CSemDupExtra(&(constValue), sizeof(ILEvalValue)); \
			} while (0)

/*
 * Set a semantic value to a dynamic constant reference.
 */
#define	CSemSetDynConstant(value,type)	\
			do { \
				(value).kind__ = C_SEMKIND_RVALUE | C_SEMKIND_CONSTANT | \
								 C_SEMKIND_DYN_CONSTANT; \
				(value).type__ = (type); \
				(value).extra__ = 0; \
			} while (0)

/*
 * Set a semantic value to a function reference.
 */
#define	CSemSetFunction(value,type,name)	\
			do { \
				(value).kind__ = C_SEMKIND_FUNCTION | C_SEMKIND_CONSTANT | \
								 C_SEMKIND_DYN_CONSTANT; \
				(value).type__ = (type); \
				(value).extra__ = (void *)(name); \
			} while (0)

/*
 * Set a semantic value to a type reference.
 */
#define	CSemSetType(value,type)	\
			do { \
				(value).kind__ = C_SEMKIND_TYPE; \
				(value).type__ = (type); \
				(value).extra__ = 0; \
			} while (0)

/*
 * Covnert a semantic value into a type reference.
 */
#define	CSemToType(value)	\
			do { \
				(value).kind__ = C_SEMKIND_TYPE; \
				(value).extra__ = 0; \
			} while (0)

/*
 * Adjust a semantic value to record that it is boolean.  This must
 * be used after one of the above "Set" macros.
 */
#define	CSemSetBoolean(value)	\
			do { \
				(value).kind__ |= C_SEMKIND_BOOLEAN; \
			} while (0)

/*
 * Set a semantic value to "error".
 */
#define	CSemSetError(value)	\
			do { \
				(value).kind__ = C_SEMKIND_ERROR; \
				(value).type__ = ILType_Void; \
				(value).extra__ = 0; \
			} while (0)

/*
 * Perform inline semantic analysis on a node, in a specific scope.
 */
CSemValue CSemInlineAnalysis(ILGenInfo *info, ILNode *node, ILScope *scope);

%}

%output "c_nodes.c"

%{
#include <cscc/c/c_internal.h>
%}

/*
 * Define extra node types that are required by C.
 */
%node ILNode_CString ILNode_String
%node ILNode_SizeOfExpr ILNode_UnaryExpression =
{
	%nocreate ILType *type = {0};
}
%node ILNode_SizeOfType ILNode_Expression =
{
	ILType *type;
}
%node ILNode_TwoConditional ILNode_BinaryExpression
%node ILNode_CDeclarator ILNode_Dummy =
{
	CDeclarator decl;
}
%node ILNode_VaStart ILNode_Expression =
{
	ILNode *vaList;
	char *name;
}
%node ILNode_VaEnd ILNode_Expression =
{
	ILNode *vaList;
}
%node ILNode_VaArg ILNode_Expression =
{
	ILNode *vaList;
	ILType *type;
}
%node ILNode_SetJmp ILNode_UnaryExpression
%node ILNode_AllocA ILNode_UnaryExpression
%node ILNode_AsmStmt ILNode_Statement =
{
	char *code;
}

%output "c_semantics.c"

%{
#include <cscc/c/c_internal.h>
%}

/*
 * Define the C semantic analysis node operation.  "parent" points
 * to the position where "node" was loaded from, so it can be replaced
 * with a new node if necessary.  "stmtLevel" is non-zero if the parent
 * node is at the statement level of a function, or zero if the parent
 * is an expression node.
 */
%operation CSemValue ILNode_CSemAnalysis([ILNode *node], ILGenInfo *info,
									     ILNode **parent, int stmtLevel)
			= {CSemValueDefault}

/*
 * Include C-specific definitions.
 */
%include "c_builtin.tc"
%include "c_const.tc"
%include "c_lvalue.tc"
%include "c_invoke.tc"
%include "c_oper.tc"
%include "c_stmt.tc"
%include "c_stubs.tc"
