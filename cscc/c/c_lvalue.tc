/*
 * c_lvalue.tc - L-value node handling for C.
 *
 * Copyright (C) 2002  Southern Storm Software, Pty Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/*
 * Perform semantic analysis for a simple identifier.
 */
ILNode_CSemAnalysis(ILNode_Identifier)
{
	/* Nothing to do here: the grammar should have replaced this
	   node with something more appropriate by now */
	return CSemValueError;
}

/*
 * Perform semantic analysis for a member access node.
 */
ILNode_CSemAnalysis(ILNode_CMemberField)
{
	CSemValue value;
	ILType *type;
	ILType *fieldType;
	ILField *field;
	ILUInt32 bitFieldStart;
	ILUInt32 bitFieldSize;

	/* Perform semantic analysis on the primary expression */
	value = ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);
	if(!CSemIsRValue(value))
	{
		if(!CSemIsError(value))
		{
			goto typeError;
		}
		return CSemValueError;
	}

	/* Make sure that the expression is a structure or union */
	type = CSemGetType(value);
	if(!CTypeIsStruct(type) && !CTypeIsUnion(type))
	{
		goto typeError;
	}

	/* Search for the field within the type */
	field = CTypeLookupField(info, type, node->name,
							 &bitFieldStart, &bitFieldSize);
	if(!field)
	{
		if(CTypeIsStruct(type))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
			  			  _("structure has no member named `%s'"),
			  			  node->name);
		}
		else
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
			  			  _("union has no member named `%s'"),
			  			  node->name);
		}
		return CSemValueError;
	}

	/* Save the field for the code generator */
	node->field = field;

	/* Determine if the result is an l-value or an r-value */
	fieldType = ILField_Type(field);
	if(CTypeIsConst(type))
	{
		/* Add back the "const" modifier from the struct type */
		fieldType = CTypeAddConst(info, fieldType);
	}
	if(CTypeIsVolatile(type))
	{
		/* Add back the "volatile" modifier from the struct type */
		fieldType = CTypeAddVolatile(info, fieldType);
	}
	if(bitFieldSize != 0)
	{
		/* Replace this node with a bit field access node */
		if(CSemIsLValue(value))
		{
			*parent = ILNode_CBitField_create(node->expr, field,
											  ILTypeToMachineType(fieldType),
											  bitFieldStart, bitFieldSize, 1);
			CSemSetLValueNoRef(value, fieldType);
		}
		else
		{
			*parent = ILNode_CBitField_create(node->expr, field,
											  ILTypeToMachineType(fieldType),
											  bitFieldStart, bitFieldSize, 0);
			CSemSetRValue(value, fieldType);
		}
		CGenCloneLine(*parent, (ILNode *)node);
	}
	else if(CTypeIsArray(fieldType))
	{
		if(!CSemIsLValue(value))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
			  			  _("invalid use of non-lvalue array"));
		}
		CSemSetRValue(value, CTypeDecay(info, fieldType));
	}
	else
	{
		if(CSemIsLValue(value))
		{
			CSemSetLValue(value, fieldType);
		}
		else
		{
			CSemSetRValue(value, fieldType);
		}
	}
	return value;

	/* Report that the type is not consistent with the operation */
typeError:
	CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
		  _("request for member `%s' in something not a structure or union"),
		  node->name);
	return CSemValueError;
}

/*
 * Get the type of a member access node.
 */
ILNode_GetType(ILNode_CMemberField)
{
	ILType *type = ILField_Type(node->field);
	if(CTypeIsArray(type))
	{
		/* Arrays decay to r-value pointers when accessed */
		return ILMachineType_UnmanagedPtr;
	}
	else
	{
		return ILTypeToMachineType(type);
	}
}

/*
 * Generate discard code for a member access node.
 */
ILNode_GenDiscard(ILNode_CMemberField)
{
	ILNode_GenDiscard(node->expr, info);
}

/*
 * Generate value code for a member access node.
 */
ILNode_GenValue(ILNode_CMemberField)
{
	ILType *type = ILField_Type(node->field);
	if(yyisa(node->expr, ILNode_LValue))
	{
		CGenAddress(info, node->expr);
	}
	else
	{
		ILNode_GenValue(node->expr, info);
	}
	if(CTypeIsArray(type))
	{
		/* Arrays decay to r-value pointers when accessed */
		ILGenFieldRef(info, IL_OP_LDFLDA, node->field);
		return ILMachineType_UnmanagedPtr;
	}
	else
	{
		ILGenFieldRef(info, IL_OP_LDFLD, node->field);
		return ILTypeToMachineType(type);
	}
}
JavaGenValue(ILNode_CMemberField)
{
	/* Nothing to do here: will never be called */
	return ILMachineType_Void;
}

/*
 * Prepare to store to a member access node.
 */
ILNode_Prepare(ILNode_CMemberField)
{
	CGenAddress(info, node->expr);
	return ILTypeToMachineType(ILField_Type(node->field));
}
JavaPrepare(ILNode_CMemberField)
{
	/* Nothing to do here: will never be called */
	return ILMachineType_Void;
}

/*
 * Get and prepare to store to a member access node.
 */
ILNode_GetAndPrepare(ILNode_CMemberField)
{
	ILType *type = ILField_Type(node->field);
	CGenAddress(info, node->expr);
	ILGenSimple(info, IL_OP_DUP);
	ILGenAdjust(info, 1);
	ILGenFieldRef(info, IL_OP_LDFLD, node->field);
	if(leave)
	{
		/* Rearrange the stack to leave the value in the correct position */
		unsigned tempVar1 = ILGenTempTypedVar(info, type);
		unsigned tempVar2 = ILGenTempTypedVar(info, ILType_Int);
		ILGenStoreLocal(info, tempVar1);
		ILGenStoreLocal(info, tempVar2);
		ILGenLoadLocal(info, tempVar1);
		ILGenLoadLocal(info, tempVar2);
		ILGenLoadLocal(info, tempVar1);
		ILGenAdjust(info, 1);
		ILGenReleaseTempVar(info, tempVar1);
		ILGenReleaseTempVar(info, tempVar2);
	}
	return ILTypeToMachineType(ILField_Type(node->field));
}
JavaGetAndPrepare(ILNode_CMemberField)
{
	/* Nothing to do here: will never be called */
	return ILMachineType_Void;
}

/*
 * Store to a member access node.
 */
ILNode_Store(ILNode_CMemberField)
{
	if(leave)
	{
		ILType *type = ILField_Type(node->field);
		unsigned tempVar1 = ILGenTempTypedVar(info, type);
		ILGenSimple(info, IL_OP_DUP);
		ILGenAdjust(info, 1);
		ILGenStoreLocal(info, tempVar1);
		ILGenFieldRef(info, IL_OP_STFLD, node->field);
		ILGenAdjust(info, -2);
		ILGenLoadLocal(info, tempVar1);
		ILGenReleaseTempVar(info, tempVar1);
	}
	else
	{
		ILGenFieldRef(info, IL_OP_STFLD, node->field);
		ILGenAdjust(info, -2);
	}
}
JavaStore(ILNode_CMemberField)
{
	/* Nothing to do here: will never be called */
}

/*
 * Generate a reference for a member access node.
 */
ILNode_GenRef(ILNode_CMemberField)
{
	CGenAddress(info, (ILNode *)node);
}

/*
 * Generate the address of a member access node.
 */
ILNode_CGenAddress(ILNode_CMemberField)
{
	CAddress addr;
	ILFieldLayout *layout = ILFieldLayoutGetFromOwner(node->field);
	if(layout)
	{
		/* Adjust the address using the field's explict offset */
		addr = ILNode_CGenAddress((ILNode_LValue *)(node->expr), info);
		addr.offset += (ILInt32)(ILFieldLayoutGetOffset(layout));
	}
	else
	{
		/* We need to use "ldflda" to find the field's dynamic address */
		CGenAddress(info, node->expr);
		ILGenFieldRef(info, IL_OP_LDFLDA, node->field);
		addr.ptrOnStack = 1;
		addr.offset = 0;
	}
	return addr;
}

/*
 * Perform semantic analysis for a field dereference node.
 */
ILNode_CSemAnalysis(ILNode_CDerefField)
{
	CSemValue value;
	ILType *type;
	ILType *structType;
	ILType *fieldType;
	ILField *field;
	ILUInt32 bitFieldStart;
	ILUInt32 bitFieldSize;

	/* Perform semantic analysis on the primary expression */
	value = ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);
	if(!CSemIsRValue(value))
	{
		if(!CSemIsError(value))
		{
			goto typeError;
		}
		return CSemValueError;
	}

	/* Make sure that the expression is a pointer to a structure or union */
	type = CSemGetType(value);
	if(!CTypeIsPointer(type))
	{
		goto typeError;
	}
	structType = CTypeGetPtrRef(type);
	if(!CTypeIsStruct(structType) && !CTypeIsUnion(structType))
	{
		goto typeError;
	}

	/* Search for the field within the type */
	field = CTypeLookupField(info, type, node->name,
							 &bitFieldStart, &bitFieldSize);
	if(!field)
	{
		if(CTypeIsStruct(type))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
			  			  _("structure has no member named `%s'"),
			  			  node->name);
		}
		else
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
			  			  _("union has no member named `%s'"),
			  			  node->name);
		}
		return CSemValueError;
	}

	/* Save the field for the code generator */
	node->field = field;

	/* Determine if the result is an l-value or an r-value */
	fieldType = ILField_Type(field);
	if(CTypeIsConst(structType))
	{
		/* Add back the "const" modifier from the struct type */
		fieldType = CTypeAddConst(info, fieldType);
	}
	if(CTypeIsVolatile(structType))
	{
		/* Add back the "volatile" modifier from the struct type */
		fieldType = CTypeAddVolatile(info, fieldType);
	}
	if(bitFieldSize != 0)
	{
		/* Replace this node with a bit field access node */
		*parent = ILNode_CBitField_create(node->expr, field,
										  ILTypeToMachineType(fieldType),
										  bitFieldStart, bitFieldSize, 0);
		CGenCloneLine(*parent, (ILNode *)node);
		CSemSetLValueNoRef(value, fieldType);
	}
	else if(CTypeIsArray(fieldType))
	{
		CSemSetRValue(value, CTypeDecay(info, fieldType));
	}
	else
	{
		CSemSetLValue(value, fieldType);
	}
	return value;

	/* Report that the type is not consistent with the operation */
typeError:
	CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
		  _("request for member `%s' in something not a structure or union"),
		  node->name);
	return CSemValueError;
}

/*
 * Get the type of a field dereference node.
 */
ILNode_GetType(ILNode_CDerefField)
{
	ILType *type = ILField_Type(node->field);
	if(CTypeIsArray(type))
	{
		/* Arrays decay to r-value pointers when accessed */
		return ILMachineType_UnmanagedPtr;
	}
	else
	{
		return ILTypeToMachineType(type);
	}
}

/*
 * Generate discard code for a field deference node.
 */
ILNode_GenDiscard(ILNode_CDerefField)
{
	ILNode_GenDiscard(node->expr, info);
}

/*
 * Generate value code for a field dereference node.
 */
ILNode_GenValue(ILNode_CDerefField)
{
	ILType *type = ILField_Type(node->field);
	ILNode_GenValue(node->expr, info);
	if(CTypeIsArray(type))
	{
		/* Arrays decay to r-value pointers when accessed */
		ILGenFieldRef(info, IL_OP_LDFLDA, node->field);
		return ILMachineType_UnmanagedPtr;
	}
	else
	{
		ILGenFieldRef(info, IL_OP_LDFLD, node->field);
		return ILTypeToMachineType(type);
	}
}
JavaGenValue(ILNode_CDerefField)
{
	/* Nothing to do here: will never be called */
	return ILMachineType_Void;
}

/*
 * Prepare to store to a field dereference node.
 */
ILNode_Prepare(ILNode_CDerefField)
{
	ILNode_GenValue(node->expr, info);
	return ILTypeToMachineType(ILField_Type(node->field));
}
JavaPrepare(ILNode_CDerefField)
{
	/* Nothing to do here: will never be called */
	return ILMachineType_Void;
}

/*
 * Get and prepare to store to a field dereference node.
 */
ILNode_GetAndPrepare(ILNode_CDerefField)
{
	ILType *type = ILField_Type(node->field);
	ILNode_GenValue(node->expr, info);
	ILGenSimple(info, IL_OP_DUP);
	ILGenAdjust(info, 1);
	ILGenFieldRef(info, IL_OP_LDFLD, node->field);
	if(leave)
	{
		/* Rearrange the stack to leave the value in the correct position */
		unsigned tempVar1 = ILGenTempTypedVar(info, type);
		unsigned tempVar2 = ILGenTempTypedVar(info, ILType_Int);
		ILGenStoreLocal(info, tempVar1);
		ILGenStoreLocal(info, tempVar2);
		ILGenLoadLocal(info, tempVar1);
		ILGenLoadLocal(info, tempVar2);
		ILGenLoadLocal(info, tempVar1);
		ILGenAdjust(info, 1);
		ILGenReleaseTempVar(info, tempVar1);
		ILGenReleaseTempVar(info, tempVar2);
	}
	return ILTypeToMachineType(ILField_Type(node->field));
}
JavaGetAndPrepare(ILNode_CDerefField)
{
	/* Nothing to do here: will never be called */
	return ILMachineType_Void;
}

/*
 * Store to a field dereference node.
 */
ILNode_Store(ILNode_CDerefField)
{
	if(leave)
	{
		ILType *type = ILField_Type(node->field);
		unsigned tempVar1 = ILGenTempTypedVar(info, type);
		ILGenSimple(info, IL_OP_DUP);
		ILGenAdjust(info, 1);
		ILGenStoreLocal(info, tempVar1);
		ILGenFieldRef(info, IL_OP_STFLD, node->field);
		ILGenAdjust(info, -2);
		ILGenLoadLocal(info, tempVar1);
		ILGenReleaseTempVar(info, tempVar1);
	}
	else
	{
		ILGenFieldRef(info, IL_OP_STFLD, node->field);
		ILGenAdjust(info, -2);
	}
}
JavaStore(ILNode_CDerefField)
{
	/* Nothing to do here: will never be called */
}

/*
 * Generate a reference for a field dereference node.
 */
ILNode_GenRef(ILNode_CDerefField)
{
	CGenAddress(info, (ILNode *)node);
}

/*
 * Generate the address of a field dereference node.
 */
ILNode_CGenAddress(ILNode_CDerefField)
{
	CAddress addr;
	ILFieldLayout *layout = ILFieldLayoutGetFromOwner(node->field);
	ILNode_GenValue(node->expr, info);
	addr.ptrOnStack = 1;
	if(layout)
	{
		/* Adjust the address using the field's explict offset */
		addr.offset = (ILInt32)(ILFieldLayoutGetOffset(layout));
	}
	else
	{
		/* We need to use "ldflda" to find the field's dynamic address */
		ILGenFieldRef(info, IL_OP_LDFLDA, node->field);
		addr.offset = 0;
	}
	return addr;
}

/*
 * Perform semantic analysis for a local variable reference.
 */
ILNode_CSemAnalysis(ILNode_LocalVar),
ILNode_CSemAnalysis(ILNode_ArgumentVar)
{
	/* These node types aren't used by the grammar */
	return CSemValueError;
}

/*
 * Generate the address of a local variable reference.
 */
ILNode_CGenAddress(ILNode_LocalVar),
ILNode_CGenAddress(ILNode_ArgumentVar)
{
	/* These node types aren't used by the grammar */
	return CAddressDefault;
}

/*
 * Perform semantic analysis for a C local variable reference.
 */
ILNode_CSemAnalysis(ILNode_CLocalVar)
{
	CSemValue value;
	if(node->type != node->decayedType)
	{
		/* This is an array that decays to an r-value pointer */
		CSemSetRValue(value, node->decayedType);
	}
	else
	{
		/* This type doesn't decay, so it is an l-value */
		CSemSetLValue(value, node->type);
	}
	return value;
}

/*
 * Generate value code for a C local variable reference.
 * This overrides the standard code in "codegen" so that
 * we can handle arrays that decay into pointers.
 */
ILNode_GenValue(ILNode_CLocalVar)
{
	if(node->type == node->decayedType)
	{
		/* This is an ordinary local variable */
		ILGenLoadLocal(info, node->index);
		ILGenAdjust(info, 1);
	}
	else
	{
		/* This local variable decays immediately into a pointer */
		ILGenLoadLocalAddr(info, node->index);
		ILGenAdjust(info, 1);
	}
	return node->machineType;
}

/*
 * Generate the address of a local variable reference.
 */
ILNode_CGenAddress(ILNode_CLocalVar)
{
	CAddress addr;
	ILGenLoadLocalAddr(info, node->index);
	ILGenAdjust(info, 1);
	addr.ptrOnStack = 1;
	addr.offset = 0;
	return addr;
}

/*
 * Perform semantic analysis for a C argument variable reference.
 */
ILNode_CSemAnalysis(ILNode_CArgumentVar)
{
	CSemValue value;
	CSemSetLValue(value, node->type);
	return value;
}

/*
 * Generate the address of an argument reference.
 */
ILNode_CGenAddress(ILNode_CArgumentVar)
{
	CAddress addr;
	ILGenLoadArgAddr(info, node->index);
	ILGenAdjust(info, 1);
	addr.ptrOnStack = 1;
	addr.offset = 0;
	return addr;
}

/*
 * Perform semantic analysis for a C global variable reference.
 */
ILNode_CSemAnalysis(ILNode_CGlobalVar)
{
	CSemValue value;
	if(node->type != node->decayedType)
	{
		/* This is an array that decays to an r-value pointer */
		CSemSetRValue(value, node->decayedType);
	}
	else
	{
		/* This type doesn't decay, so it is an l-value */
		CSemSetLValue(value, node->type);
	}
	return value;
}

/*
 * Get the type of a C global variable reference.
 */
ILNode_GetType(ILNode_CGlobalVar)
{
	return ILTypeToMachineType(node->decayedType);
}

/*
 * Generate discard code for a C global variable reference.
 */
ILNode_GenDiscard(ILNode_CGlobalVar)
{
	/* Nothing to do here */
}

/*
 * Generate value code for a C global variable reference.
 */
ILNode_GenValue(ILNode_CGlobalVar)
{
	if(info->asmOutput)
	{
		if(node->type == node->decayedType)
		{
			fputs("\tldsfld\t", info->asmOutput);
		}
		else
		{
			fputs("\tldsflda\t", info->asmOutput);
		}
		ILDumpType(info->asmOutput, info->image, node->type,
				   IL_DUMP_QUOTE_NAMES);
		putc(' ', info->asmOutput);
		ILDumpIdentifier(info->asmOutput, node->name, 0,
						 IL_DUMP_QUOTE_NAMES);
		putc('\n', info->asmOutput);
	}
	ILGenAdjust(info, 1);
	return ILTypeToMachineType(node->decayedType);
}

/*
 * Prepare a C global variable reference to be stored in.
 */
ILNode_Prepare(ILNode_CGlobalVar)
{
	/* Nothing to do here */
	return ILTypeToMachineType(node->decayedType);
}

/*
 * Get and prepare a C global variable reference.
 */
ILNode_GetAndPrepare(ILNode_CGlobalVar)
{
	if(info->asmOutput)
	{
		fputs("\tldsfld\t", info->asmOutput);
		ILDumpType(info->asmOutput, info->image, node->type,
				   IL_DUMP_QUOTE_NAMES);
		putc(' ', info->asmOutput);
		ILDumpIdentifier(info->asmOutput, node->name, 0,
						 IL_DUMP_QUOTE_NAMES);
		putc('\n', info->asmOutput);
	}
	ILGenAdjust(info, 1);
	if(leave)
	{
		ILGenSimple(info, IL_OP_DUP);
		ILGenAdjust(info, 1);
	}
	return ILTypeToMachineType(node->decayedType);
}

/*
 * Store into a C global variable reference.
 */
ILNode_Store(ILNode_CGlobalVar)
{
	if(leave)
	{
		ILGenSimple(info, IL_OP_DUP);
		ILGenAdjust(info, 1);
	}
	fputs("\tstsfld\t", info->asmOutput);
	ILDumpType(info->asmOutput, info->image, node->type,
			   IL_DUMP_QUOTE_NAMES);
	putc(' ', info->asmOutput);
	ILDumpIdentifier(info->asmOutput, node->name, 0,
					 IL_DUMP_QUOTE_NAMES);
	putc('\n', info->asmOutput);
	ILGenAdjust(info, -1);
}

/*
 * Generate an address for a C global variable reference.
 */
ILNode_GenRef(ILNode_CGlobalVar)
{
	if(info->asmOutput)
	{
		fputs("\tldsflda\t", info->asmOutput);
		ILDumpType(info->asmOutput, info->image, node->type,
				   IL_DUMP_QUOTE_NAMES);
		putc(' ', info->asmOutput);
		ILDumpIdentifier(info->asmOutput, node->name, 0,
						 IL_DUMP_QUOTE_NAMES);
		putc('\n', info->asmOutput);
	}
	ILGenAdjust(info, 1);
}

/*
 * Generate the address of a global variable reference.
 */
ILNode_CGenAddress(ILNode_CGlobalVar)
{
	CAddress addr;
	ILNode_GenRef((ILNode_LValue *)node, info);
	addr.ptrOnStack = 1;
	addr.offset = 0;
	return addr;
}

/*
 * Stub out unnecessary Java code generation functions.
 */
JavaGenValue(ILNode_CGlobalVar),
JavaPrepare(ILNode_CGlobalVar),
JavaGetAndPrepare(ILNode_CGlobalVar)
{
	/* Never called: nothing to do here */
	return ILTypeToMachineType(node->decayedType);
}
JavaStore(ILNode_CGlobalVar)
{
	/* Never called: nothing to do here */
}

/*
 * Perform semantic analysis for an array access node.
 */
ILNode_CSemAnalysis(ILNode_CArrayAccess)
{
	CSemValue value1;
	CSemValue value2;
	CSemValue tempValue;
	ILNode *tempNode;
	ILType *rawElemType;
	ILType *elemType;

	/* Perform semantic analysis on the two values.  We deliberately
	   turn off "stmtLevel" processing, because we don't know if we
	   may need to swap the values below.  This only affects "setjmp"
	   and "alloca", which probably won't be present here anyway */
	value1 = ILNode_CSemAnalysis(node->array, info, &(node->array), 0);
	value2 = ILNode_CSemAnalysis(node->indices, info, &(node->indices), 0);

	/* Swap the values if the second is the pointer.  We need to do
	   this to support code of the form "3[p]", which is legal ANSI C,
	   but not necessarily a very smart coding convention */
	if(CSemIsRValue(value1) && CSemIsRValue(value2) &&
	   !CTypeIsPointer(CSemGetType(value1)) &&
	   CTypeIsPointer(CSemGetType(value2)))
	{
		tempValue = value1;
		value1 = value2;
		value2 = tempValue;
		tempNode = node->array;
		node->array = node->indices;
		node->indices = tempNode;
	}

	/* Validate the arguments to the array access operator */
	if(!CSemIsRValue(value1) || !CTypeIsPointer(CSemGetType(value1)))
	{
		if(!CSemIsError(value1))
		{
			CCErrorOnLine(yygetfilename(node->array),
						  yygetlinenum(node->array),
						  _("subscripted value is neither array nor pointer"));
		}
		elemType = 0;
		rawElemType = 0;
	}
	else
	{
		rawElemType = CTypeGetPtrRef(CSemGetType(value1));
		elemType = CTypeDecay(info, rawElemType);
		if(ILTypeStripPrefixes(elemType) == ILType_Void)
		{
			CCErrorOnLine(yygetfilename(node->array),
						  yygetlinenum(node->array),
						  _("dereferencing `void *' pointer"));
		}
	}
	if(!CSemIsRValue(value2) || !CTypeIsInteger(CSemGetType(value2)))
	{
		if(!CSemIsError(value2))
		{
			CCErrorOnLine(yygetfilename(node->indices),
						  yygetlinenum(node->indices),
						  _("array subscript is not an integer"));
		}
	}

	/* Set the type values in the node, for use by the code generators */
	node->arrayType = CSemGetType(value1);
	node->elemType = elemType;

	/* Determine the final semantic value to return */
	if(elemType)
	{
		if(elemType == rawElemType)
		{
			/* Non-array element type, which is an l-value */
			CSemSetLValue(value1, elemType);
		}
		else
		{
			/* The array element decays into a pointer, which is an r-value */
			CSemSetRValue(value1, elemType);
		}
		return value1;
	}
	else
	{
		return CSemValueError;
	}
}

/*
 * Generate value code for an array access node.
 */
ILNode_GenValue(ILNode_CArrayAccess)
{
	ILMachineType type = ILTypeToMachineType(node->elemType);

	/* Push the address of the array element onto the stack */
	CGenAddress(info, (ILNode *)node);

	/* Load the value from the pointer if not a sub-array */
	if(node->elemType == CTypeGetPtrRef(node->arrayType))
	{
		ILGenLoadManaged(info, type, ILTypeStripPrefixes(node->elemType));
	}

	/* Return the machine type for the element */
	return type;
}

/*
 * Prepare to store to an array access node.
 */
ILNode_Prepare(ILNode_CArrayAccess)
{
	/* Push the address of the array element onto the stack */
	CGenAddress(info, (ILNode *)node);

	/* Return the machine type for the element */
	return ILTypeToMachineType(node->elemType);
}

/*
 * Get and prepare to store to an array access node.
 */
ILNode_GetAndPrepare(ILNode_CArrayAccess)
{
	ILMachineType type = ILTypeToMachineType(node->elemType);
	unsigned tempVar1;
	unsigned tempVar2;

	/* Push the address of the array element onto the stack */
	CGenAddress(info, (ILNode *)node);

	/* Duplicate the pointer on the stack for the store */
	ILGenSimple(info, IL_OP_DUP);
	ILGenAdjust(info, 1);

	/* Load the current value from the pointer */
	ILGenLoadManaged(info, type, ILTypeStripPrefixes(node->elemType));

	/* Rearrange the contents of the stack if "leave" is set */
	if(leave)
	{
		tempVar1 = ILGenTempTypedVar(info, ILType_Int);
		tempVar2 = ILGenTempTypedVar
			(info, ILTypeStripPrefixes(node->elemType));
		ILGenStoreLocal(info, tempVar2);
		ILGenStoreLocal(info, tempVar1);
		ILGenLoadLocal(info, tempVar2);
		ILGenLoadLocal(info, tempVar1);
		ILGenLoadLocal(info, tempVar2);
		ILGenAdjust(info, 1);
		ILGenReleaseTempVar(info, tempVar1);
		ILGenReleaseTempVar(info, tempVar2);
	}

	/* Return the machine type for the element */
	return type;
}

/*
 * Store to an array access node.
 */
ILNode_Store(ILNode_CArrayAccess)
{
	ILMachineType type = ILTypeToMachineType(node->elemType);
	unsigned tempVar;
	if(leave)
	{
		tempVar = ILGenTempTypedVar
			(info, ILTypeStripPrefixes(node->elemType));
		ILGenSimple(info, IL_OP_DUP);
		ILGenAdjust(info, 1);
		ILGenStoreLocal(info, tempVar);
		ILGenStoreManaged(info, type, ILTypeStripPrefixes(node->elemType));
		ILGenLoadLocal(info, tempVar);
		ILGenAdjust(info, -2);
		ILGenReleaseTempVar(info, tempVar);
	}
	else
	{
		ILGenStoreManaged(info, type, ILTypeStripPrefixes(node->elemType));
		ILGenAdjust(info, -2);
	}
}

/*
 * Generate reference code for an array access node.
 */
ILNode_GenRef(ILNode_CArrayAccess)
{
	/* Generate the address of this node, and force its
	   conversion into a pointer value on the stack */
	CGenAddress(info, (ILNode *)node);
}

/*
 * Generate the address of an array access node.
 */
ILNode_CGenAddress(ILNode_CArrayAccess)
{
	CAddress addr;
	ILEvalValue value;
	ILUInt32 size;
	ILInt64 temp;

	/* Get the address of the array start */
	if(ILNode_EvalConst(node->array, info, &value) &&
	   value.valueType == ILMachineType_UnmanagedPtr)
	{
		addr.ptrOnStack = 0;
		addr.offset = value.un.i4Value;
	}
	else
	{
		ILNode_GenValue(node->array, info);
		addr.ptrOnStack = 1;
		addr.offset = 0;
	}

	/* Adjust the pointer by the array index */
	size = CTypeSizeAndAlign(node->elemType, 0);
	if(size != CTYPE_DYNAMIC && ILNode_EvalConst(node->indices, info, &value))
	{
		/* Adjust the address offset by a constant index */
		temp = (ILInt64)size;
		switch(value.valueType)
		{
			case ILMachineType_Int8:
			case ILMachineType_UInt8:
			case ILMachineType_Int16:
			case ILMachineType_UInt16:
			case ILMachineType_Char:
			case ILMachineType_Int32:
			{
				temp *= (ILInt64)(value.un.i4Value);
			}
			break;

			case ILMachineType_UInt32:
			{
				temp *= (ILInt64)(ILUInt32)(value.un.i4Value);
			}
			break;

			case ILMachineType_Int64:
			{
				if(value.un.i8Value >= (ILInt64)IL_MIN_INT32 &&
				   value.un.i8Value <= (ILInt64)IL_MAX_INT32)
				{
					temp *= value.un.i8Value;
				}
				else
				{
					goto force;
				}
			}
			break;

			case ILMachineType_UInt64:
			{
				if(value.un.i8Value >= 0 &&
				   value.un.i8Value <= (ILInt64)IL_MAX_INT32)
				{
					temp *= value.un.i8Value;
				}
				else
				{
					goto force;
				}
			}
			break;

			default: goto force;
		}
		temp += (ILInt64)(addr.offset);
		if(temp < (ILInt64)IL_MIN_INT32 || temp > (ILInt64)IL_MAX_INT32)
		{
			goto force;
		}
		addr.offset = (ILInt32)temp;
	}
	else
	{
	force:
		/* Force the pointer onto the stack */
		if(!(addr.ptrOnStack) && addr.offset != 0)
		{
			ILGenUIntNative(info, addr.offset);
			ILGenAdjust(info, 1);
			addr.ptrOnStack = 1;
			addr.offset = 0;
		}

		/* Push the array index value onto the stack */
		ILGenCast(info, ILNode_GenValue(node->indices, info),
				  ILMachineType_NativeInt);
		ILGenAdjust(info, 1);

		/* Multiply the array index by the element size */
		if(size != CTYPE_DYNAMIC)
		{
			switch(size)
			{
				case 1:		break;

				case 2:
				{
					ILGenSimple(info, IL_OP_LDC_I4_1);
					ILGenSimple(info, IL_OP_SHL);
					ILGenExtend(info, 1);
				}
				break;

				case 4:
				{
					ILGenSimple(info, IL_OP_LDC_I4_2);
					ILGenSimple(info, IL_OP_SHL);
					ILGenExtend(info, 1);
				}
				break;

				case 8:
				{
					ILGenSimple(info, IL_OP_LDC_I4_3);
					ILGenSimple(info, IL_OP_SHL);
					ILGenExtend(info, 1);
				}
				break;

				default:
				{
					ILGenIntNative(info, (ILInt32)size);
					ILGenSimple(info, IL_OP_MUL);
					ILGenExtend(info, 1);
				}
				break;
			}
		}
		else
		{
			CGenSizeOf(info, node->elemType);
			ILGenSimple(info, IL_OP_CONV_U);
			ILGenSimple(info, IL_OP_MUL);
			ILGenAdjust(info, -1);
		}

		/* Add the computed offset to the pointer */
		if(addr.ptrOnStack)
		{
			ILGenSimple(info, IL_OP_ADD);
			ILGenAdjust(info, -1);
		}
		else
		{
			/* The original pointer was NULL, so there is no need to add */
			addr.ptrOnStack = 1;
		}
	}

	/* Return the final address to the caller */
	return addr;
}

/*
 * Evaluate the constant value of an array access node.
 */
ILNode_EvalConst(ILNode_CArrayAccess)
{
	ILEvalValue arrayValue;
	ILEvalValue indexValue;
	ILUInt32 size;
	ILInt64 ptr;

	/* Evaluate the two arguments */
	if(!ILNode_EvalConst(node->array, info, &arrayValue) ||
	   arrayValue.valueType != ILMachineType_UnmanagedPtr ||
	   !ILNode_EvalConst(node->indices, info, &indexValue))
	{
		return 0;
	}

	/* Get the size of the array element type */
	size = CTypeSizeAndAlign(node->elemType, 0);
	if(size == CTYPE_DYNAMIC)
	{
		return 0;
	}

	/* Compute the new constant pointer value */
	ptr = (ILInt64)(arrayValue.un.i4Value);
	switch(indexValue.valueType)
	{
		case ILMachineType_Int8:
		case ILMachineType_UInt8:
		case ILMachineType_Int16:
		case ILMachineType_UInt16:
		case ILMachineType_Char:
		case ILMachineType_Int32:
		{
			ptr += ((ILInt64)(indexValue.un.i4Value)) * ((ILInt64)size);
		}
		break;

		case ILMachineType_UInt32:
		{
			ptr += ((ILInt64)(ILUInt32)(indexValue.un.i4Value))
						* ((ILInt64)size);
		}
		break;

		case ILMachineType_Int64:
		{
			if(indexValue.un.i8Value >= (ILInt64)IL_MIN_INT32 &&
			   indexValue.un.i8Value <= (ILInt64)IL_MAX_INT32)
			{
				ptr += indexValue.un.i8Value * ((ILInt64)size);
			}
			else
			{
				return 0;
			}
		}
		break;

		case ILMachineType_UInt64:
		{
			if(indexValue.un.i8Value >= 0 &&
			   indexValue.un.i8Value <= (ILInt64)IL_MAX_INT32)
			{
				ptr += indexValue.un.i8Value * ((ILInt64)size);
			}
			else
			{
				return 0;
			}
		}
		break;

		default: return 0;
	}

	/* Bail out if the constant pointer is outside the 32-bit range */
	if(ptr < (ILInt64)IL_MIN_INT32 || ptr > (ILInt64)IL_MAX_INT32)
	{
		return 0;
	}

	/* Create the new constant pointer value and return it */
	arrayValue.valueType = ILMachineType_UnmanagedPtr;
	arrayValue.un.i4Value = (ILInt32)ptr;
	return 1;
}

ILNode_CSemAnalysis(ILNode_ArrayInit)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for a pointer dereference node.
 */
ILNode_CSemAnalysis(ILNode_CDeref)
{
	CSemValue value;

	/* Perform semantic analysis on the pointer value */
	value = ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);
	if(!CSemIsRValue(value) || !CTypeIsPointer(CSemGetType(value)))
	{
		if(!CSemIsError(value))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  _("invalid argument to unary `*'"));
		}
		return CSemValueError;
	}

	/* Get the type of the pointed-to value */
	node->type = CTypeGetPtrRef(CSemGetType(value));
	node->machineType = ILTypeToMachineType(node->type);

	/* Return an l-value that corresponds to the pointed-to value */
	CSemSetLValue(value, node->type);
	return value;
}

/*
 * Get the type of a pointer dereference node.
 */
ILNode_GetType(ILNode_CDeref)
{
	return node->machineType;
}

/*
 * Generate discard code for a pointer dereference node.
 */
ILNode_GenDiscard(ILNode_CDeref)
{
	ILNode_GenDiscard(node->expr, info);
}

/*
 * Generate value code for a pointer dereference node.
 */
ILNode_GenValue(ILNode_CDeref)
{
	ILNode_GenValue(node->expr, info);
	ILGenLoadManaged(info, node->machineType,
					 ILTypeStripPrefixes(node->type));
	return node->machineType;
}
JavaGenValue(ILNode_CDeref)
{
	/* Never called: nothing to do here */
	return node->machineType;
}

/*
 * Prepare to store to a pointer dereference node.
 */
ILNode_Prepare(ILNode_CDeref)
{
	ILNode_GenValue(node->expr, info);
	return node->machineType;
}
JavaPrepare(ILNode_CDeref)
{
	/* Never called: nothing to do here */
	return node->machineType;
}

/*
 * Get and prepare to store to a pointer dereference node.
 */
ILNode_GetAndPrepare(ILNode_CDeref)
{
	ILNode_GenValue(node->expr, info);
	ILGenSimple(info, IL_OP_DUP);
	ILGenAdjust(info, 1);
	ILGenLoadManaged(info, node->machineType,
					 ILTypeStripPrefixes(node->type));
	if(leave)
	{
		/* Rearrange the stack to leave the value in the correct position */
		unsigned tempVar1 = ILGenTempTypedVar(info, node->type);
		unsigned tempVar2 = ILGenTempTypedVar(info, ILType_Int);
		ILGenStoreLocal(info, tempVar1);
		ILGenStoreLocal(info, tempVar2);
		ILGenLoadLocal(info, tempVar1);
		ILGenLoadLocal(info, tempVar2);
		ILGenLoadLocal(info, tempVar1);
		ILGenAdjust(info, 1);
		ILGenReleaseTempVar(info, tempVar1);
		ILGenReleaseTempVar(info, tempVar2);
	}
	return node->machineType;
}
JavaGetAndPrepare(ILNode_CDeref)
{
	/* Never called: nothing to do here */
	return node->machineType;
}

/*
 * Store to a pointer dereference node.
 */
ILNode_Store(ILNode_CDeref)
{
	if(leave)
	{
		unsigned tempVar1 = ILGenTempTypedVar(info, node->type);
		ILGenSimple(info, IL_OP_DUP);
		ILGenAdjust(info, 1);
		ILGenStoreLocal(info, tempVar1);
		ILGenStoreManaged(info, node->machineType,
						  ILTypeStripPrefixes(node->type));
		ILGenAdjust(info, -2);
		ILGenLoadLocal(info, tempVar1);
		ILGenReleaseTempVar(info, tempVar1);
	}
	else
	{
		ILGenStoreManaged(info, node->machineType,
						  ILTypeStripPrefixes(node->type));
		ILGenAdjust(info, -2);
	}
}
JavaStore(ILNode_CDeref)
{
	/* Never called: nothing to do here */
}

/*
 * Generate reference code for a pointer dereference node.
 */
ILNode_GenRef(ILNode_CDeref)
{
	CGenAddress(info, (ILNode *)node);
}

/*
 * Generate an address for a pointer dereference node.
 */
ILNode_CGenAddress(ILNode_CDeref)
{
	CAddress addr;
	ILNode_GenValue(node->expr, info);
	addr.ptrOnStack = 1;
	addr.offset = 0;
	return addr;
}

/*
 * Get the machine type for a bit field access node.
 */
ILNode_GetType(ILNode_CBitField)
{
	return node->machineType;
}

%output "c_nodes.c"

%{

/*
 * Convert a raw storage value into a bit field value.
 */
static void RawToBitField(ILGenInfo *info, ILMachineType type,
						  ILUInt32 start, ILUInt32 size)
{
	switch(type)
	{
		case ILMachineType_Int8:
		case ILMachineType_Int16:
		case ILMachineType_Int32:
		{
			/* Handle signed fields of 32 bits or less in size */
			if(size == 8)
			{
				if(start == (32 - 8))
				{
					ILGenUIntNative(info, start);
					ILGenSimple(info, IL_OP_SHR);
					ILGenExtend(info, 1);
				}
				else if(start != 0)
				{
					ILGenUIntNative(info, start);
					ILGenSimple(info, IL_OP_SHR);
					ILGenSimple(info, IL_OP_CONV_I1);
					ILGenExtend(info, 1);
				}
				else
				{
					ILGenSimple(info, IL_OP_CONV_I1);
				}
			}
			else if(size == 16)
			{
				if(start == (32 - 16))
				{
					ILGenUIntNative(info, start);
					ILGenSimple(info, IL_OP_SHR);
					ILGenExtend(info, 1);
				}
				else if(start != 0)
				{
					ILGenUIntNative(info, start);
					ILGenSimple(info, IL_OP_SHR);
					ILGenSimple(info, IL_OP_CONV_I2);
					ILGenExtend(info, 1);
				}
				else
				{
					ILGenSimple(info, IL_OP_CONV_I2);
				}
			}
			else
			{
				if((start + size) < 32)
				{
					ILGenUIntNative(info, 32 - (start + size));
					ILGenSimple(info, IL_OP_SHL);
					ILGenExtend(info, 1);
				}
				ILGenUIntNative(info, 32 - size);
				ILGenSimple(info, IL_OP_SHR);
				ILGenExtend(info, 1);
			}
		}
		break;

		case ILMachineType_UInt8:
		case ILMachineType_UInt16:
		case ILMachineType_Char:
		case ILMachineType_UInt32:
		{
			/* Handle unsigned fields of 32 bits or less in size */
			if(start != 0)
			{
				ILGenUIntNative(info, start);
				ILGenSimple(info, IL_OP_SHR_UN);
				ILGenExtend(info, 1);
			}
			if(size == 8)
			{
				ILGenSimple(info, IL_OP_CONV_U1);
			}
			else if(size == 16)
			{
				ILGenSimple(info, IL_OP_CONV_U2);
			}
			else
			{
				ILGenUInt32(info, (((ILUInt32)1) << size) - 1);
				ILGenSimple(info, IL_OP_AND);
				ILGenExtend(info, 1);
			}
		}
		break;

		case ILMachineType_Int64:
		{
			/* Handle 64-bit signed fields */
			if((start + size) < 64)
			{
				ILGenUIntNative(info, 64 - (start + size));
				ILGenSimple(info, IL_OP_SHL);
				ILGenExtend(info, 1);
			}
			ILGenUIntNative(info, 64 - size);
			ILGenSimple(info, IL_OP_SHR);
			ILGenExtend(info, 1);
		}
		break;

		case ILMachineType_UInt64:
		{
			/* Handle 64-bit unsigned fields */
			if(start != 0)
			{
				ILGenUIntNative(info, start);
				ILGenSimple(info, IL_OP_SHR_UN);
				ILGenExtend(info, 1);
			}
			ILGenUInt64(info, (((ILUInt64)1) << size) - 1);
			ILGenSimple(info, IL_OP_AND);
			ILGenExtend(info, 1);
		}
		break;

		default: break;
	}
}

/*
 * Duplicate a stack value that corresponds to a raw storage
 * value.  Mask off the bit field bits in the second top value,
 * and convert the top value from raw into a bit field.  This
 * prepares the stack for a later store operation.
 */
static void BitFieldGetAndPrepare(ILGenInfo *info, ILMachineType type,
							      ILUInt32 start, ILUInt32 size)
{
	unsigned tempVar;

	/* We need a temporary variable */
	tempVar = ILGenTempVar(info, type);

	/* Save the value in the temporary variable */
	ILGenSimple(info, IL_OP_DUP);
	ILGenStoreLocal(info, tempVar);
	ILGenExtend(info, 1);

	/* Mask off the bit field */
	if(type == ILMachineType_Int64 || type == ILMachineType_UInt64)
	{
		ILGenUInt64(info, ~(((((ILUInt64)1) << size) - 1) << start));
		ILGenSimple(info, IL_OP_AND);
		ILGenExtend(info, 1);
	}
	else
	{
		ILGenUInt32(info, ~(((((ILUInt32)1) << size) - 1) << start));
		ILGenSimple(info, IL_OP_AND);
		ILGenExtend(info, 1);
	}

	/* Reload the original value onto the stack */
	ILGenLoadLocal(info, tempVar);
	ILGenAdjust(info, 1);

	/* Convert from raw to final */
	RawToBitField(info, type, start, size);

	/* Release the temporary variable */
	ILGenReleaseTempVar(info, tempVar);
}

/*
 * Convert a bit field value into a raw storage value and OR
 * it with the original masked storage value that is already
 * on the stack.
 */
static void BitFieldToRaw(ILGenInfo *info, ILMachineType type,
						  ILUInt32 start, ILUInt32 size)
{
	switch(type)
	{
		case ILMachineType_Int8:
		case ILMachineType_UInt8:
		case ILMachineType_Int16:
		case ILMachineType_UInt16:
		case ILMachineType_Char:
		case ILMachineType_Int32:
		case ILMachineType_UInt32:
		{
			ILGenUInt32(info, (((ILUInt32)1) << size) - 1);
			ILGenSimple(info, IL_OP_AND);
			ILGenExtend(info, 1);
			if(start != 0)
			{
				ILGenUIntNative(info, start);
				ILGenSimple(info, IL_OP_SHL);
				ILGenExtend(info, 1);
			}
		}
		break;

		case ILMachineType_Int64:
		case ILMachineType_UInt64:
		{
			ILGenUInt64(info, (((ILUInt64)1) << size) - 1);
			ILGenSimple(info, IL_OP_AND);
			ILGenExtend(info, 1);
			if(start != 0)
			{
				ILGenUIntNative(info, start);
				ILGenSimple(info, IL_OP_SHL);
				ILGenExtend(info, 1);
			}
		}
		break;

		default: break;
	}
	ILGenSimple(info, IL_OP_OR);
	ILGenAdjust(info, -1);
}

%}

%output "c_semantics.c"

/*
 * Generate value code for a bit field access node.
 */
ILNode_GenValue(ILNode_CBitField)
{
	/* Push the address or value onto the stack */
	if(node->genExprAsAddr)
	{
		ILNode_GenRef((ILNode_LValue *)(node->expr), info);
	}
	else
	{
		ILNode_GenValue(node->expr, info);
	}

	/* Load the contents of the storage field */
	ILGenFieldRef(info, IL_OP_LDFLD, node->field);

	/* Mask off unnecessary bits, shift down, and sign-extend */
	RawToBitField(info, node->machineType, node->bitFieldStart,
				  node->bitFieldSize);

	/* Done */
	return node->machineType;
}
JavaGenValue(ILNode_CBitField)
{
	/* Never called: nothing to do here */
	return node->machineType;
}

/*
 * Prepare to store into a bit field access node.
 */
ILNode_Prepare(ILNode_CBitField)
{
	/* Push the address of the structure onto the stack */
	if(node->genExprAsAddr)
	{
		ILNode_GenRef((ILNode_LValue *)(node->expr), info);
	}
	else
	{
		ILNode_GenValue(node->expr, info);
	}

	/* Fetch the current value and mask off the bit field */
	ILGenSimple(info, IL_OP_DUP);
	ILGenFieldRef(info, IL_OP_LDFLD, node->field);
	ILGenAdjust(info, 1);
	if(node->machineType == ILMachineType_Int64 ||
	   node->machineType == ILMachineType_UInt64)
	{
		ILGenUInt64(info, ~(((((ILUInt64)1) << node->bitFieldSize) - 1)
								<< node->bitFieldStart));
		ILGenSimple(info, IL_OP_AND);
		ILGenExtend(info, 1);
	}
	else
	{
		ILGenUInt32(info, ~(((((ILUInt32)1) << node->bitFieldSize) - 1)
								<< node->bitFieldStart));
		ILGenSimple(info, IL_OP_AND);
		ILGenExtend(info, 1);
	}

	/* The bit field is prepared */
	return node->machineType;
}
JavaPrepare(ILNode_CBitField)
{
	/* Never called: nothing to do here */
	return node->machineType;
}

/*
 * Get and prepare to store into a bit field access node.
 */
ILNode_GetAndPrepare(ILNode_CBitField)
{
	/* Push the address of the structure onto the stack */
	if(node->genExprAsAddr)
	{
		ILNode_GenRef((ILNode_LValue *)(node->expr), info);
	}
	else
	{
		ILNode_GenValue(node->expr, info);
	}

	/* Fetch the current value of the storage field */
	ILGenSimple(info, IL_OP_DUP);
	ILGenFieldRef(info, IL_OP_LDFLD, node->field);
	ILGenAdjust(info, 1);

	/* Extract the bit field value and prepare the remainder for storing */
	BitFieldGetAndPrepare(info, node->machineType, node->bitFieldStart,
						  node->bitFieldSize);

	/* Save a copy of the value if we need to leave it on the stack */
	if(leave)
	{
		node->tempVar = ILGenTempVar(info, node->machineType);
		ILGenSimple(info, IL_OP_DUP);
		ILGenStoreLocal(info, node->tempVar);
		ILGenExtend(info, 1);
	}

	/* The bit field is prepared */
	return node->machineType;
}
JavaGetAndPrepare(ILNode_CBitField)
{
	/* Never called: nothing to do here */
	return node->machineType;
}

/*
 * Store into a bit field access node.
 */
ILNode_Store(ILNode_CBitField)
{
	unsigned tempVar = ~((unsigned)0);

	/* Save the value in a temporary variable if we need to leave it */
	if(leave)
	{
		tempVar = ILGenTempVar(info, node->machineType);
		ILGenSimple(info, IL_OP_DUP);
		ILGenStoreLocal(info, tempVar);
		ILGenExtend(info, 1);
	}

	/* Combine the value with the other parts of the storage field */
	BitFieldToRaw(info, node->machineType, node->bitFieldStart,
				  node->bitFieldSize);

	/* Store the combined value back into the storage field */
	ILGenFieldRef(info, IL_OP_STFLD, node->field);
	ILGenAdjust(info, -2);

	/* Reload the value onto the stack if necessary */
	if(leave)
	{
		ILGenLoadLocal(info, tempVar);
		ILGenAdjust(info, 1);
		ILGenReleaseTempVar(info, tempVar);
	}

	/* Did we have a "left" value from the "GetAndPrepare" call? */
	if(node->tempVar != ~((unsigned)0))
	{
		ILGenLoadLocal(info, node->tempVar);
		ILGenAdjust(info, 1);
		ILGenReleaseTempVar(info, node->tempVar);
		node->tempVar = ~((unsigned)0);
	}
}
JavaStore(ILNode_CBitField)
{
	/* Never called: nothing to do here */
}
