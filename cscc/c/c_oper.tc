/*
 * c_oper.tc - Operator handling for C.
 *
 * Copyright (C) 2002  Southern Storm Software, Pty Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/*
 * Perform semantic analysis for the logical NOT operator.
 */
ILNode_CSemAnalysis(ILNode_LogicalNot)
{
	ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);
	return CSemValueBool;
}

/*
 * Perform semantic analysis for the logical AND operator.
 */
ILNode_CSemAnalysis(ILNode_LogicalAnd)
{
	ILNode_CSemAnalysis(node->expr1, info, &(node->expr1), stmtLevel);
	ILNode_CSemAnalysis(node->expr2, info, &(node->expr2), stmtLevel);
	return CSemValueBool;
}

/*
 * Perform semantic analysis for the logical OR operator.
 */
ILNode_CSemAnalysis(ILNode_LogicalOr)
{
	ILNode_CSemAnalysis(node->expr1, info, &(node->expr1), stmtLevel);
	ILNode_CSemAnalysis(node->expr2, info, &(node->expr2), stmtLevel);
	return CSemValueBool;
}

%{

/*
 * Determine if a machine type is numeric or integer.
 */
#define	IsNumericMachineType(type)	\
			((type) >= ILMachineType_Int8 && \
			 (type) <= ILMachineType_NativeFloat)
#define	IsIntegerMachineType(type)	\
			((type) >= ILMachineType_Int8 && \
			 (type) <= ILMachineType_NativeUInt)
#define	IsSmallIntegerMachineType(type)	\
			((type) >= ILMachineType_Int8 && \
			 (type) <= ILMachineType_Int32)

/*
 * Determine if a machine type is a signed integer type.
 */
static int IsSignedMachineType(ILMachineType type)
{
	return (type == ILMachineType_Int8 ||
			type == ILMachineType_Int16 ||
			type == ILMachineType_Int32 ||
			type == ILMachineType_Int64);
}

/*
 * Multiply a node by a pointer element type size.
 */
static ILNode *MulPtrSize(ILNode *node, CSemValue value, ILType *elemType)
{
	ILUInt32 elemSize = CTypeSizeAndAlign(elemType, 0);
	ILEvalValue *evalValue = CSemGetConstant(value);
	ILNode *newNode;
	ILInt64 totalSize;
	if(elemSize != CTYPE_DYNAMIC)
	{
		/* The size is constant, so try to compute at compile time */
		if(elemSize == 0)
		{
			newNode = ILNode_Int_create(0, 0, 0);
			CGenCloneLine(newNode, node);
			return newNode;
		}
		else if(elemSize == 1)
		{
			return node;
		}
		if(evalValue && IsSmallIntegerMachineType(evalValue->valueType))
		{
			totalSize = ((ILInt64)elemSize) *
						((ILInt64)(evalValue->un.i4Value));
			if(totalSize >= (ILInt64)IL_MIN_INT32 &&
			   totalSize <= (ILInt64)IL_MAX_INT32)
			{
				if(totalSize >= 0)
				{
					newNode = ILNode_Int_create((ILUInt64)totalSize, 0, 1);
				}
				else
				{
					newNode = ILNode_Int_create
						((ILUInt64)(-totalSize), 1, 1);
				}
				CGenCloneLine(newNode, node);
				return newNode;
			}
		}
		if(elemSize == 2)
		{
			newNode = ILNode_Shl_create
				(node, ILNode_Int32_create(1, 0, 1));
		}
		else if(elemSize == 4)
		{
			newNode = ILNode_Shl_create
				(node, ILNode_Int32_create(2, 0, 1));
		}
		else if(elemSize == 8)
		{
			newNode = ILNode_Shl_create
				(node, ILNode_Int32_create(3, 0, 1));
		}
		else
		{
			newNode = ILNode_Mul_create
				(node, ILNode_UInt32_create((ILUInt32)elemSize, 0, 1));
		}
	}
	else
	{
		/* The size is dynamic: check for the simple 0 and 1 cases */
		if(evalValue && IsSmallIntegerMachineType(evalValue->valueType))
		{
			if(evalValue->un.i4Value == 0)
			{
				newNode = ILNode_Int_create(0, 0, 0);
				CGenCloneLine(newNode, node);
				return newNode;
			}
			else if(evalValue->un.i4Value == 1)
			{
				return node;
			}
		}
		newNode = ILNode_Mul_create(node, ILNode_SizeOfType_create(elemType));
	}
	CGenCloneLine(newNode, node);
	return newNode;
}

/*
 * Divide a pointer difference by an element size.
 */
static ILNode *DivPtrSize(ILNode *node, ILType *elemType)
{
	ILUInt32 elemSize = CTypeSizeAndAlign(elemType, 0);
	ILNode *newNode;
	if(elemSize != CTYPE_DYNAMIC)
	{
		if(elemSize == 1)
		{
			return node;
		}
		else if(elemSize == 2)
		{
			newNode = ILNode_Shr_create
				(node, ILNode_Int32_create(1, 0, 1));
		}
		else if(elemSize == 4)
		{
			newNode = ILNode_Shr_create
				(node, ILNode_Int32_create(2, 0, 1));
		}
		else if(elemSize == 8)
		{
			newNode = ILNode_Shr_create
				(node, ILNode_Int32_create(3, 0, 1));
		}
		else
		{
			newNode = ILNode_Div_create
				(node, ILNode_Int_create((ILInt32)elemSize, 0, 1));
		}
	}
	else
	{
		newNode = ILNode_Div_create(node, ILNode_SizeOfType_create(elemType));
	}
	CGenCloneLine(newNode, node);
	return newNode;
}

/*
 * Determine a common type for binary operators.
 */
static ILMachineType CommonBinaryType(ILGenInfo *info,
									  ILMachineType type1,
									  ILMachineType type2)
{
	ILMachineType common;

	/* Determine a common type using the codegen inference algorithm */
	common = ILCommonType(info, type1, type2, 0);

	/* Widen the common type to the natural type for the operation */
	switch(common)
	{
		case ILMachineType_Int8:
		case ILMachineType_UInt8:
		case ILMachineType_Int16:
		case ILMachineType_UInt16:
		case ILMachineType_Char:
		{
			common = ILMachineType_Int32;
		}
		break;

		case ILMachineType_Float32:
		{
			common = ILMachineType_Float64;
		}
		break;

		default: break;
	}

	/* Return the common type to the caller */
	return common;
}

/*
 * Binary operator kinds.
 */
#define	C_BINARY_ADD		0
#define	C_BINARY_SUB		1
#define	C_BINARY_REM		2
#define	C_BINARY_NUMERIC	3
#define	C_BINARY_BITWISE	4
#define	C_BINARY_SHIFT		5

/*
 * Perform semantic analysis for a binary operator.
 */
static CSemValue BinarySem(ILGenInfo *info, ILNode_BinaryExpression *node,
						   ILNode **parent, int stmtLevel,
						   const char *name, int opkind)
{
	CSemValue value1;
	CSemValue value2;
	ILMachineType type1;
	ILMachineType type2;
	ILMachineType common1;
	ILMachineType common2;
	ILNode *temp;
	ILType *elemType;
	ILType *elemType2;
	ILType *finalType = ILType_Invalid;

	/* Perform semantic analysis on the two arguments, and
	   check that they are both r-values */
	value1 = ILNode_CSemAnalysis(node->expr1, info, &(node->expr1), stmtLevel);
	value2 = ILNode_CSemAnalysis(node->expr2, info, &(node->expr2), 0);
	if(!CSemIsRValue(value1) || !CSemIsRValue(value2))
	{
		/* Pass error conditions up, but otherwise ignore the problem.
		   We've already reported the error at the lower level */
		if(CSemIsError(value1) || CSemIsError(value2))
		{
			return CSemValueError;
		}
		goto invalid;
	}

	/* Find a common type to use for the operation */
	type1 = ILTypeToMachineType(CSemGetType(value1));
	type2 = ILTypeToMachineType(CSemGetType(value2));
	if(opkind == C_BINARY_SHIFT)
	{
		/* Shift operator that can only support integer operands */
		if(IsIntegerMachineType(type1) && IsIntegerMachineType(type2))
		{
			common1 = CommonBinaryType(info, type1, type1);
			common2 = ILMachineType_Int32;
		}
		else
		{
			goto invalid;
		}
	}
	else if(opkind == C_BINARY_BITWISE || opkind == C_BINARY_REM)
	{
		/* Operator that can only support integer operands */
		if(IsIntegerMachineType(type1) && IsIntegerMachineType(type2))
		{
			common1 = common2 = CommonBinaryType(info, type1, type2);
		}
		else
		{
			goto invalid;
		}
	}
	else
	{
		/* The operator can support all numeric operands */
		if(IsNumericMachineType(type1) && IsNumericMachineType(type2))
		{
			common1 = common2 = CommonBinaryType(info, type1, type2);
		}
		else if(opkind == C_BINARY_ADD)
		{
			if(type1 == ILMachineType_UnmanagedPtr &&
			   IsIntegerMachineType(type2))
			{
				/* Add pointer and integer */
				elemType = CTypeGetPtrRef(CSemGetType(value1));
				node->expr2 = MulPtrSize(node->expr2, value2, elemType);
				if(IsSignedMachineType(type2))
				{
					common1 = common2 = ILMachineType_NativeInt;
				}
				else
				{
					common1 = common2 = ILMachineType_NativeUInt;
				}
				finalType = CSemGetType(value1);
			}
			else if(type2 == ILMachineType_UnmanagedPtr &&
			        IsIntegerMachineType(type1))
			{
				/* Add integer and pointer */
				elemType = CTypeGetPtrRef(CSemGetType(value2));
				node->expr1 = MulPtrSize(node->expr1, value1, elemType);
				if(IsSignedMachineType(type1))
				{
					common1 = common2 = ILMachineType_NativeInt;
				}
				else
				{
					common1 = common2 = ILMachineType_NativeUInt;
				}
				finalType = CSemGetType(value2);
			}
			else
			{
				goto invalid;
			}
		}
		else if(opkind == C_BINARY_SUB)
		{
			if(type1 == ILMachineType_UnmanagedPtr &&
			   IsIntegerMachineType(type2))
			{
				/* Subtract pointer and integer */
				elemType = CTypeGetPtrRef(CSemGetType(value1));
				node->expr2 = MulPtrSize(node->expr2, value2, elemType);
				if(IsSignedMachineType(type2))
				{
					common1 = common2 = ILMachineType_NativeInt;
				}
				else
				{
					common1 = common2 = ILMachineType_NativeUInt;
				}
				finalType = CSemGetType(value1);
			}
			else if(type1 == ILMachineType_UnmanagedPtr &&
			        type2 == ILMachineType_UnmanagedPtr)
			{
				/* Subtract pointer and pointer */
				elemType = ILTypeStripPrefixes
					(CTypeGetPtrRef(CSemGetType(value1)));
				elemType2 = ILTypeStripPrefixes
					(CTypeGetPtrRef(CSemGetType(value2)));
				if(!CTypeIsIdentical(elemType, elemType2))
				{
					goto invalid;
				}
				temp = ILNode_CastSimple_create
					(node->expr1, ILMachineType_NativeInt);
				CGenCloneLine(temp, node->expr1);
				node->expr1 = temp;
				temp = ILNode_CastSimple_create
					(node->expr2, ILMachineType_NativeInt);
				CGenCloneLine(temp, node->expr2);
				node->expr2 = temp;
				*parent = DivPtrSize((ILNode *)node, elemType);
				if(CTypePtrSize == 4)
				{
					*parent = ILNode_CastSimple_create
						(*parent, ILMachineType_Int32);
					CGenCloneLine(*parent, (ILNode *)node);
					CSemSetRValue(value1, ILType_Int32);
				}
				else
				{
					*parent = ILNode_CastSimple_create
						(*parent, ILMachineType_Int64);
					CGenCloneLine(*parent, (ILNode *)node);
					CSemSetRValue(value1, ILType_Int64);
				}
				return value1;
			}
			else
			{
				goto invalid;
			}
		}
		else
		{
			goto invalid;
		}
	}

	/* Cast the arguments to their final types and return */
	if(common1 != type1)
	{
		temp = ILNode_CastSimple_create(node->expr1, common1);
		CGenCloneLine(temp, node->expr1);
		node->expr1 = temp;
	}
	if(common2 != type2)
	{
		temp = ILNode_CastSimple_create(node->expr2, common2);
		CGenCloneLine(temp, node->expr2);
		node->expr2 = temp;
	}
	if(finalType == ILType_Invalid)
	{
		/* Simple numeric calculation */
		CSemSetRValue(value1, ILValueTypeToType(info, common1));
	}
	else
	{
		/* Pointer calculation */
		*parent = ILNode_CastSimple_create
			((ILNode *)node, ILMachineType_UnmanagedPtr);
		CSemSetRValue(value1, finalType);
	}
	return value1;

	/* Report an invalid operands error and bail out */
invalid:
	CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
				  _("invalid operands to binary `%s'"), name);
	return CSemValueError;
}

/*
 * Perform semantic analysis for binary operator assignment.
 */
static CSemValue AssignSem(ILGenInfo *info, ILNode_BinaryExpression *node,
						   ILNode **parent, const char *name, int opkind)
{
	CSemValue value1;
	CSemValue value2;
	ILMachineType type1;
	ILMachineType type2;
	ILMachineType common2;
	ILNode *temp;
	ILType *elemType;

	/* Perform semantic analysis on the two arguments, and check
	   that the first is an l-value and second an r-value */
	value1 = ILNode_CSemAnalysis(node->expr1, info, &(node->expr1), 0);
	value2 = ILNode_CSemAnalysis(node->expr2, info, &(node->expr2), 0);
	if(!CSemIsLValue(value1))
	{
		if(!CSemIsError(value1))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  _("invalid lvalue in assignment"));
		}
		if(!CSemIsRValue(value2) && !CSemIsError(value2))
		{
			goto invalid;
		}
		return CSemValueError;
	}
	if(!CSemIsRValue(value2))
	{
		/* Pass error conditions up, but otherwise ignore the problem.
		   We've already reported the error at the lower level */
		if(CSemIsError(value2))
		{
			return CSemValueError;
		}
		goto invalid;
	}

	/* Find a common type to use for the operation */
	type1 = ILTypeToMachineType(CSemGetType(value1));
	type2 = ILTypeToMachineType(CSemGetType(value2));
	if(opkind == C_BINARY_SHIFT)
	{
		/* Shift operator that can only support integer operands */
		if(IsIntegerMachineType(type1) && IsIntegerMachineType(type2))
		{
			common2 = ILMachineType_Int32;
		}
		else
		{
			goto invalid;
		}
	}
	else if(opkind == C_BINARY_BITWISE || opkind == C_BINARY_REM)
	{
		/* Operator that can only support integer operands */
		if(IsIntegerMachineType(type1) && IsIntegerMachineType(type2))
		{
			common2 = type1;
		}
		else
		{
			goto invalid;
		}
	}
	else
	{
		/* The operator can support all numeric operands */
		if(IsNumericMachineType(type1) && IsNumericMachineType(type2))
		{
			common2 = type1;
		}
		else if(opkind == C_BINARY_ADD)
		{
			if(type1 == ILMachineType_UnmanagedPtr &&
			   IsIntegerMachineType(type2))
			{
				/* Add pointer and integer */
				elemType = CTypeGetPtrRef(CSemGetType(value1));
				node->expr2 = MulPtrSize(node->expr2, value2, elemType);
				if(IsSignedMachineType(type2))
				{
					common2 = ILMachineType_NativeInt;
				}
				else
				{
					common2 = ILMachineType_NativeUInt;
				}
			}
			else
			{
				goto invalid;
			}
		}
		else if(opkind == C_BINARY_SUB)
		{
			if(type1 == ILMachineType_UnmanagedPtr &&
			   IsIntegerMachineType(type2))
			{
				/* Subtract pointer and integer */
				elemType = CTypeGetPtrRef(CSemGetType(value1));
				node->expr2 = MulPtrSize(node->expr2, value2, elemType);
				if(IsSignedMachineType(type2))
				{
					common2 = ILMachineType_NativeInt;
				}
				else
				{
					common2 = ILMachineType_NativeUInt;
				}
			}
			else
			{
				goto invalid;
			}
		}
		else
		{
			goto invalid;
		}
	}

	/* Cast the arguments to their final types and return */
	if(common2 != type2)
	{
		temp = ILNode_CastSimple_create(node->expr2, common2);
		CGenCloneLine(temp, node->expr2);
		node->expr2 = temp;
	}
	CSemSetRValue(value1, CSemGetType(value1));
	return value1;

	/* Report an invalid operands error and bail out */
invalid:
	CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
				  _("invalid operands to binary `%s'"), name);
	return CSemValueError;
}

/*
 * Perform semantic analysis for increment or decrement expressions.
 */
static CSemValue IncOrDecSem(ILGenInfo *info, ILNode_UnaryExpression *node,
						     ILNode **parent, const char *name)
{
	CSemValue value;
	ILMachineType type;
	ILType *elemType;
	ILUInt32 elemSize;
	ILClass *elemClass;
	ILNode *newNode;

	/* Perform semantic analysis on the l-value argument */
	value = ILNode_CSemAnalysis(node->expr, info, &(node->expr), 0);
	if(!CSemIsLValue(value))
	{
		if(!CSemIsError(value))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  _("invalid lvalue in %s"), name);
		}
		return CSemValueError;
	}

	/* Check that the type is incrementable or decrementale */
	type = ILTypeToMachineType(CSemGetType(value));
	switch(type)
	{
		case ILMachineType_Int8:
		case ILMachineType_UInt8:
		case ILMachineType_Int16:
		case ILMachineType_UInt16:
		case ILMachineType_Char:
		case ILMachineType_Int32:
		case ILMachineType_UInt32:
		case ILMachineType_Int64:
		case ILMachineType_UInt64:
		case ILMachineType_NativeInt:
		case ILMachineType_NativeUInt:
		case ILMachineType_Float32:
		case ILMachineType_Float64:
		case ILMachineType_NativeFloat:		break;

		case ILMachineType_UnmanagedPtr:
		{
			elemType = CTypeGetPtrRef(CSemGetType(value));
			elemSize = CTypeSizeAndAlign(elemType, 0);
			if(elemSize != 1)
			{
				elemType = ILTypeStripPrefixes(elemType);
				if(elemType == ILType_Float)
				{
					elemType = ILFindNonSystemType
						(info, "NativeFloat", "OpenSystem.C");
				}
				elemClass = ILTypeToClass(info, elemType);
				if(yyisa(node, ILNode_PreInc))
				{
					newNode = ILNode_PreIncPtr_create
						(node->expr, elemSize, elemClass);
				}
				else if(yyisa(node, ILNode_PreDec))
				{
					newNode = ILNode_PreDecPtr_create
						(node->expr, elemSize, elemClass);
				}
				else if(yyisa(node, ILNode_PostInc))
				{
					newNode = ILNode_PostIncPtr_create
						(node->expr, elemSize, elemClass);
				}
				else
				{
					newNode = ILNode_PostDecPtr_create
						(node->expr, elemSize, elemClass);
				}
				CGenCloneLine(newNode, (ILNode *)node);
				*parent = newNode;
			}
		}
		break;

		default:
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  _("wrong type argument to %s"), name);
			return CSemValueError;
		}
		/* Not reached */
	}

	/* Convert the l-value into and r-value and return */
	CSemSetRValue(value, CSemGetType(value));
	return value;
}

/*
 * Perform semantic analysis for a relational operator.
 */
static CSemValue RelationalSem(ILGenInfo *info, ILNode_BinaryExpression *node,
						       ILNode **parent, int stmtLevel,
						       const char *name)
{
	CSemValue value1;
	CSemValue value2;
	ILMachineType type1;
	ILMachineType type2;
	ILMachineType common;
	ILType *elemType;
	ILType *elemType2;
	ILNode *temp;

	/* Perform semantic analysis on the two arguments, and
	   check that they are both r-values */
	value1 = ILNode_CSemAnalysis(node->expr1, info, &(node->expr1), stmtLevel);
	value2 = ILNode_CSemAnalysis(node->expr2, info, &(node->expr2), 0);
	if(!CSemIsRValue(value1) || !CSemIsRValue(value2))
	{
		/* Pass error conditions up, but otherwise ignore the problem.
		   We've already reported the error at the lower level */
		if(CSemIsError(value1) || CSemIsError(value2))
		{
			return CSemValueBool;
		}
		goto invalid;
	}

	/* Find a common type to use for the operation */
	type1 = ILTypeToMachineType(CSemGetType(value1));
	type2 = ILTypeToMachineType(CSemGetType(value2));
	if(IsNumericMachineType(type1) && IsNumericMachineType(type2))
	{
		/* Compare numeric values */
		common = CommonBinaryType(info, type1, type2);
	}
	else if(type1 == ILMachineType_UnmanagedPtr &&
			type2 == ILMachineType_UnmanagedPtr)
	{
		/* Compare pointer values */
		elemType = ILTypeStripPrefixes(CSemGetType(value1));
		elemType2 = ILTypeStripPrefixes(CSemGetType(value2));
		if(elemType != ILType_Void && elemType2 != ILType_Void &&
		   !ILTypeIdentical(elemType, elemType2))
		{
			CCWarningOnLine(yygetfilename(node), yygetlinenum(node),
				_("comparison of distinct pointer types lacks a cast"));
		}
		common = ILMachineType_UnmanagedPtr;
	}
	else if(type1 == ILMachineType_UnmanagedPtr && IsIntegerMachineType(type2))
	{
		/* Compare pointer and integer */
		if(CSemIsZero(value2))
		{
			if(yyisa(node, ILNode_Eq))
			{
				temp = ILNode_IsNull_create(node->expr1);
				CGenCloneLine(temp, node->expr1);
				*parent = temp;
				return CSemValueBool;
			}
			else if(yyisa(node, ILNode_Ne))
			{
				temp = ILNode_IsNonNull_create(node->expr1);
				CGenCloneLine(temp, node->expr1);
				*parent = temp;
				return CSemValueBool;
			}
		}
		else
		{
			CCWarningOnLine(yygetfilename(node), yygetlinenum(node),
				_("comparison between pointer and integer"));
		}
		if(IsSignedMachineType(type2))
		{
			common = ILMachineType_NativeInt;
		}
		else
		{
			common = ILMachineType_NativeUInt;
		}
	}
	else if(IsIntegerMachineType(type1) && type2 == ILMachineType_UnmanagedPtr)
	{
		/* Compare integer and pointer */
		if(CSemIsZero(value1))
		{
			if(yyisa(node, ILNode_Eq))
			{
				temp = ILNode_IsNull_create(node->expr2);
				CGenCloneLine(temp, node->expr2);
				*parent = temp;
				return CSemValueBool;
			}
			else if(yyisa(node, ILNode_Ne))
			{
				temp = ILNode_IsNonNull_create(node->expr2);
				CGenCloneLine(temp, node->expr2);
				*parent = temp;
				return CSemValueBool;
			}
		}
		else
		{
			CCWarningOnLine(yygetfilename(node), yygetlinenum(node),
				_("comparison between pointer and integer"));
		}
		if(IsSignedMachineType(type1))
		{
			common = ILMachineType_NativeInt;
		}
		else
		{
			common = ILMachineType_NativeUInt;
		}
	}
	else
	{
		goto invalid;
	}

	/* Cast the arguments to their final types and return */
	if(common != type1)
	{
		temp = ILNode_CastSimple_create(node->expr1, common);
		CGenCloneLine(temp, node->expr1);
		node->expr1 = temp;
	}
	if(common != type2)
	{
		temp = ILNode_CastSimple_create(node->expr2, common);
		CGenCloneLine(temp, node->expr2);
		node->expr2 = temp;
	}
	return CSemValueBool;

	/* Report an invalid operands error and bail out */
invalid:
	CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
				  _("invalid operands to binary `%s'"), name);
	return CSemValueBool;
}

%}

/*
 * Perform semantic analysis for the addition operator.
 */
ILNode_CSemAnalysis(ILNode_Add)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, "+", C_BINARY_ADD);
}

/*
 * Perform semantic analysis for the subtraction operator.
 */
ILNode_CSemAnalysis(ILNode_Sub)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, "-", C_BINARY_SUB);
}

/*
 * Perform semantic analysis for the multiplication operator.
 */
ILNode_CSemAnalysis(ILNode_Mul)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, "*", C_BINARY_NUMERIC);
}

/*
 * Perform semantic analysis for the division operator.
 */
ILNode_CSemAnalysis(ILNode_Div)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, "/", C_BINARY_NUMERIC);
}

/*
 * Perform semantic analysis for the remainder operator.
 */
ILNode_CSemAnalysis(ILNode_Rem)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, "%", C_BINARY_REM);
}

/*
 * Perform semantic analysis for the negation operator.
 */
ILNode_CSemAnalysis(ILNode_Neg)
{
	CSemValue value;
	ILMachineType type;
	ILMachineType common;
	ILNode *temp;

	/* Perform semantic analysis on the argument */
	value = ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);
	if(!CSemIsRValue(value))
	{
		/* Pass error conditions up, but otherwise ignore the problem.
		   We've already reported the error at the lower level */
		if(CSemIsError(value))
		{
			return CSemValueError;
		}
		goto invalid;
	}

	/* Find an appropriate numeric type to negate within */
	type = ILTypeToMachineType(CSemGetType(value));
	switch(type)
	{
		case ILMachineType_Int8:
		case ILMachineType_UInt8:
		case ILMachineType_Int16:
		case ILMachineType_UInt16:
		case ILMachineType_Char:
		case ILMachineType_Int32:
		case ILMachineType_UInt32:
		{
			common = ILMachineType_Int32;
		}
		break;

		case ILMachineType_Int64:
		case ILMachineType_UInt64:
		{
			common = ILMachineType_Int64;
		}
		break;

		case ILMachineType_NativeInt:
		case ILMachineType_NativeUInt:
		{
			common = ILMachineType_NativeInt;
		}
		break;

		case ILMachineType_Float32:
		case ILMachineType_Float64:
		{
			common = ILMachineType_Float64;
		}
		break;

		case ILMachineType_NativeFloat:
		{
			common = ILMachineType_NativeFloat;
		}
		break;

		default: goto invalid;
	}

	/* Cast the argument to its final type and return */
	if(common != type)
	{
		temp = ILNode_CastSimple_create(node->expr, common);
		CGenCloneLine(temp, node->expr);
		node->expr = temp;
	}
	CSemSetRValue(value, ILValueTypeToType(info, common));
	return value;

	/* Report an invalid operands error and bail out */
invalid:
	CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
				  _("invalid operand to unary `-'"));
	return CSemValueError;
}

/*
 * Perform semantic analysis for the unary plus operator.
 */
ILNode_CSemAnalysis(ILNode_UnaryPlus)
{
	CSemValue value;
	ILMachineType type;
	ILMachineType common;
	ILNode *temp;

	/* Perform semantic analysis on the argument */
	value = ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);
	if(!CSemIsRValue(value))
	{
		/* Pass error conditions up, but otherwise ignore the problem.
		   We've already reported the error at the lower level */
		if(CSemIsError(value))
		{
			return CSemValueError;
		}
		goto invalid;
	}

	/* Find an appropriate numeric type to process with */
	type = ILTypeToMachineType(CSemGetType(value));
	switch(type)
	{
		case ILMachineType_Int8:
		case ILMachineType_UInt8:
		case ILMachineType_Int16:
		case ILMachineType_UInt16:
		case ILMachineType_Char:
		case ILMachineType_Int32:
		case ILMachineType_UInt32:
		{
			common = ILMachineType_Int32;
		}
		break;

		case ILMachineType_Int64:
		case ILMachineType_UInt64:
		{
			common = ILMachineType_Int64;
		}
		break;

		case ILMachineType_NativeInt:
		case ILMachineType_NativeUInt:
		{
			common = ILMachineType_NativeInt;
		}
		break;

		case ILMachineType_Float32:
		case ILMachineType_Float64:
		{
			common = ILMachineType_Float64;
		}
		break;

		case ILMachineType_NativeFloat:
		{
			common = ILMachineType_NativeFloat;
		}
		break;

		default: goto invalid;
	}

	/* Cast the argument to its final type and return */
	if(common != type)
	{
		temp = ILNode_CastSimple_create(node->expr, common);
		CGenCloneLine(temp, node->expr);
		node->expr = temp;
	}
	*parent = node->expr;
	CSemSetRValue(value, ILValueTypeToType(info, common));
	return value;

	/* Report an invalid operands error and bail out */
invalid:
	CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
				  _("invalid operand to unary `+'"));
	return CSemValueError;
}

/*
 * Perform semantic analysis for the bitwise AND operator.
 */
ILNode_CSemAnalysis(ILNode_And)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, "&", C_BINARY_BITWISE);
}

/*
 * Perform semantic analysis for the bitwise OR operator.
 */
ILNode_CSemAnalysis(ILNode_Or)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, "|", C_BINARY_BITWISE);
}

/*
 * Perform semantic analysis for the bitwise XOR operator.
 */
ILNode_CSemAnalysis(ILNode_Xor)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, "^", C_BINARY_BITWISE);
}

/*
 * Perform semantic analysis for the bitwise NOT operator.
 */
ILNode_CSemAnalysis(ILNode_Not)
{
	CSemValue value;
	ILMachineType type;
	ILMachineType common;
	ILNode *temp;

	/* Perform semantic analysis on the argument */
	value = ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);
	if(!CSemIsRValue(value))
	{
		/* Pass error conditions up, but otherwise ignore the problem.
		   We've already reported the error at the lower level */
		if(CSemIsError(value))
		{
			return CSemValueError;
		}
		goto invalid;
	}

	/* Find an appropriate numeric type to NOT within */
	type = ILTypeToMachineType(CSemGetType(value));
	switch(type)
	{
		case ILMachineType_Int8:
		case ILMachineType_UInt8:
		case ILMachineType_Int16:
		case ILMachineType_UInt16:
		case ILMachineType_Char:
		case ILMachineType_Int32:
		{
			common = ILMachineType_Int32;
		}
		break;

		case ILMachineType_UInt32:
		{
			common = ILMachineType_UInt32;
		}
		break;

		case ILMachineType_Int64:
		{
			common = ILMachineType_Int64;
		}
		break;

		case ILMachineType_UInt64:
		{
			common = ILMachineType_UInt64;
		}
		break;

		case ILMachineType_NativeInt:
		{
			common = ILMachineType_NativeInt;
		}
		break;

		case ILMachineType_NativeUInt:
		{
			common = ILMachineType_NativeUInt;
		}
		break;

		default: goto invalid;
	}

	/* Cast the argument to its final type and return */
	if(common != type)
	{
		temp = ILNode_CastSimple_create(node->expr, common);
		CGenCloneLine(temp, node->expr);
		node->expr = temp;
	}
	CSemSetRValue(value, ILValueTypeToType(info, common));
	return value;

	/* Report an invalid operands error and bail out */
invalid:
	CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
				  _("invalid operand to unary `~'"));
	return CSemValueError;
}

/*
 * Perform semantic analysis for the left shift operator.
 */
ILNode_CSemAnalysis(ILNode_Shl)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, "<<", C_BINARY_SHIFT);
}

/*
 * Perform semantic analysis for the right shift operator.
 */
ILNode_CSemAnalysis(ILNode_Shr),
ILNode_CSemAnalysis(ILNode_UShr)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, ">>", C_BINARY_SHIFT);
}

/*
 * Perform semantic analysis for the assignment expression.
 */
ILNode_CSemAnalysis(ILNode_Assign)
{
	CSemValue value1;
	CSemValue value2;

	/* Determine if the l-value will leave the machine state at
	   the statement level of the expression, or if it might leave
	   values on the stack before computing "expr2".  This check
	   is necessary to ensure that we can assign the results of
	   "setjmp" and "alloca" to local/global variables */
	if(stmtLevel)
	{
		if(!yyisa(node->expr1, ILNode_CLocalVar) &&
		   !yyisa(node->expr1, ILNode_CArgumentVar) &&
		   !yyisa(node->expr1, ILNode_CGlobalVar))
		{
			stmtLevel = 0;
		}
	}

	/* Perform semantic analysis on the two values */
	value1 = ILNode_CSemAnalysis(node->expr1, info, &(node->expr1), 0);
	value2 = ILNode_CSemAnalysis(node->expr2, info, &(node->expr2), stmtLevel);

	/* Check that the first is an l-value and the second is an r-value */
	if(!CSemIsLValue(value1))
	{
		if(!CSemIsError(value1))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  "invalid lvalue in assignment");
		}
		return CSemValueError;
	}
	if(!CSemIsRValue(value2))
	{
		if(!CSemIsError(value2))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  "invalid rvalue in assignment");
		}
		return CSemValueError;
	}

	/* Check that we can coerce from "value2" to "value1"'s type */
	if(ILTypeStripPrefixes(CSemGetType(value1)) == ILType_Boolean &&
	   (CSemIsBoolean(value2) ||
	    ILTypeStripPrefixes(CSemGetType(value2)) == ILType_Boolean))
	{
		/* Assigning a value to a "__bool__" variable is handled specially */
		return CSemValueBool;
	}
	else
	{
		if(!CCanCoerceValue(value2, CSemGetType(value1)))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  "incompatible types in assignment");
			CSemSetRValue(value1, CSemGetType(value1));
			return value1;
		}

		/* Insert coercion nodes to convert the rvalue appropriately */
		CCoerceNode(info, node->expr2, &(node->expr2),
					value2, CSemGetType(value1));

		/* Convert value1 into an rvalue and return its type */
		CSemSetRValue(value1, CSemGetType(value1));
		return value1;
	}
}

/*
 * Perform semantic analysis for the addition assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignAdd)
{
	return AssignSem(info, (ILNode_BinaryExpression *)(node->assign),
					 &(node->assign), "+", C_BINARY_ADD);
}

/*
 * Perform semantic analysis for the subtraction assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignSub)
{
	return AssignSem(info, (ILNode_BinaryExpression *)(node->assign),
					 &(node->assign), "-", C_BINARY_SUB);
}

/*
 * Perform semantic analysis for the multiplication assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignMul)
{
	return AssignSem(info, (ILNode_BinaryExpression *)(node->assign),
					 &(node->assign), "*", C_BINARY_NUMERIC);
}

/*
 * Perform semantic analysis for the division assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignDiv)
{
	return AssignSem(info, (ILNode_BinaryExpression *)(node->assign),
					 &(node->assign), "/", C_BINARY_NUMERIC);
}

/*
 * Perform semantic analysis for the remainder assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignRem)
{
	return AssignSem(info, (ILNode_BinaryExpression *)(node->assign),
					 &(node->assign), "%", C_BINARY_REM);
}

/*
 * Perform semantic analysis for the bitwise AND assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignAnd)
{
	return AssignSem(info, (ILNode_BinaryExpression *)(node->assign),
					 &(node->assign), "&", C_BINARY_BITWISE);
}

/*
 * Perform semantic analysis for the bitwise OR assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignOr)
{
	return AssignSem(info, (ILNode_BinaryExpression *)(node->assign),
					 &(node->assign), "|", C_BINARY_BITWISE);
}

/*
 * Perform semantic analysis for the bitwise XOR assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignXor)
{
	return AssignSem(info, (ILNode_BinaryExpression *)(node->assign),
					 &(node->assign), "^", C_BINARY_BITWISE);
}

/*
 * Perform semantic analysis for the left shift assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignShl)
{
	return AssignSem(info, (ILNode_BinaryExpression *)(node->assign),
					 &(node->assign), "<<", C_BINARY_SHIFT);
}

/*
 * Perform semantic analysis for the right shift assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignShr),
ILNode_CSemAnalysis(ILNode_AssignUShr)
{
	return AssignSem(info, (ILNode_BinaryExpression *)(node->assign),
					 &(node->assign), ">>", C_BINARY_SHIFT);
}

/*
 * Perform semantic analysis for the pre-increment expression.
 */
ILNode_CSemAnalysis(ILNode_PreInc)
{
	return IncOrDecSem(info, (ILNode_UnaryExpression *)node,
					   parent, "increment");
}

/*
 * Perform semantic analysis for the pre-decrement expression.
 */
ILNode_CSemAnalysis(ILNode_PreDec)
{
	return IncOrDecSem(info, (ILNode_UnaryExpression *)node,
					   parent, "decrement");
}

/*
 * Perform semantic analysis for the post-increment expression.
 */
ILNode_CSemAnalysis(ILNode_PostInc)
{
	return IncOrDecSem(info, (ILNode_UnaryExpression *)node,
					   parent, "increment");
}

/*
 * Perform semantic analysis for the post-decrement expression.
 */
ILNode_CSemAnalysis(ILNode_PostDec)
{
	return IncOrDecSem(info, (ILNode_UnaryExpression *)node,
					   parent, "decrement");
}

/*
 * Perform semantic analysis for the equality operator.
 */
ILNode_CSemAnalysis(ILNode_Eq)
{
	return RelationalSem(info, (ILNode_BinaryExpression *)node,
				         parent, stmtLevel, "==");
}

/*
 * Perform semantic analysis for the inequality operator.
 */
ILNode_CSemAnalysis(ILNode_Ne)
{
	return RelationalSem(info, (ILNode_BinaryExpression *)node,
				         parent, stmtLevel, "!=");
}

/*
 * Perform semantic analysis for the less than operator.
 */
ILNode_CSemAnalysis(ILNode_Lt)
{
	return RelationalSem(info, (ILNode_BinaryExpression *)node,
				         parent, stmtLevel, "<");
}

/*
 * Perform semantic analysis for the less than or equal operator.
 */
ILNode_CSemAnalysis(ILNode_Le)
{
	return RelationalSem(info, (ILNode_BinaryExpression *)node,
				         parent, stmtLevel, "<=");
}

/*
 * Perform semantic analysis for the greater than operator.
 */
ILNode_CSemAnalysis(ILNode_Gt)
{
	return RelationalSem(info, (ILNode_BinaryExpression *)node,
				         parent, stmtLevel, ">");
}

/*
 * Perform semantic analysis for the greater than or equal operator.
 */
ILNode_CSemAnalysis(ILNode_Ge)
{
	return RelationalSem(info, (ILNode_BinaryExpression *)node,
				         parent, stmtLevel, ">=");
}

/*
 * Perform semantic analysis for the comma operator.
 */
ILNode_CSemAnalysis(ILNode_Comma)
{
	CSemValue value1;
	CSemValue value2;

	/* Perform semantic analysis on the two arguments */
	value1 = ILNode_CSemAnalysis(node->expr1, info, &(node->expr1), stmtLevel);
	value2 = ILNode_CSemAnalysis(node->expr2, info, &(node->expr2), stmtLevel);

	/* Both must be r-value's */
	if(!CSemIsRValue(value1) || !CSemIsRValue(value2))
	{
		if(!CSemIsError(value1) && !CSemIsError(value2))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  _("invalid operands to binary `,'"));
		}
		value2 = CSemValueError;
	}
	else if(CSemIsLValue(value2))
	{
		/* Turn l-values into r-values */
		CSemSetRValue(value2, CSemGetType(value2));
	}

	/* Return "value2" as the final semantic value */
	return value2;
}

/*
 * Perform semantic analysis for "as is" operators.
 */
ILNode_CSemAnalysis(ILNode_AsIs),
ILNode_CSemAnalysis(ILNode_Overflow),
ILNode_CSemAnalysis(ILNode_NoOverflow),
ILNode_CSemAnalysis(ILNode_Pedantic),
ILNode_CSemAnalysis(ILNode_NoPedantic)
{
	return ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);
}

/*
 * Generate l-value addresses for "as is" operators.
 */
ILNode_CGenAddress(ILNode_AsIs),
ILNode_CGenAddress(ILNode_Overflow),
ILNode_CGenAddress(ILNode_NoOverflow),
ILNode_CGenAddress(ILNode_Pedantic),
ILNode_CGenAddress(ILNode_NoPedantic)
{
	if(yyisa(node->expr, ILNode_LValue))
	{
		return ILNode_CGenAddress((ILNode_LValue *)(node->expr), info);
	}
	else
	{
		return CAddressDefault;
	}
}

/*
 * Perform semantic analysis for the simple cast operator.
 */
ILNode_CSemAnalysis(ILNode_CastSimple)
{
	/* This will never be called, as the grammar uses "CastType" instead */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the general-purpose cast operator.
 */
ILNode_CSemAnalysis(ILNode_CastType)
{
	CSemValue value;

	/* Perform semantic analysis on the argument value */
	value = ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);

	/* Bail out if not an r-value */
	if(!CSemIsRValue(value))
	{
		if(!CSemIsError(value))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  _("invalid operand to cast expression"));
		}
		CSemSetRValue(value, node->type);
		return value;
	}

	/* Can we coerce to the destination type? */
	if(!CCanCoerceValue(value, node->type))
	{
		CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
			  		  "no conversion from `%s' to `%s'",
					  CTypeToName(info, CSemGetType(value)),
					  CTypeToName(info, node->type));
		CSemSetRValue(value, node->type);
		return value;
	}

	/* Perform the cast and return the new semantic value.  We also copy the
	   expression node up one level to eliminate the ILNode_CastType node */
	*parent = node->expr;
	return CCastNode(info, node->expr, parent, value, node->type);
}

%{

/*
 * Get the common type for a conditional operator.  Returns "ILType_Invalid"
 * if there is no common type.
 */
static ILType *CommonCondType(ILGenInfo *info, ILType *type1, ILType *type2)
{
	ILMachineType mtype1 = ILTypeToMachineType(type1);
	ILMachineType mtype2 = ILTypeToMachineType(type2);

	/* If one of the types is "void", then the result is also "void" */
	if(mtype1 == ILMachineType_Void ||
	   mtype2 == ILMachineType_Void)
	{
		return ILType_Void;
	}

	/* Check for numeric combinations */
	if(IsNumericMachineType(mtype1) && IsNumericMachineType(mtype2))
	{
		return ILValueTypeToType(info, CommonBinaryType(info, mtype1, mtype2));
	}

	/* Check for pointer combinations */
	if(CTypeIsPointer(type1) && CTypeIsPointer(type2))
	{
		return type1;
	}
	else if(CTypeIsPointer(type1) && IsIntegerMachineType(mtype2))
	{
		return type1;
	}
	else if(CTypeIsPointer(type2) && IsIntegerMachineType(mtype1))
	{
		return type2;
	}

	/* The types must be identical (e.g. for struct and union types) */
	if(CTypeIsIdentical(type1, type2))
	{
		return type1;
	}

	/* Could not determine a common type */
	return ILType_Invalid;
}

%}

/*
 * Perform semantic analysis for the conditional operator.
 */
ILNode_CSemAnalysis(ILNode_Conditional)
{
	CSemValue value1;
	CSemValue value2;
	ILType *commonType;

	/* Perform semantic analysis on the boolean condition */
	ILNode_CSemAnalysis(node->expr1, info, &(node->expr1), stmtLevel);

	/* Perform semantic analysis on the "then" and "else" clauses */
	value1 = ILNode_CSemAnalysis(node->expr2, info, &(node->expr2), stmtLevel);
	value2 = ILNode_CSemAnalysis(node->expr2, info, &(node->expr3), stmtLevel);
	if((!CSemIsRValue(value1) && !CSemIsVoid(value1)) ||
	   (!CSemIsRValue(value2) && !CSemIsVoid(value2)))
	{
		goto error;
	}

	/* Determine the common type and then coerce the arguments */
	commonType = CommonCondType(info, CSemGetType(value1), CSemGetType(value2));
	if(commonType == ILType_Invalid)
	{
		goto error;
	}
	else if(commonType == ILType_Void)
	{
		return CSemValueDefault;
	}
	else
	{
		CCoerceNode(info, node->expr2, &(node->expr2), value1, commonType);
		CCoerceNode(info, node->expr3, &(node->expr3), value2, commonType);
		CSemSetRValue(value1, commonType);
		return value1;
	}

	/* Report an error with the arguments to "?:" */
error:
	CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
				  _("invalid operands to ternary `?:'"));
	return CSemValueError;
}

/*
 * Perform semantic analysis for the "address of" operator.
 */
ILNode_CSemAnalysis(ILNode_AddressOf)
{
	CSemValue value;

	/* Perform semantic analysis on the argument */
	value = ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);
	if(!CSemIsLValue(value))
	{
		if(!CSemIsError(value))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  _("invalid lvalue in unary `&'"));
		}
		return CSemValueError;
	}

	/* Build the final semantic value and return it */
	CSemSetRValue(value, CTypeCreatePointer(info, CSemGetType(value)));
	return value;
}

/*
 * Perform semantic analysis for the "to boolean" operator.
 */
ILNode_CSemAnalysis(ILNode_ToBool)
{
	CSemValue value;

	/* Perform semantic analysis on the expression */
	value = ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);

	/* Bail out if not an r-value */
	if(CSemIsError(value))
	{
		return CSemValueBool;
	}
	else if(!CSemIsRValue(value))
	{
		CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  _("invalid boolean expression"));
		return CSemValueBool;
	}

	/* Determine how to test the boolean value */
	if(CTypeIsPrimitive(CSemGetType(value)))
	{
		switch(CTypeToElementType(CSemGetType(value)))
		{
			case IL_META_ELEMTYPE_BOOLEAN:
			case IL_META_ELEMTYPE_I1:
			case IL_META_ELEMTYPE_U1:
			case IL_META_ELEMTYPE_I2:
			case IL_META_ELEMTYPE_U2:
			case IL_META_ELEMTYPE_CHAR:
			case IL_META_ELEMTYPE_I4:
			case IL_META_ELEMTYPE_U4:
			case IL_META_ELEMTYPE_I8:
			case IL_META_ELEMTYPE_U8:
			case IL_META_ELEMTYPE_I:
			case IL_META_ELEMTYPE_U:
			case IL_META_ELEMTYPE_R4:
			case IL_META_ELEMTYPE_R8:
			case IL_META_ELEMTYPE_R:
			{
				/* The code generator already knows how to handle
				   boolean conversions for these kinds of types */
			}
			break;

			default:
			{
				CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
							  _("invalid boolean expression"));
			}
			break;
		}
	}
	else if(CTypeIsPointer(CSemGetType(value)) ||
	        CTypeIsFunctionPtr(CSemGetType(value)))
	{
		*parent = ILNode_IsNonNull_create(node->expr);
		CGenCloneLine(*parent, node->expr);
	}
	else
	{
		CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  _("invalid boolean expression"));
	}

	/* The result will always be boolean */
	return CSemValueBool;
}

/*
 * Perform semantic analysis for the "to constant" operator.
 */
ILNode_CSemAnalysis(ILNode_ToConst)
{
	CSemValue value;
	value = ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);
	if(CSemIsRValue(value) && CSemIsConstant(value))
	{
		return value;
	}
	else if(!CSemIsError(value))
	{
		CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  _("constant value required"));
	}
	return CSemValueError;
}

/*
 * Perform semantic analysis for the "sizeof expression" operator.
 */
ILNode_CSemAnalysis(ILNode_SizeOfExpr)
{
	ILUInt32 size;
	CSemValue value;
	ILEvalValue evalValue;

	/* Perform semantic analysis on the expression */
	value = ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);
	if(!CSemIsRValue(value))
	{
		if(!CSemIsError(value))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  _("invalid operand to `sizeof'"));
		}
		CSemSetDynConstant(value, ILType_UInt32);
		return value;
	}
	node->type = CSemGetType(value);

	/* Determine the size based on the type */
	size = CTypeSizeAndAlign(node->type, (ILUInt32 *)0);
	if(size != CTYPE_DYNAMIC)
	{
		/* We can replace this node with a compile-time constant */
		evalValue.valueType = ILMachineType_UInt32;
		evalValue.un.i4Value = (ILInt32)size;
		CSemSetConstant(value, ILType_UInt32, evalValue);
	}
	else
	{
		/* We must compute this constant value dynamically at runtime */
		CSemSetDynConstant(value, ILType_UInt32);
	}
	return value;
}

/*
 * Perform semantic analysis for the "sizeof type" operator.
 */
ILNode_CSemAnalysis(ILNode_SizeOfType)
{
	ILUInt32 size;
	CSemValue value;
	ILEvalValue evalValue;

	size = CTypeSizeAndAlign(node->type, (ILUInt32 *)0);
	if(size != CTYPE_DYNAMIC)
	{
		/* We can replace this node with a compile-time constant */
		evalValue.valueType = ILMachineType_UInt32;
		evalValue.un.i4Value = (ILInt32)size;
		CSemSetConstant(value, ILType_UInt32, evalValue);
	}
	else
	{
		/* We must compute this constant value dynamically at runtime */
		CSemSetDynConstant(value, ILType_UInt32);
	}
	return value;
}

/*
 * Perform code generation operations for the "sizeof" operator.
 */
ILNode_GetType(ILNode_SizeOfType),
ILNode_GetType(ILNode_SizeOfExpr)
{
	return ILMachineType_UInt32;
}
ILNode_GenValue(ILNode_SizeOfType),
ILNode_GenValue(ILNode_SizeOfExpr)
{
	CGenSizeOf(info, node->type);
	return ILMachineType_UInt32;
}
JavaGenValue(ILNode_SizeOfType),
JavaGenValue(ILNode_SizeOfExpr)
{
	/* Will never be called: nothing to do here */
	return ILMachineType_UInt32;
}

/*
 * Perform semantic analysis for error nodes.
 */
ILNode_CSemAnalysis(ILNode_Error)
{
	return CSemValueError;
}
