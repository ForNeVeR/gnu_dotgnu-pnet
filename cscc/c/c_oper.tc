/*
 * c_oper.tc - Operator handling for C.
 *
 * Copyright (C) 2002  Southern Storm Software, Pty Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/*
 * Perform semantic analysis for the logical NOT operator.
 */
ILNode_CSemAnalysis(ILNode_LogicalNot)
{
	ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);
	return CSemValueBool;
}

/*
 * Perform semantic analysis for the logical AND operator.
 */
ILNode_CSemAnalysis(ILNode_LogicalAnd)
{
	ILNode_CSemAnalysis(node->expr1, info, &(node->expr1), stmtLevel);
	ILNode_CSemAnalysis(node->expr2, info, &(node->expr2), stmtLevel);
	return CSemValueBool;
}

/*
 * Perform semantic analysis for the logical OR operator.
 */
ILNode_CSemAnalysis(ILNode_LogicalOr)
{
	ILNode_CSemAnalysis(node->expr1, info, &(node->expr1), stmtLevel);
	ILNode_CSemAnalysis(node->expr2, info, &(node->expr2), stmtLevel);
	return CSemValueBool;
}

%{

/*
 * Determine if a machine type is numeric or integer.
 */
#define	IsNumericMachineType(type)	\
			((type) >= ILMachineType_Int8 && \
			 (type) <= ILMachineType_NativeFloat)
#define	IsIntegerMachineType(type)	\
			((type) >= ILMachineType_Int8 && \
			 (type) <= ILMachineType_NativeUInt)

/*
 * Determine a common type for binary operators.
 */
static ILMachineType CommonBinaryType(ILGenInfo *info,
									  ILMachineType type1,
									  ILMachineType type2)
{
	ILMachineType common;

	/* Determine a common type using the codegen inference algorithm */
	common = ILCommonType(info, type1, type2, 0);

	/* Widen the common type to the natural type for the operation */
	switch(common)
	{
		case ILMachineType_Int8:
		case ILMachineType_UInt8:
		case ILMachineType_Int16:
		case ILMachineType_UInt16:
		case ILMachineType_Char:
		{
			common = ILMachineType_Int32;
		}
		break;

		default: break;
	}

	/* Return the common type to the caller */
	return common;
}

/*
 * Binary operator kinds.
 */
#define	C_BINARY_ADD		0
#define	C_BINARY_SUB		1
#define	C_BINARY_REM		2
#define	C_BINARY_NUMERIC	3
#define	C_BINARY_BITWISE	4
#define	C_BINARY_SHIFT		5

/*
 * Perform semantic analysis for a binary operator.
 */
static CSemValue BinarySem(ILGenInfo *info, ILNode_BinaryExpression *node,
						   ILNode **parent, int stmtLevel,
						   const char *name, int opkind)
{
	CSemValue value1;
	CSemValue value2;
	ILMachineType type1;
	ILMachineType type2;
	ILMachineType common1;
	ILMachineType common2;
	ILNode *temp;

	/* Perform semantic analysis on the two arguments, and
	   check that they are both r-values */
	value1 = ILNode_CSemAnalysis(node->expr1, info, &(node->expr1), stmtLevel);
	value2 = ILNode_CSemAnalysis(node->expr2, info, &(node->expr2), 0);
	if(!CSemIsRValue(value1) || !CSemIsRValue(value2))
	{
		/* Pass error conditions up, but otherwise ignore the problem.
		   We've already reported the error at the lower level */
		if(CSemIsError(value1) || CSemIsError(value2))
		{
			return CSemValueError;
		}
		goto invalid;
	}

	/* Find a common type to use for the operation */
	type1 = ILTypeToMachineType(CSemGetType(value1));
	type2 = ILTypeToMachineType(CSemGetType(value2));
	if(opkind == C_BINARY_SHIFT)
	{
		/* Shift operator that can only support integer operands */
		if(IsIntegerMachineType(type1) && IsIntegerMachineType(type2))
		{
			common1 = CommonBinaryType(info, type1, type1);
			common2 = ILMachineType_Int32;
		}
		else
		{
			goto invalid;
		}
	}
	else if(opkind == C_BINARY_BITWISE || opkind == C_BINARY_REM)
	{
		/* Operator that can only support integer operands */
		if(IsIntegerMachineType(type1) && IsIntegerMachineType(type2))
		{
			common1 = common2 = CommonBinaryType(info, type1, type2);
		}
		else
		{
			goto invalid;
		}
	}
	else
	{
		/* The operator can support all numeric operands */
		if(IsNumericMachineType(type1) && IsNumericMachineType(type2))
		{
			common1 = common2 = CommonBinaryType(info, type1, type2);
		}
		else if(opkind == C_BINARY_ADD)
		{
			if(type1 == ILMachineType_UnmanagedPtr &&
			   IsIntegerMachineType(type2))
			{
				/* Add pointer and integer */
				/* TODO */
				goto invalid;
			}
			else if(type2 == ILMachineType_UnmanagedPtr &&
			        IsIntegerMachineType(type1))
			{
				/* Add integer and pointer */
				/* TODO */
				goto invalid;
			}
			else
			{
				goto invalid;
			}
		}
		else if(opkind == C_BINARY_SUB)
		{
			if(type1 == ILMachineType_UnmanagedPtr &&
			   IsIntegerMachineType(type2))
			{
				/* Subtract pointer and integer */
				/* TODO */
				goto invalid;
			}
			else
			{
				goto invalid;
			}
		}
		else
		{
			goto invalid;
		}
	}

	/* Cast the arguments to their final types and return */
	if(common1 != type1)
	{
		temp = ILNode_CastSimple_create(node->expr1, common1);
		CGenCloneLine(temp, node->expr1);
		node->expr1 = temp;
	}
	if(common2 != type2)
	{
		temp = ILNode_CastSimple_create(node->expr2, common2);
		CGenCloneLine(temp, node->expr2);
		node->expr2 = temp;
	}
	CSemSetRValue(value1, ILValueTypeToType(info, common1));
	return value1;

	/* Report an invalid operands error and bail out */
invalid:
	CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
				  _("invalid operands to binary `%s'"), name);
	return CSemValueError;
}

%}

/*
 * Perform semantic analysis for the addition operator.
 */
ILNode_CSemAnalysis(ILNode_Add)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, "+", C_BINARY_ADD);
}

/*
 * Perform semantic analysis for the subtraction operator.
 */
ILNode_CSemAnalysis(ILNode_Sub)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, "-", C_BINARY_SUB);
}

/*
 * Perform semantic analysis for the multiplication operator.
 */
ILNode_CSemAnalysis(ILNode_Mul)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, "*", C_BINARY_NUMERIC);
}

/*
 * Perform semantic analysis for the division operator.
 */
ILNode_CSemAnalysis(ILNode_Div)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, "/", C_BINARY_NUMERIC);
}

/*
 * Perform semantic analysis for the remainder operator.
 */
ILNode_CSemAnalysis(ILNode_Rem)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, "%", C_BINARY_REM);
}

/*
 * Perform semantic analysis for the negation operator.
 */
ILNode_CSemAnalysis(ILNode_Neg)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the unary plus operator.
 */
ILNode_CSemAnalysis(ILNode_UnaryPlus)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the bitwise AND operator.
 */
ILNode_CSemAnalysis(ILNode_And)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, "&", C_BINARY_BITWISE);
}

/*
 * Perform semantic analysis for the bitwise OR operator.
 */
ILNode_CSemAnalysis(ILNode_Or)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, "|", C_BINARY_BITWISE);
}

/*
 * Perform semantic analysis for the bitwise XOR operator.
 */
ILNode_CSemAnalysis(ILNode_Xor)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, "^", C_BINARY_BITWISE);
}

/*
 * Perform semantic analysis for the bitwise NOT operator.
 */
ILNode_CSemAnalysis(ILNode_Not)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the left shift operator.
 */
ILNode_CSemAnalysis(ILNode_Shl)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, "<<", C_BINARY_SHIFT);
}

/*
 * Perform semantic analysis for the right shift operator.
 */
ILNode_CSemAnalysis(ILNode_Shr),
ILNode_CSemAnalysis(ILNode_UShr)
{
	return BinarySem(info, (ILNode_BinaryExpression *)node, parent,
					 stmtLevel, ">>", C_BINARY_SHIFT);
}

/*
 * Perform semantic analysis for the assignment expression.
 */
ILNode_CSemAnalysis(ILNode_Assign)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the addition assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignAdd)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the subtraction assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignSub)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the multiplication assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignMul)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the division assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignDiv)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the remainder assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignRem)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the bitwise AND assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignAnd)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the bitwise OR assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignOr)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the bitwise XOR assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignXor)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the left shift assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignShl)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the right shift assignment expression.
 */
ILNode_CSemAnalysis(ILNode_AssignShr),
ILNode_CSemAnalysis(ILNode_AssignUShr)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the pre-increment expression.
 */
ILNode_CSemAnalysis(ILNode_PreInc)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the pre-decrement expression.
 */
ILNode_CSemAnalysis(ILNode_PreDec)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the post-increment expression.
 */
ILNode_CSemAnalysis(ILNode_PostInc)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the post-decrement expression.
 */
ILNode_CSemAnalysis(ILNode_PostDec)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the equality operator.
 */
ILNode_CSemAnalysis(ILNode_Eq)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the inequality operator.
 */
ILNode_CSemAnalysis(ILNode_Ne)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the less than operator.
 */
ILNode_CSemAnalysis(ILNode_Lt)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the less than or equal operator.
 */
ILNode_CSemAnalysis(ILNode_Le)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the greater than operator.
 */
ILNode_CSemAnalysis(ILNode_Gt)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the greater than or equal operator.
 */
ILNode_CSemAnalysis(ILNode_Ge)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the comma operator.
 */
ILNode_CSemAnalysis(ILNode_Comma)
{
	CSemValue value1;
	CSemValue value2;

	/* Perform semantic analysis on the two arguments */
	value1 = ILNode_CSemAnalysis(node->expr1, info, &(node->expr1), stmtLevel);
	value2 = ILNode_CSemAnalysis(node->expr2, info, &(node->expr2), stmtLevel);

	/* Both must be r-value's */
	if(!CSemIsRValue(value1) || !CSemIsRValue(value2))
	{
		if(!CSemIsError(value1) && !CSemIsError(value2))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  _("invalid operands to binary `,'"));
		}
		value2 = CSemValueError;
	}
	else if(CSemIsLValue(value2))
	{
		/* Turn l-values into r-values */
		CSemSetRValue(value2, CSemGetType(value2));
	}

	/* Return "value2" as the final semantic value */
	return value2;
}

/*
 * Perform semantic analysis for "as is" operators.
 */
ILNode_CSemAnalysis(ILNode_AsIs),
ILNode_CSemAnalysis(ILNode_Overflow),
ILNode_CSemAnalysis(ILNode_NoOverflow),
ILNode_CSemAnalysis(ILNode_Pedantic),
ILNode_CSemAnalysis(ILNode_NoPedantic)
{
	return ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);
}

/*
 * Generate l-value addresses for "as is" operators.
 */
ILNode_CGenAddress(ILNode_AsIs),
ILNode_CGenAddress(ILNode_Overflow),
ILNode_CGenAddress(ILNode_NoOverflow),
ILNode_CGenAddress(ILNode_Pedantic),
ILNode_CGenAddress(ILNode_NoPedantic)
{
	if(yyisa(node->expr, ILNode_LValue))
	{
		return ILNode_CGenAddress((ILNode_LValue *)(node->expr), info);
	}
	else
	{
		return CAddressDefault;
	}
}

/*
 * Perform semantic analysis for the simple cast operator.
 */
ILNode_CSemAnalysis(ILNode_CastSimple)
{
	/* This will never be called, as the grammar uses "CastType" instead */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the general-purpose cast operator.
 */
ILNode_CSemAnalysis(ILNode_CastType)
{
	CSemValue value;

	/* Perform semantic analysis on the argument value */
	value = ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);

	/* Bail out if not an r-value */
	if(!CSemIsRValue(value))
	{
		if(!CSemIsError(value))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  _("invalid operand to cast expression"));
		}
		CSemSetRValue(value, node->type);
		return value;
	}

	/* Can we coerce to the destination type? */
	if(!CCanCoerceValue(value, node->type))
	{
		CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
			  		  "no conversion from `%s' to `%s'",
					  CTypeToName(info, CSemGetType(value)),
					  CTypeToName(info, node->type));
		CSemSetRValue(value, node->type);
		return value;
	}

	/* Perform the cast and return the new semantic value.  We also copy the
	   expression node up one level to eliminate the ILNode_CastType node */
	*parent = node->expr;
	return CCastNode(info, node->expr, parent, value, node->type);
}

/*
 * Perform semantic analysis for the conditional operator.
 */
ILNode_CSemAnalysis(ILNode_Conditional)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the two-place conditional operator.
 */
ILNode_CSemAnalysis(ILNode_TwoConditional)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Generate the type of a two-place conditional operator.
 */
ILNode_GetType(ILNode_TwoConditional)
{
	/* TODO */
	return ILMachineType_Void;
}

/*
 * Generate discard code for the two-place conditional operator.
 */
ILNode_GenDiscard(ILNode_TwoConditional)
{
	/* TODO */
}

/*
 * Generate value code for the two-place conditional operator.
 */
ILNode_GenValue(ILNode_TwoConditional)
{
	/* TODO */
	return ILMachineType_Void;
}
JavaGenValue(ILNode_TwoConditional)
{
	/* Never called: nothing to do here */
	return ILMachineType_Void;
}

/*
 * Perform semantic analysis for the pointer dereference operator.
 */
ILNode_CSemAnalysis(ILNode_Deref)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the "address of" operator.
 */
ILNode_CSemAnalysis(ILNode_AddressOf)
{
	/* TODO */
	return CSemValueError;
}

/*
 * Perform semantic analysis for the "to boolean" operator.
 */
ILNode_CSemAnalysis(ILNode_ToBool)
{
	CSemValue value;

	/* Perform semantic analysis on the expression */
	value = ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);

	/* Bail out if not an r-value */
	if(CSemIsError(value))
	{
		return CSemValueBool;
	}
	else if(!CSemIsRValue(value))
	{
		CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  _("invalid boolean expression"));
		return CSemValueBool;
	}

	/* Determine how to test the boolean value */
	if(CTypeIsPrimitive(CSemGetType(value)))
	{
		switch(CTypeToElementType(CSemGetType(value)))
		{
			case IL_META_ELEMTYPE_BOOLEAN:
			case IL_META_ELEMTYPE_I1:
			case IL_META_ELEMTYPE_U1:
			case IL_META_ELEMTYPE_I2:
			case IL_META_ELEMTYPE_U2:
			case IL_META_ELEMTYPE_CHAR:
			case IL_META_ELEMTYPE_I4:
			case IL_META_ELEMTYPE_U4:
			case IL_META_ELEMTYPE_I8:
			case IL_META_ELEMTYPE_U8:
			case IL_META_ELEMTYPE_I:
			case IL_META_ELEMTYPE_U:
			case IL_META_ELEMTYPE_R4:
			case IL_META_ELEMTYPE_R8:
			case IL_META_ELEMTYPE_R:
			{
				/* The code generator already knows how to handle
				   boolean conversions for these kinds of types */
			}
			break;

			default:
			{
				CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
							  _("invalid boolean expression"));
			}
			break;
		}
	}
	else if(CTypeIsPointer(CSemGetType(value)) ||
	        CTypeIsMethod(CSemGetType(value)))
	{
		*parent = ILNode_IsNonNull_create(node->expr);
		CGenCloneLine(*parent, node->expr);
	}
	else
	{
		CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  _("invalid boolean expression"));
	}

	/* The result will always be boolean */
	return CSemValueBool;
}

/*
 * Perform semantic analysis for the "to constant" operator.
 */
ILNode_CSemAnalysis(ILNode_ToConst)
{
	CSemValue value;
	value = ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);
	if(CSemIsRValue(value) && CSemIsConstant(value))
	{
		return value;
	}
	else if(!CSemIsError(value))
	{
		CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  _("constant value required"));
	}
	return CSemValueError;
}

/*
 * Perform semantic analysis for the "sizeof expression" operator.
 */
ILNode_CSemAnalysis(ILNode_SizeOfExpr)
{
	ILUInt32 size;
	CSemValue value;
	ILEvalValue evalValue;

	/* Perform semantic analysis on the expression */
	value = ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);
	if(!CSemIsRValue(value))
	{
		if(!CSemIsError(value))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  _("invalid operand to `sizeof'"));
		}
		CSemSetDynConstant(value, ILType_UInt32);
		return value;
	}
	node->type = CSemGetType(value);

	/* Determine the size based on the type */
	size = CTypeSizeAndAlign(node->type, (ILUInt32 *)0);
	if(size != CTYPE_DYNAMIC)
	{
		/* We can replace this node with a compile-time constant */
		evalValue.valueType = ILMachineType_UInt32;
		evalValue.un.i4Value = (ILInt32)size;
		CSemSetConstant(value, ILType_UInt32, evalValue);
	}
	else
	{
		/* We must compute this constant value dynamically at runtime */
		CSemSetDynConstant(value, ILType_UInt32);
	}
	return value;
}

/*
 * Perform semantic analysis for the "sizeof type" operator.
 */
ILNode_CSemAnalysis(ILNode_SizeOfType)
{
	ILUInt32 size;
	CSemValue value;
	ILEvalValue evalValue;

	size = CTypeSizeAndAlign(node->type, (ILUInt32 *)0);
	if(size != CTYPE_DYNAMIC)
	{
		/* We can replace this node with a compile-time constant */
		evalValue.valueType = ILMachineType_UInt32;
		evalValue.un.i4Value = (ILInt32)size;
		CSemSetConstant(value, ILType_UInt32, evalValue);
	}
	else
	{
		/* We must compute this constant value dynamically at runtime */
		CSemSetDynConstant(value, ILType_UInt32);
	}
	return value;
}

/*
 * Perform code generation operations for the "sizeof" operator.
 */
ILNode_GetType(ILNode_SizeOfType),
ILNode_GetType(ILNode_SizeOfExpr)
{
	return ILMachineType_UInt32;
}
ILNode_GenValue(ILNode_SizeOfType),
ILNode_GenValue(ILNode_SizeOfExpr)
{
	CGenSizeOf(info, node->type);
	return ILMachineType_UInt32;
}
JavaGenValue(ILNode_SizeOfType),
JavaGenValue(ILNode_SizeOfExpr)
{
	/* Will never be called: nothing to do here */
	return ILMachineType_UInt32;
}

/*
 * Perform semantic analysis for error nodes.
 */
ILNode_CSemAnalysis(ILNode_Error)
{
	return CSemValueError;
}
