/*
 * c_stmt.tc - Statement handling for C.
 *
 * Copyright (C) 2002  Southern Storm Software, Pty Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

%{

/*
 * Determine if a tree node corresponds to the empty statement.
 */
#define	IsEmpty(node) ((node) == 0 || yykind((node)) == yykindof(ILNode_Empty))

/*
 * Perform semantic analysis on a sub-statement.
 */
static CSemValue StmtSem(ILNode *node, ILGenInfo *info,
					     ILNode **parent, int stmtLevel)
{
	CSemValue value = CSemValueDefault;
	if(node)
	{
		value = ILNode_CSemAnalysis(node, info, parent, stmtLevel);
		if(!CSemIsVoid(value) && !CSemIsRValue(value))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  _("invalid statement"));
		}
	}
	return value;
}

/*
 * Statement context flags.
 */
#define	C_STMT_LOOP			1
#define	C_STMT_SWITCH		2
#define	C_STMT_TRY			4
#define	C_STMT_CATCH		8
#define	C_STMT_FINALLY		16

/*
 * Push a statement context.
 */
static void PushStmtContext(ILGenInfo *info, int context)
{
	if(info->contextStackSize >= info->contextStackMax)
	{
		/* Increase the size of the context stack */
		int *newstack;
		newstack = (int *)ILRealloc(info->contextStack,
									sizeof(int) * (info->contextStackMax + 4));
		if(!newstack)
		{
			ILGenOutOfMemory(info);
		}
		info->contextStack = newstack;
		info->contextStackMax += 4;
	}
	info->contextStack[info->contextStackSize] = context;
	++(info->contextStackSize);
}

/*
 * Pop the top-most statement context.
 */
static void PopStmtContext(ILGenInfo *info)
{
	--(info->contextStackSize);
}

/*
 * Determine if we are within a specific context, but not
 * within a "stop" context.  e.g. "break" can be used
 * within a loop, but not in the body of a "finally"
 * within the loop.  "finally" is the "stop" context.
 */
static int StmtContextOK(ILGenInfo *info, int context, int stopContext)
{
	long posn = info->contextStackSize;
	while(posn > 0)
	{
		--posn;
		if((info->contextStack[posn] & stopContext) != 0)
		{
			return 0;
		}
		if((info->contextStack[posn] & context) != 0)
		{
			return 1;
		}
	}
	if(!context)
	{
		/* We are checking a "return" statement */
		return 1;
	}
	else
	{
		/* We are checking some other kind of statement */
		return 0;
	}
}

%}

/*
 * Perform semantic analysis for the empty statement.
 */
ILNode_CSemAnalysis(ILNode_Empty)
{
	/* Nothing to do here, because there is nothing in the statement */
	return CSemValueDefault;
}

/*
 * Perform semantic analysis for compound statements.  We return the
 * semantic value of the last statement in case it is an expression
 * and the compound statement was used in the context of an expression
 * statement: "({ ... })".
 */
ILNode_CSemAnalysis(ILNode_Compound),
ILNode_CSemAnalysis(ILNode_List)
{
	CSemValue value = CSemValueDefault;
	ILNode_ListIter iter;
	ILNode *stmt, *replace;
	ILNode_ListIter_Init(&iter, node);
	while((stmt = ILNode_ListIter_Next(&iter)) != 0)
	{
		replace = stmt;
		value = ILNode_CSemAnalysis(stmt, info, &replace, stmtLevel);
		if(replace != stmt)
		{
			*(iter.last) = replace;
		}
		if(!CSemIsVoid(value) && !CSemIsRValue(value))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  _("invalid statement"));
		}
	}
	return value;
}

/*
 * Perform semantic analysis for "if" statements.
 */
ILNode_CSemAnalysis(ILNode_If)
{
	ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);
	StmtSem(node->thenClause, info, &(node->thenClause), stmtLevel);
	StmtSem(node->elseClause, info, &(node->elseClause), stmtLevel);
	return CSemValueDefault;
}

/*
 * Perform semantic analysis for "while" statements.
 */
ILNode_CSemAnalysis(ILNode_While)
{
	ILNode_CSemAnalysis(node->cond, info, &(node->cond), stmtLevel);
	PushStmtContext(info, C_STMT_LOOP);
	StmtSem(node->stmt, info, &(node->stmt), stmtLevel);
	PopStmtContext(info);
	return CSemValueDefault;
}

/*
 * Perform semantic analysis for "do" statements.
 */
ILNode_CSemAnalysis(ILNode_Do)
{
	PushStmtContext(info, C_STMT_LOOP);
	StmtSem(node->stmt, info, &(node->stmt), stmtLevel);
	PopStmtContext(info);
	ILNode_CSemAnalysis(node->cond, info, &(node->cond), stmtLevel);
	return CSemValueDefault;
}

/*
 * Perform semantic analysis for "for" statements.
 */
ILNode_CSemAnalysis(ILNode_For)
{
	StmtSem(node->init, info, &(node->init), stmtLevel);
	ILNode_CSemAnalysis(node->cond, info, &(node->cond), stmtLevel);
	StmtSem(node->incr, info, &(node->incr), stmtLevel);
	PushStmtContext(info, C_STMT_LOOP);
	StmtSem(node->stmt, info, &(node->stmt), stmtLevel);
	PopStmtContext(info);
	return CSemValueDefault;
}

/*
 * Perform semantic analysis for "break" statements.
 */
ILNode_CSemAnalysis(ILNode_Break)
{
	if(!StmtContextOK(info, C_STMT_LOOP | C_STMT_SWITCH, 0))
	{
		CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "`break' used outside loop or switch");
	}
	return CSemValueDefault;
}

/*
 * Perform semantic analysis for "continue" statements.
 */
ILNode_CSemAnalysis(ILNode_Continue)
{
	if(!StmtContextOK(info, C_STMT_LOOP, 0))
	{
		CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "`continue' used outside loop");
	}
	return CSemValueDefault;
}

/*
 * Perform semantic analysis for "return" statements.
 */
ILNode_CSemAnalysis(ILNode_Return)
{
	ILMethod *method = CFunctionGetCurrent();
	ILType *returnType = ILTypeGetReturn(ILMethod_Signature(method));
	if(returnType != ILType_Void)
	{
		/* Emit a warning if the return type is not "void".  This really
		   should be an error, but we copy what gcc does for compatibility */
		CCWarningOnLine(yygetfilename(node), yygetlinenum(node),
			  "`return' with no value, in function returning non-void");
	}
	return CSemValueDefault;
}

/*
 * Perform semantic analysis for "return expression" statements.
 */
ILNode_CSemAnalysis(ILNode_ReturnExpr)
{
	CSemValue value;
	ILMethod *method = CFunctionGetCurrent();
	ILType *returnType = ILTypeGetReturnWithPrefixes
			(ILMethod_Signature(method));

	/* Perform semantic analysis on the expression */
	value = ILNode_CSemAnalysis(node->expr, info, &(node->expr), stmtLevel);
	if(CSemIsError(value))
	{
		/* We've already reported an error for a bad expression,
		   so don't bother complaining about the situation again */
		return CSemValueDefault;
	}
	else if(!CSemIsRValue(value))
	{
		CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "invalid return value");
		return CSemValueDefault;
	}

	/* Determine if the value is compatible with the return type */
	if(ILTypeStripPrefixes(returnType) == ILType_Void)
	{
		/* Emit a warning if the return type is "void".  This really should
		   be an error, but we copy what gcc does for compatibility */
		CCWarningOnLine(yygetfilename(node), yygetlinenum(node),
			  "`return' with a value, in function returning void");

		/* Replace the current node with a value-less return so that
		   the code generator outputs the correct return code */
		*parent = ILNode_Return_create();
		CGenCloneLine(*parent, (ILNode *)node);
	}
	else
	{
		/* Coerce the value to the return type */
		if(CCanCoerceValue(value, returnType))
		{
			CCoerceNode(info, node->expr, &(node->expr), value, returnType);
		}
		else
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
				  		  "incompatible types in return: "
						  		"no conversion from `%s' to `%s'",
						  CTypeToName(info, CSemGetType(value)),
						  CTypeToName(info, returnType));
		}
	}

	/* Done */
	return CSemValueDefault;
}

/*
 * Perform semantic analysis for "goto" statements.
 */
ILNode_CSemAnalysis(ILNode_Goto)
{
	/* TODO */
	return CSemValueDefault;
}

/*
 * Perform semantic analysis for "goto label" statements.
 */
ILNode_CSemAnalysis(ILNode_GotoLabel)
{
	/* TODO */
	return CSemValueDefault;
}

/*
 * Perform semantic analysis for "new scope" statements.
 */
ILNode_CSemAnalysis(ILNode_NewScope)
{
	ILScope *savedScope = info->currentScope;
	if(!(node->scope))
	{
		node->scope = ILScopeCreate(info, savedScope);
	}
	info->currentScope = node->scope;
	StmtSem(node->stmt, info, &(node->stmt), stmtLevel);
	info->currentScope = savedScope;
	return CSemValueDefault;
}

/*
 * Perform semantic analysis for "switch" statements.
 */
ILNode_CSemAnalysis(ILNode_Switch)
{
	/* TODO */
	return CSemValueDefault;
}

/*
 * Perform semantic analysis for line number information blocks.
 */
ILNode_CSemAnalysis(ILNode_LineInfo)
{
	StmtSem(node->stmt, info, &(node->stmt), stmtLevel);
	return CSemValueDefault;
}
