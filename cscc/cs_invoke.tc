/*
 * cs_invoke.tc - Semantic analysis for method invocation.
 *
 * Copyright (C) 2001  Southern Storm Software, Pty Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

%decls %{

/*
 * Convert a method into a printable name, suitable for use in error messages.
 */
const char *CSMethodToName(ILMethod *method);

/*
 * Information that is kept about an evaluated argument.
 */
typedef struct
{
	ILType	   *type;
	ILNode     *node;
	ILNode    **parent;
	ILParameterModifier modifier;

} CSEvalArg;

/*
 * Evaluate a list of arguments for a method invocation.
 * Returns the number of arguments, or -1 on error.
 */
int CSEvalArguments(ILGenInfo *info, ILNode *argList,
					ILNode **argListParent, CSEvalArg **args);

/*
 * Free an evaluated argument list.
 */
void CSEvalFreeArguments(CSEvalArg *args);

/*
 * Determine if a method is a candidate for evaluation.
 * Returns 0 if not a candidate, 1 if a candidate in its
 * normal form, and 2 if a candidate in its expanded form.
 */
int CSMethodIsCandidate(ILGenInfo *info, ILMethod *method,
					    CSEvalArg *args, int numArgs);

/*
 * Determine the best method candidate in a group.
 * Returns NULL if none of the methods are "best".
 */
ILMethod *CSBestCandidate(ILGenInfo *info, void *group,
						  CSEvalArg *args, int numArgs);

/*
 * Coerce the arguments and set up the final argument list.
 * Returns the method's return type.
 */
ILType *CSMethodCoerceArgs(ILGenInfo *info, ILMethod *method,
						   CSEvalArg *args, int numArgs,
						   ILNode **argListParent);

%}

/*
 * Perform semantic analysis for the argument list operator.
 */
ILNode_SemAnalysis(ILNode_ArgList)
{
	CSSemValue value1;
	CSSemValue value2;
	value1 = ILNode_SemAnalysis(node->expr1, info, &(node->expr1));
	value2 = ILNode_SemAnalysis(node->expr2, info, &(node->expr2));
	if(!CSIsSemValue(value1.kind) || !CSIsSemValue(value2.kind))
	{
		CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "invalid operands to binary `,'");
	}
	return value2;
}

ILNode_SemAnalysis(ILNode_Argument)
{
	CSSemValue value;
	value = ILNode_SemAnalysis(node->expression, info, &(node->expression));
	if(node->modifier == ILParamMod_out ||
	   node->modifier == ILParamMod_ref)
	{
		if(value.kind != CS_SEMKIND_LVALUE ||
		   yyisa(node->expression, ILNode_LValueNoRef))
		{
			CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  "invalid lvalue in `%s' argument",
						  (node->modifier == ILParamMod_out
						  		? "out" : "ref"));
			if(value.kind == CS_SEMKIND_RVALUE ||
			   value.kind == CS_SEMKIND_SVALUE)
			{
				value.kind = CS_SEMKIND_LVALUE;
			}
			else
			{
				value.kind = CS_SEMKIND_LVALUE;
				value.type = ILType_Int32;
			}
		}
		if(info->outputIsJava)
		{
			CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
			  "`%s' arguments not permitted when compiling to Java bytecode",
			  (node->modifier == ILParamMod_out ? "out" : "ref"));
		}
	}
	return value;
}

%{

/*
 * Report an error message for a failed method signature match,
 * listing the candidates for the call.
 */
static void MethodCandidateError(ILNode *node, char *methodName,
								 void *group, CSEvalArg *args, int numArgs)
{
	unsigned long num;
	ILMethod *method;
	ILIntString str;
	int argNum;

	/* Report the method name and argument types */
	if(methodName)
	{
		/* Construct a list of the argument types for the error */
		str = ILInternString(methodName, -1);
		str = ILInternAppendedString(str, ILInternString("(", 1));
		for(argNum = 0; argNum < numArgs; ++argNum)
		{
			if(argNum != 0)
			{
				str = ILInternAppendedString(str, ILInternString(", ", 2));
			}
			if(args[argNum].modifier == ILParamMod_out)
			{
				str = ILInternAppendedString(str, ILInternString("out ", 4));
			}
			else if(args[argNum].modifier == ILParamMod_ref)
			{
				str = ILInternAppendedString(str, ILInternString("ref ", 4));
			}
			str = ILInternAppendedString
					(str, ILInternString
							((char *)CSTypeToName(args[argNum].type), -1));
		}
		str = ILInternAppendedString(str, ILInternString(")", 1));
		CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "no matching method for call to `%s'",
					  str.string);
	}
	else
	{
		/* Don't know what the method name is, so use a generic message */
		CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "no matching method for call");
	}

	/* Report the candidates */
	num = 0;
	while((method = CSGetGroupMember(group, num)) != 0)
	{
		if(!num)
		{
			CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  "candidates are: %s", CSMethodToName(method));
		}
		else
		{
			CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  "                %s", CSMethodToName(method));
		}
		++num;
	}
}

%}

/*
 * Perform semantic analysis for a method invocation.
 */
ILNode_SemAnalysis(ILNode_InvocationExpression)
{
	CSSemValue value;
	CSSemValue method;
	ILMethod *methodInfo;
	ILType *retType;
	CSEvalArg *args;
	int numArgs;
	unsigned long methodNum;
	char *methodName;
	int candidateForm;

	/* Get the method name for later error reporting */
	if(ILIsQualIdent(node->expr1))
	{
		methodName = ILQualIdentName(node->expr1, 0);
	}
	else if(yyisa(node->expr1, ILNode_MemberAccess))
	{
		methodName = ILQualIdentName
			(((ILNode_MemberAccess *)(node->expr1))->expr2, 0);
	}
	else
	{
		methodName = 0;
	}

	/* TODO: delegate invocation */

	/* Perform semantic analysis on the method expression */
	method = ILNode_SemAnalysis(node->expr1, info, &(node->expr1));
	if(method.kind != CS_SEMKIND_METHOD_GROUP)
	{
		CSErrorOnLine(yygetfilename(node->expr1), yygetlinenum(node->expr1),
					  "called object is not a method");
		return CSSemValueDefault;
	}

	/* Bail out if the method group is NULL.  This is used by "BaseInit"
	   to indicate no parent constructor in "System.Object" */
	if(method.type == 0)
	{
		if(node->expr2)
		{
			/* Cannot use arguments on "System.Object"'s base initializer */
			CSErrorOnLine(yygetfilename(node->expr2),
						  yygetlinenum(node->expr2),
						  "too many arguments to base type constructor");
		}
		value.kind = CS_SEMKIND_VOID;
		value.type = (ILType *)0;
		return value;
	}

	/* Evaluate the arguments */
	numArgs = CSEvalArguments(info, node->expr2, &(node->expr2), &args);
	if(numArgs < 0)
	{
		return CSSemValueDefault;
	}

	/* Find the set of candidate methods */
	methodNum = 0;
	while((methodInfo = CSGetGroupMember
							((void *)(method.type), methodNum)) != 0)
	{
		candidateForm = CSMethodIsCandidate(info, methodInfo, args, numArgs);
		if(candidateForm)
		{
			CSSetGroupMemberForm((void *)(method.type), methodNum,
								 candidateForm);
			++methodNum;
		}
		else
		{
			method.type = (ILType *)CSRemoveGroupMember
								((void *)(method.type), methodNum);
		}
	}

	/* If there are no candidates left, then bail out */
	methodNum = 0;
	methodInfo = CSGetGroupMember((void *)(method.type), methodNum);
	if(!methodInfo)
	{
		MethodCandidateError((ILNode *)node, methodName,
							 (void *)(method.type), args, numArgs);
		CSEvalFreeArguments(args);
		return CSSemValueDefault;
	}

	/* There are two or more candidates, then try to find the best one */
	if(CSGetGroupMember((void *)(method.type), 1) != 0)
	{
		methodInfo = CSBestCandidate(info, (void *)(method.type),
									 args, numArgs);
		if(!methodInfo)
		{
			MethodCandidateError((ILNode *)node, methodName,
								 (void *)(method.type), args, numArgs);
			CSEvalFreeArguments(args);
			return CSSemValueDefault;
		}
	}

	/* Import the method into this image, and set it within the node */
	methodInfo = (ILMethod *)ILMemberImport
						(info->image, (ILMember *)methodInfo);
	node->methodInfo = methodInfo;

	/* Handle the "this" parameter if necessary */
	if(!ILMethod_IsStatic(methodInfo))
	{
		node->thisExpr = node->expr1;
	}

	/* Coerce the arguments and build the final argument list */
	retType = CSMethodCoerceArgs(info, methodInfo, args, numArgs,
								 &(node->expr2));
	CSEvalFreeArguments(args);

	/* The semantic value is the method's return type as an r-value */
	if(retType == ILType_Void)
	{
		value.kind = CS_SEMKIND_VOID;
		value.type = 0;
	}
	else
	{
		value.kind = CS_SEMKIND_RVALUE;
		value.type = retType;
	}
	return value;
}

/*
 * Perform semantic analysis for a reference to a base constructor.
 */
ILNode_SemAnalysis(ILNode_BaseInit)
{
	CSSemValue value;
	ILClass *classInfo;
	ILClass *parentInfo;

	/* If we are compiling "System.Object", then we need to
	   bail out with an empty method group.  This tells
	   "InvocationExpression" to ignore the call */
	classInfo = ((ILNode_ClassDefn *)(info->currentClass))->classInfo;
	parentInfo = (classInfo ? ILClass_Parent(classInfo) : 0);
	if(!parentInfo)
	{
		value.kind = CS_SEMKIND_METHOD_GROUP;
		value.type = (ILType *)0;
		return value;
	}

	/* Resolve ".ctor" within the base class */
	value.kind = CS_SEMKIND_RVALUE;
	value.type = ILType_FromClass(parentInfo);
	value = CSResolveMemberName(info, (ILNode *)node, value, ".ctor");

	/* Replace the current expression with "this" */
	*parent = ILNode_This_create();
	return value;
}

/*
 * Perform semantic analysis for a reference to a "this" constructor.
 */
ILNode_SemAnalysis(ILNode_ThisInit)
{
	CSSemValue value;
	ILClass *classInfo;

	/* Resolve ".ctor" within the current class */
	classInfo = ((ILNode_ClassDefn *)(info->currentClass))->classInfo;
	value.kind = CS_SEMKIND_RVALUE;
	value.type = ILType_FromClass(classInfo);
	value = CSResolveMemberName(info, (ILNode *)node, value, ".ctor");

	/* Replace the current expression with "this" */
	*parent = ILNode_This_create();
	return value;
}

/*
 * Perform semantic analysis for argument array nodes.
 */
ILNode_SemAnalysis(ILNode_ArgArray)
{
	/* This will never be called */
	return CSSemValueDefault;
}

%{

const char *CSMethodToName(ILMethod *method)
{
	ILType *signature = ILMethod_Signature(method);
	const char *name = ILMethod_Name(method);
	ILIntString str;
	ILType *type;
	ILParameterModifier paramMod;
	unsigned numParams;
	unsigned param;

	/* Put "static" or "virtual" on the front if necessary */
	if(ILMethod_IsStatic(method))
	{
		str = ILInternString("static ", 7);
	}
	else if(ILMethod_IsVirtual(method))
	{
		str = ILInternString("virtual ", 8);
	}
	else
	{
		str = ILInternString("", 0);
	}

	/* Get the type of the class that contains the method */
	type = ILType_FromClass(ILMethod_Owner(method));

	/* The formatting is slightly different for constructors */
	if(!strcmp(name, ".ctor") || !strcmp(name, ".cctor"))
	{
		/* Append the class name to the string */
		str = ILInternAppendedString
				(str, ILInternString((char *)CSTypeToName(type), -1));
	}
	else
	{
		/* Convert the return type into a string */
		str = ILInternAppendedString
				(str, ILInternString((char *)CSTypeToName
										(ILTypeGetReturn(signature)), -1));
		str = ILInternAppendedString(str, ILInternString(" ", 1));

		/* Append the class name to the string */
		str = ILInternAppendedString
				(str, ILInternString((char *)CSTypeToName(type), -1));

		/* Append a dot to the string */
		str = ILInternAppendedString(str, ILInternString(".", 1));

		/* Append the method name to the string */
		str = ILInternAppendedString(str, ILInternString((char *)name, -1));
	}

	/* Add the parameter types to the string */
	str = ILInternAppendedString(str, ILInternString("(", 1));
	numParams = ILTypeNumParams(signature);
	for(param = 1; param <= numParams; ++param)
	{
		paramMod = ILGenGetParamInfo(method, signature, param, &type);
		if(param != 1)
		{
			str = ILInternAppendedString(str, ILInternString(", ", 2));
		}
		if(paramMod == ILParamMod_out)
		{
			str = ILInternAppendedString(str, ILInternString("out ", 4));
		}
		else if(paramMod == ILParamMod_ref)
		{
			str = ILInternAppendedString(str, ILInternString("ref ", 4));
		}
		else if(paramMod == ILParamMod_params)
		{
			str = ILInternAppendedString(str, ILInternString("params ", 7));
		}
		str = ILInternAppendedString
				(str, ILInternString((char *)CSTypeToName(type), -1));
	}
	str = ILInternAppendedString(str, ILInternString(")", 1));

	/* Return the final string to the caller */
	return str.string;
}

/*
 * Count the number of arguments in an ArgList.
 */
static unsigned CountArgList(ILNode *argList)
{
	unsigned count;
	if(!argList)
	{
		return 0;
	}
	count = 1;
	while(yyisa(argList, ILNode_ArgList))
	{
		++count;
		argList = ((ILNode_ArgList *)argList)->expr1;
	}
	return count;
}

/*
 * Get the parameter modifier for an argument.
 */
static ILParameterModifier GetParamModForArg(ILNode *arg)
{
	if(yyisa(arg, ILNode_Argument))
	{
		return ((ILNode_Argument *)arg)->modifier;
	}
	else
	{
		return ILParamMod_empty;
	}
}

int CSEvalArguments(ILGenInfo *info, ILNode *argList,
					ILNode **argListParent, CSEvalArg **args)
{
	int argCount;
	int argNum;
	CSEvalArg *argArray;
	ILNode *tempList;
	ILNode **tempParent;
	int tempNum;
	int haveErrors;
	CSSemValue value;

	/* Get the number of arguments that have been supplied */
	argCount = CountArgList(argList);

	/* Bail out if there are no arguments */
	if(!argCount)
	{
		*args = 0;
		return 0;
	}

	/* Allocate an argument array */
	argArray = (CSEvalArg *)ILMalloc(sizeof(CSEvalArg) * argCount);
	if(!argArray)
	{
		CSOutOfMemory();
	}

	/* Perform semantic analysis on the arguments and fill the array */
	haveErrors = 0;
	for(argNum = 0; argNum < argCount; ++argNum)
	{
		/* Find the argument node and its parent */
		tempList = argList;
		tempParent = argListParent;
		tempNum = argNum + 1;
		while(tempNum < argCount)
		{
			tempParent = &(((ILNode_ArgList *)tempList)->expr1);
			tempList = ((ILNode_ArgList *)tempList)->expr1;
			++tempNum;
		}
		if(yyisa(tempList, ILNode_ArgList))
		{
			tempParent = &(((ILNode_ArgList *)tempList)->expr2);
			tempList = ((ILNode_ArgList *)tempList)->expr2;
		}

		/* Populate the argument array element */
		value = ILNode_SemAnalysis(tempList, info, tempParent);
		argArray[argNum].node = *tempParent;
		argArray[argNum].parent = tempParent;
		argArray[argNum].modifier = GetParamModForArg(tempList);
		if(CSIsSemValue(value.kind))
		{
			argArray[argNum].type = value.type;
		}
		else
		{
			argArray[argNum].type = ILType_Void;
			CSErrorOnLine(yygetfilename(tempList),
						  yygetlinenum(tempList),
						  "invalid value for argument %u", argNum + 1);
			haveErrors = 1;
		}
	}

	/* Report either an error, or the argument count */
	if(haveErrors)
	{
		ILFree(argArray);
		*args = 0;
		return -1;
	}
	else
	{
		*args = argArray;
		return argCount;
	}
}

void CSEvalFreeArguments(CSEvalArg *args)
{
	if(args)
	{
		ILFree(args);
	}
}

/*
 * Get the type and modifier information associated with
 * a method parameter.  The first parameter is 0.  Returns
 * ILType_Invalid if the parameter index is invalid.
 */
static ILType *GetMethodParamType(ILMethod *method, ILType *signature,
								  int paramNum, ILParameterModifier *paramMod)
{
	int numParams = ILTypeNumParams(signature);
	int firstParam;
	ILType *paramType;

	/* If we have an "explicit this" method, then we need to
	   adjust for the first parameter, which is always "this" */
	if((ILType_CallConv(signature) & IL_META_CALLCONV_HASTHIS) != 0 &&
	   (ILType_CallConv(signature) & IL_META_CALLCONV_EXPLICITTHIS) != 0 &&
	   numParams > 0)
	{
		firstParam = 2;
	}
	else
	{
		firstParam = 1;
	}

	/* Bail out if the parameter number is out of range */
	if(paramNum > (numParams - firstParam))
	{
		return ILType_Invalid;
	}

	/* Get the parameter type information and return it */
	*paramMod = ILGenGetParamInfo(method, signature, paramNum + firstParam,
								  &paramType);
	return paramType;
}

/*
 * Get the type information associated with a method parameter,
 * given that its expansion form is known.
 */
static ILType *GetMethodExpandedType(ILMethod *method, ILType *signature,
								     int form, int paramNum,
									 ILParameterModifier *paramMod)
{
	ILType *paramType;
	paramType = GetMethodParamType(method, signature, paramNum, paramMod);
	if(paramType == ILType_Invalid)
	{
		return ILType_Invalid;
	}
	else if(*paramMod == ILParamMod_params)
	{
		if(form == 2)
		{
			/* We are using the "params" array in its expanded form */
			return paramType;
		}
		else
		{
			/* We are using the "params" array in its array form */
			return ILTypeGetParam(signature, ILTypeNumParams(signature));
		}
	}
	return paramType;
}

/*
 * Get the element type of a single-dimensional array,
 * or return ILType_Invalid if not such as array.
 */
static ILType *GetArrayElemType(ILType *type)
{
	if(type != 0 && ILType_IsComplex(type) &&
	   ILType_Kind(type) == IL_TYPE_COMPLEX_ARRAY)
	{
		return ILType_ElemType(type);
	}
	else
	{
		return ILType_Invalid;
	}
}

int CSMethodIsCandidate(ILGenInfo *info, ILMethod *method,
						CSEvalArg *args, int numArgs)
{
	ILType *signature = ILMethod_Signature(method);
	int argNum, paramNum;
	ILParameterModifier paramMod;
	ILType *paramType;
	ILType *elemType;
	int matchParams;

	/* Scan through the parameters looking for a match */
	paramNum = 0;
	matchParams = 0;
	for(argNum = 0; argNum < numArgs; ++argNum)
	{
		paramType = GetMethodParamType(method, signature, paramNum, &paramMod);
		if(paramType == ILType_Invalid)
		{
			/* Too many arguments were supplied */
			return 0;
		}
		else if(paramMod == ILParamMod_params)
		{
			if(args[argNum].modifier != ILParamMod_empty)
			{
				return 0;
			}
			if(matchParams)
			{
				/* We already started matching as an element type,
				   so we must keep matching as an element type */
				if(!ILCanCoerce(info->context, args[argNum].type, paramType))
				{
					return 0;
				}
			}
			else
			{
				/* The match can either be as an array, or as an element type */
				elemType = GetArrayElemType(args[argNum].type);
				if(elemType != ILType_Invalid &&
				   ILCanCoerce(info->context, elemType, paramType))
				{
					/* Matched as an array */
					++paramNum;
				}
				else if(!ILCanCoerce(info->context, args[argNum].type,
									 paramType))
				{
					/* Could not match as an array or as an element */
					return 0;
				}
				else
				{
					/* Match everything else as an element */
					matchParams = 1;
				}
			}
		}
		else if(paramMod != args[argNum].modifier)
		{
			/* Incorrect modifiers */
			return 0;
		}
		else if(paramMod == ILParamMod_empty)
		{
			/* Match anything that can coerce to the parameter type */
			if(!ILCanCoerce(info->context, args[argNum].type, paramType))
			{
				return 0;
			}
			++paramNum;
		}
		else
		{
			/* The type match must be exact for "ref" and "out" parameters */
			if(!ILTypeIdentical(args[argNum].type, paramType))
			{
				return 0;
			}
			++paramNum;
		}
	}

	/* Get the next parameter type, which must either be
	   a "params" array, or the end of the parameter list */
	paramType = GetMethodParamType(method, signature, paramNum, &paramMod);
	if(paramType == ILType_Invalid)
	{
		/* The candidate was matched in its normal form */
		return 1;
	}
	else if(paramMod == ILParamMod_params)
	{
		/* The candidate was matched in its expanded form */
		return 2;
	}
	else
	{
		/* The candidate did not match */
		return 0;
	}
}

/*
 * Determine which of two methods is better than the other one.
 * Returns IL_BETTER_T1 if "method1" is better, or IL_BETTER_T2
 * if "method2" is better, or IL_BETTER_NEITHER if neither is better.
 */
static int BetterMethod(ILGenInfo *info,
						ILMethod *method1, int form1,
						ILMethod *method2, int form2,
						CSEvalArg *args, int numArgs)
{
	ILType *signature1 = ILMethod_Signature(method1);
	ILType *signature2 = ILMethod_Signature(method2);
	int argNum;
	int paramNum1;
	int paramNum2;
	ILParameterModifier paramMod1;
	ILParameterModifier paramMod2;
	ILType *type1;
	ILType *type2;
	ILType *atype;
	int better, betterTest;

	/* Compare the argument types */
	paramNum1 = 0;
	paramNum2 = 0;
	better = IL_BETTER_NEITHER;
	for(argNum = 0; argNum < numArgs; ++argNum)
	{
		/* Get the types of the two parameters and the argument */
		type1 = GetMethodExpandedType(method1, signature1,
									  form1, paramNum1++, &paramMod1);
		type2 = GetMethodExpandedType(method2, signature2,
									  form2, paramNum2++, &paramMod2);
		atype = args[argNum].type;

		/* Skip the argument if "out" or "ref", because such arguments
		   must always be identical, so neither can be better */
		if(paramMod1 == ILParamMod_out || paramMod1 == ILParamMod_ref ||
		   paramMod2 == ILParamMod_out || paramMod2 == ILParamMod_ref)
		{
			continue;
		}

		/* Determine which is the better coercion */
		betterTest = ILBetterConversion(info, args[argNum].type, type1, type2);
		if(betterTest == IL_BETTER_T1)
		{
			if(better == IL_BETTER_T2)
			{
				/* The first method is better in this parameter,
				   but worse in others */
				better = -1;
			}
			else if(better != -1)
			{
				/* The first method is better so far */
				better = IL_BETTER_T1;
			}
		}
		else if(betterTest == IL_BETTER_T2)
		{
			if(better == IL_BETTER_T1)
			{
				/* The second method is better in this parameter,
				   but worse in others */
				better = -1;
			}
			else if(better != -1)
			{
				/* The second method is better so far */
				better = IL_BETTER_T2;
			}
		}

		/* Back up and revisit "params" parameters within expanded forms */
		if(paramMod1 == ILParamMod_params)
		{
			--paramNum1;
		}
		if(paramMod2 == ILParamMod_params)
		{
			--paramNum2;
		}
	}

	/* Return the result to the caller */
	if(better != -1)
	{
		return better;
	}
	else
	{
		return IL_BETTER_NEITHER;
	}
}

ILMethod *CSBestCandidate(ILGenInfo *info, void *group,
						  CSEvalArg *args, int numArgs)
{
	unsigned long methodNum = 1;
	ILMethod *bestMethod = (ILMethod *)CSGetGroupMember(group, 0);
	ILMethod *testMethod;
	int better;
	int form1 = CSGetGroupMemberForm(group, 0);
	int form2;
	int sawBetter = 0;
	while((testMethod = (ILMethod *)CSGetGroupMember(group, methodNum)) != 0)
	{
		form2 = CSGetGroupMemberForm(group, methodNum);
		better = BetterMethod(info, bestMethod, form1, testMethod,
							  form2, args, numArgs);
		if(better == IL_BETTER_T1)
		{
			sawBetter = 1;
		}
		else if(better == IL_BETTER_T2)
		{
			bestMethod = testMethod;
			sawBetter = 1;
		}
		else if(better == IL_BETTER_NEITHER && (form1 == 2 && form2 != 2))
		{
			/* We've found a method that is just as applicable as
			   a previous one.  However, the previous one involved
			   "params" and this one doesn't.  So use this one */
			bestMethod = testMethod;
		}
		++methodNum;
	}
	if(sawBetter)
	{
		return bestMethod;
	}
	else
	{
		return 0;
	}
}

ILType *CSMethodCoerceArgs(ILGenInfo *info, ILMethod *method,
						   CSEvalArg *args, int numArgs,
						   ILNode **argListParent)
{
	ILType *signature = ILMethod_Signature(method);
	int argNum, argNum2, paramNum;
	ILParameterModifier paramMod;
	ILType *paramType;
	ILType *elemType;
	ILNode *argList;
	ILNode *argArray;

	/* Coerce the fixed parameters */
	paramNum = 0;
	for(argNum = 0; argNum < numArgs; ++argNum)
	{
		paramType = GetMethodParamType(method, signature, paramNum, &paramMod);
		if(paramMod == ILParamMod_params)
		{
			break;
		}
		else if(paramMod != ILParamMod_ref && paramMod != ILParamMod_out)
		{
			ILCoerce(info, args[argNum].node,
					 args[argNum].parent, args[argNum].type, paramType);
		}
		++paramNum;
	}

	/* Coerce the remaining "params" parameters */
	paramType = GetMethodParamType(method, signature, paramNum, &paramMod);
	if(paramType != ILType_Invalid && paramMod == ILParamMod_params)
	{
		/* Determine how to repack the arguments */
		if(argNum < numArgs)
		{
			elemType = GetArrayElemType(args[argNum].type);
			if(elemType != ILType_Invalid &&
			   ILCanCoerce(info->context, elemType, paramType))
			{
				/* Pass the argument as an array */
				paramType = ILTypeGetParam
					(signature, ILTypeNumParams(signature));
				ILCoerce(info, args[argNum].node,
						 args[argNum].parent, args[argNum].type, paramType);
				argArray = 0;
			}
			else
			{
				/* Coerce the remaining arguments to the element type */
				for(argNum2 = argNum; argNum2 < numArgs; ++argNum2)
				{
					ILCoerce(info, args[argNum2].node,
							 args[argNum2].parent, args[argNum2].type,
							 paramType);
				}

				/* Build an array that contains the remaining arguments */
				argArray = 0;
				for(argNum2 = argNum; argNum2 < numArgs; ++argNum2)
				{
					if(argArray)
					{
						argArray = ILNode_ArgList_create
										(argArray, *(args[argNum2].parent));
					}
					else
					{
						argArray = *(args[argNum2].parent);
					}
				}
				argArray = ILNode_ArgArray_create
								(paramType, numArgs - argNum, argArray);
			}
		}
		else
		{
			/* No extra arguments, so create an empty array */
			argArray = ILNode_ArgArray_create(paramType, 0, 0);
		}

		/* Build a new argument list if necessary */
		if(argArray)
		{
			argList = 0;
			for(argNum2 = 0; argNum2 < argNum; ++argNum2)
			{
				if(argList)
				{
					argList = ILNode_ArgList_create
									(argList, *(args[argNum2].parent));
				}
				else
				{
					argList = *(args[argNum2].parent);
				}
			}
			if(argList)
			{
				argList = ILNode_ArgList_create(argList, argArray);
			}
			else
			{
				argList = argArray;
			}
			*argListParent = argList;
		}
	}

	/* Return the method's return type to the caller */
	return ILTypeGetReturn(signature);
}

%}
