/*
 * cs_misc.tc - Semantic analysis and codegen for C# miscellaneous node types.
 *
 * Copyright (C) 2001  Southern Storm Software, Pty Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/*
 * Perform semantic analysis for the "typeof" operator.
 */
ILNode_SemAnalysis(ILNode_TypeOf)
{
	CSSemValue value;

	/* Get the semantic value for the sub-expression */
	value = ILNode_SemAnalysis(node->expr, info, &(node->expr));

	/* Check that the argument is of the correct kind */
	if(value.kind == CS_SEMKIND_TYPE)
	{
		if(ILType_IsPrimitive(value.type))
		{
			node->type = ILType_FromClass(ILTypeToClass(info, value.type));
		}
		else
		{
			node->type = value.type;
		}
	}
	else
	{
		CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "invalid argument to `typeof' operator");
		node->type = ILFindSystemType(info, "Int32");
	}

	/* The type of the expression is "System.Type" */
	value.kind = CS_SEMKIND_RVALUE;
	value.type = ILFindSystemType(info, "Type");
	return value;
}

/*
 * Get the type of the "typeof" operator.
 */
ILNode_GetType(ILNode_TypeOf)
{
	return ILMachineType_ObjectRef;
}

/*
 * Generate value code for the "typeof" operator.
 */
ILNode_GenValue(ILNode_TypeOf)
{
	ILGenTypeToken(info, IL_OP_LDTOKEN, node->type);
	ILGenAdjust(info, 1);
	ILGenCallByName(info,
			"class [.library]System.Type "
				"[.library]System.Type::GetTypeFromHandle"
				"(valuetype [.library]System.RuntimeTypeHandle)");
	return ILMachineType_ObjectRef;
}

/*
 * Generate Java value code for the "typeof" operator.
 */
JavaGenValue(ILNode_TypeOf)
{
	const char *name;

	/* Use the "System.Type.GetType" method to resolve the type,
	   because the JVM does not have an equivalent to "ldtoken" */
	name = CSTypeToName(node->type);
	JavaGenStringConst(info, name, strlen(name));
	JavaGenCallByName(info, "System/String", "__FromJavaString",
					  "(Ljava/lang/String;)LSystem/String;");
	JavaGenAdjust(info, 1);
	JavaGenCallByName(info, "System/Type", "GetType",
					  "(LSystem/String;)LSystem/Type;");

	/* The type of the whole expression is "object reference" */
	return ILMachineType_ObjectRef;
}

/*
 * Get the machine type for the "sizeof" operator.
 */
ILNode_GetType(ILNode_SizeOf)
{
	return ILMachineType_Int32;
}

/*
 * Generate value code for the "sizeof" operator.
 */
ILNode_GenValue(ILNode_SizeOf)
{
	if(ILType_IsValueType(node->type))
	{
		ILGenClassToken(info, IL_OP_PREFIX + IL_PREFIX_OP_SIZEOF,
						ILType_ToValueType(node->type));
	}
	else
	{
		ILGenInt32(info, node->size);
	}
	ILGenAdjust(info, 1);
	return ILMachineType_Int32;
}

/*
 * Evaluate the constant value for the "sizeof" operator.
 */
ILNode_EvalConst(ILNode_SizeOf)
{
	if(ILType_IsPrimitive(node->type))
	{
		value->valueType = ILMachineType_Int32;
		value->un.i4Value = node->size;
		return 1;
	}
	else
	{
		/* Non-primitive types must be evaluated at runtime */
		return 0;
	}
}

/*
 * Generate Java value code for the "sizeof" operator.
 */
JavaGenValue(ILNode_SizeOf)
{
	/* Only called for primitive types */
	JavaGenInt32(info, node->size);
	JavaGenAdjust(info, 1);
	return ILMachineType_Int32;
}

/*
 * Perform semantic analysis for the "sizeof" operator.
 */
ILNode_SemAnalysis(ILNode_SizeOf)
{
	CSSemValue value;

	/* Print an error or warning for this construct if necessary */
	CSUnsafeMessage(info, (ILNode *)node, "unsafe `sizeof' operator");

	/* Get the semantic value for the sub-expression */
	value = ILNode_SemAnalysis(node->expr, info, &(node->expr));

	/* Convert native types into their value type forms */
	if(value.kind == CS_SEMKIND_TYPE)
	{
		if(value.type == ILType_Int)
		{
			value.type = ILFindSystemType(info, "IntPtr");
		}
		else if(value.type == ILType_UInt)
		{
			value.type = ILFindSystemType(info, "UIntPtr");
		}
	}

	/* Check the semantic value */
	if(value.kind != CS_SEMKIND_TYPE)
	{
		CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "invalid argument to `sizeof' operator");
		node->type = ILType_Int32;
	}
	else if(!ILType_IsPrimitive(value.type) &&
			!ILType_IsValueType(value.type))
	{
		CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "cannot take the size of a managed type");
		node->type = ILType_Int32;
	}
	else if(!ILType_IsPrimitive(value.type) && info->outputIsJava)
	{
		CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "`sizeof' disallowed when compiling to Java bytecode");
		node->type = ILType_Int32;
	}
	else if(value.type == ILType_Void)
	{
		CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "`void' type is not allowed in this context");
		node->type = ILType_Int32;
	}
	else
	{
		node->type = value.type;
	}

	/* Pre-compute the size if this is a primitive type */
	if(ILType_IsPrimitive(node->type))
	{
		switch(ILType_ToElement(node->type))
		{
			case IL_META_ELEMTYPE_BOOLEAN:
			case IL_META_ELEMTYPE_I1:
			case IL_META_ELEMTYPE_U1:		node->size = 1; break;

			case IL_META_ELEMTYPE_CHAR:
			case IL_META_ELEMTYPE_I2:
			case IL_META_ELEMTYPE_U2:		node->size = 2; break;

			case IL_META_ELEMTYPE_I4:
			case IL_META_ELEMTYPE_U4:
			case IL_META_ELEMTYPE_R4:		node->size = 4; break;

			case IL_META_ELEMTYPE_I8:
			case IL_META_ELEMTYPE_U8:
			case IL_META_ELEMTYPE_R8:		node->size = 8; break;

			default:						node->size = 1; break;
		}
	}

	/* Return the type information to the caller */
	value.kind = CS_SEMKIND_RVALUE;
	value.type = ILType_Int32;
	return value;
}

/*
 * Get the machine type for the "stackalloc" operator.
 */
ILNode_GetType(ILNode_StackAlloc)
{
	if(info->outputIsJava)
	{
		return ILMachineType_ObjectRef;
	}
	else
	{
		return ILMachineType_UnmanagedPtr;
	}
}

/*
 * Generate value code for the "stackalloc" operator.
 */
ILNode_GenValue(ILNode_StackAlloc)
{
	/* TODO */
	return ILMachineType_UnmanagedPtr;
}

/*
 * Generate Java value code for the "stackalloc" operator.
 */
JavaGenValue(ILNode_StackAlloc)
{
	/* TODO */
	return ILMachineType_ObjectRef;
}

/*
 * Perform semantic analysis for the "stackalloc" operator.
 */
ILNode_SemAnalysis(ILNode_StackAlloc)
{
	CSSemValue value1;
	CSSemValue value2;

	/* Print an error or warning for this construct if necessary */
	CSUnsafeMessage(info, (ILNode *)node, "unsafe `stackalloc' operator");

	/* Perform semantic analysis on the sub-expressions */
	value1 = ILNode_SemAnalysis(node->expr1, info, &(node->expr1));
	value2 = ILNode_SemAnalysis(node->expr2, info, &(node->expr2));

	/* The first must be a value type */
	if(value1.kind != CS_SEMKIND_TYPE)
	{
	}

	/* The second must be an "int" */
	/* TODO */

	/* The result has the type "pointer to value1.type" */
	value1.kind = CS_SEMKIND_RVALUE;
	value1.type = ILType_Int32;			/* TODO */
	return value1;
}

ILNode_SemAnalysis(ILNode_NewExpression)
{
	/* TODO */
	return CSSemValueDefault;
}
