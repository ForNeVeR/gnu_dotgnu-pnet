/*
 * cs_stmt.tc - Semantic analysis for C# statement node types.
 *
 * Copyright (C) 2001, 2002  Southern Storm Software, Pty Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

%{

/*
 * Determine if a tree node corresponds to the empty statement.
 */
#define	IsEmpty(node) ((node) == 0 || yykind((node)) == yykindof(ILNode_Empty))

/*
 * Perform semantic analysis on a sub-statement.
 */
static void StmtSem(ILNode *node, ILGenInfo *info, ILNode **parent)
{
	CSSemValue value;
	if(node)
	{
		value = ILNode_SemAnalysis(node, info, parent);
		if(value.kind != CS_SEMKIND_VOID &&
		   value.kind != CS_SEMKIND_LVALUE &&
		   value.kind != CS_SEMKIND_RVALUE)
		{
			CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  "invalid statement");
		}
	}
}

/*
 * Statement context flags.
 */
#define	CS_STMT_LOOP		1
#define	CS_STMT_SWITCH		2
#define	CS_STMT_TRY			4
#define	CS_STMT_CATCH		8
#define	CS_STMT_FINALLY		16

/*
 * Push a statement context.
 */
static void PushStmtContext(ILGenInfo *info, int context)
{
	if(info->contextStackSize >= info->contextStackMax)
	{
		/* Increase the size of the context stack */
		int *newstack;
		newstack = (int *)ILRealloc(info->contextStack,
									sizeof(int) * (info->contextStackMax + 4));
		if(!newstack)
		{
			ILGenOutOfMemory(info);
		}
		info->contextStack = newstack;
		info->contextStackMax += 4;
	}
	info->contextStack[info->contextStackSize] = context;
	++(info->contextStackSize);
}

/*
 * Pop the top-most statement context.
 */
static void PopStmtContext(ILGenInfo *info)
{
	--(info->contextStackSize);
}

/*
 * Determine if we are within a specific context, but not
 * within a "stop" context.  e.g. "break" can be used
 * within a loop, but not in the body of a "finally"
 * within the loop.  "finally" is the "stop" context.
 */
static int StmtContextOK(ILGenInfo *info, int context, int stopContext)
{
	long posn = info->contextStackSize;
	while(posn > 0)
	{
		--posn;
		if((info->contextStack[posn] & stopContext) != 0)
		{
			return 0;
		}
		if((info->contextStack[posn] & context) != 0)
		{
			return 1;
		}
	}
	if(!context)
	{
		/* We are checking a "return" statement */
		return 1;
	}
	else
	{
		/* We are checking some other kind of statement */
		return 0;
	}
}

%}

/*
 * Perform semantic analysis for the empty statement.
 */
ILNode_SemAnalysis(ILNode_Empty)
{
	CSSemValue value;
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the compound statement.
 */
ILNode_SemAnalysis(ILNode_Compound),
ILNode_SemAnalysis(ILNode_List)
{
	ILNode_ListIter iter;
	ILNode *child;
	ILNode *replace;
	CSSemValue value;
	ILNode_ListIter_Init(&iter, node);
	while((child = ILNode_ListIter_Next(&iter)) != 0)
	{
		replace = child;
		StmtSem(child, info, &replace);
		if(replace != child)
		{
			*(iter.last) = replace;
		}
	}
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "if" statement.
 *
 * Note: we assume that the condition has been wrapped in
 * a "ToBool" node to take care of the semantic analysis
 * for the boolean cast.
 */
ILNode_SemAnalysis(ILNode_If)
{
	CSSemValue value;
	ILNode_SemAnalysis(node->expr, info, &(node->expr));
	StmtSem(node->thenClause, info, &(node->thenClause));
	StmtSem(node->elseClause, info, &(node->elseClause));
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "while" statement.
 *
 * Note: we assume that the condition has been wrapped in
 * a "ToBool" node to take care of the semantic analysis
 * for the boolean cast.
 */
ILNode_SemAnalysis(ILNode_While)
{
	CSSemValue value;
	ILNode_SemAnalysis(node->cond, info, &(node->cond));
	PushStmtContext(info, CS_STMT_LOOP);
	StmtSem(node->stmt, info, &(node->stmt));
	PopStmtContext(info);
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "do" statement.
 *
 * Note: we assume that the condition has been wrapped in
 * a "ToBool" node to take care of the semantic analysis
 * for the boolean cast.
 */
ILNode_SemAnalysis(ILNode_Do)
{
	CSSemValue value;
	PushStmtContext(info, CS_STMT_LOOP);
	StmtSem(node->stmt, info, &(node->stmt));
	PopStmtContext(info);
	ILNode_SemAnalysis(node->cond, info, &(node->cond));
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "for" statement.
 *
 * Note: we assume that the condition has been wrapped in
 * a "ToBool" node to take care of the semantic analysis
 * for the boolean cast.
 */
ILNode_SemAnalysis(ILNode_For)
{
	CSSemValue value;
	StmtSem(node->init, info, &(node->init));
	ILNode_SemAnalysis(node->cond, info, &(node->cond));
	StmtSem(node->incr, info, &(node->incr));
	PushStmtContext(info, CS_STMT_LOOP);
	StmtSem(node->stmt, info, &(node->stmt));
	PopStmtContext(info);
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "foreach" statement.
 */
ILNode_SemAnalysis(ILNode_Foreach)
{
	/* TODO */
	CSSemValue value;
	if(CSHasUnsafeType(node->type))
	{
		CSUnsafeTypeMessage(info, (ILNode *)node);
	}
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "foreach collection" statement.
 */
ILNode_SemAnalysis(ILNode_ForeachCollection)
{
	/* We don't need to do anything here, as this node type is
	   synthesized by the "ILNode_Foreach" processing */
	CSSemValue value;
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "switch" statement.
 */
ILNode_SemAnalysis(ILNode_Switch)
{
	/* TODO */
	CSSemValue value;
	PushStmtContext(info, CS_STMT_SWITCH);
	PopStmtContext(info);
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "switch section list" statement.
 */
ILNode_SemAnalysis(ILNode_SwitchSectList)
{
	/* TODO */
	CSSemValue value;
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "switch section" statement.
 */
ILNode_SemAnalysis(ILNode_SwitchSection)
{
	/* TODO */
	CSSemValue value;
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "switch case list" statement.
 */
ILNode_SemAnalysis(ILNode_CaseList)
{
	/* TODO */
	CSSemValue value;
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "case label" statement.
 */
ILNode_SemAnalysis(ILNode_CaseLabel)
{
	/* TODO */
	CSSemValue value;
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "default label" statement.
 */
ILNode_SemAnalysis(ILNode_DefaultLabel)
{
	/* TODO */
	CSSemValue value;
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "goto" statement.
 */
ILNode_SemAnalysis(ILNode_Goto)
{
	/* TODO */
	CSSemValue value;
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "goto label" statement.
 */
ILNode_SemAnalysis(ILNode_GotoLabel)
{
	/* TODO */
	CSSemValue value;
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "goto case" statement.
 */
ILNode_SemAnalysis(ILNode_GotoCase)
{
	/* TODO */
	CSSemValue value;
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "goto default" statement.
 */
ILNode_SemAnalysis(ILNode_GotoDefault)
{
	/* TODO */
	CSSemValue value;
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "break" statement.
 */
ILNode_SemAnalysis(ILNode_Break)
{
	CSSemValue value;
	PushStmtContext(info, CS_STMT_SWITCH);

	if(!StmtContextOK(info, CS_STMT_LOOP | CS_STMT_SWITCH, CS_STMT_FINALLY))
	{
		if(StmtContextOK(info, CS_STMT_FINALLY, 0))
		{
			CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  "`break' used inside `finally' clause");
		}
		else
		{
			CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  "`break' used outside loop or switch");
		}
	}
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "continue" statement.
 */
ILNode_SemAnalysis(ILNode_Continue)
{
	CSSemValue value;
	if(!StmtContextOK(info, CS_STMT_LOOP, CS_STMT_FINALLY))
	{
		if(StmtContextOK(info, CS_STMT_FINALLY, 0))
		{
			CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  "`continue' used inside `finally' clause");
		}
		else
		{
			CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  "`continue' used outside loop");
		}
	}
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "return" statement.
 */
ILNode_SemAnalysis(ILNode_Return)
{
	/* Emit an error if the return type is not "void" */
	ILType *returnType = ILTypeGetReturn(ILMethod_Signature
		(((ILNode_MethodDeclaration *)(info->currentMethod))->methodInfo));
	if(returnType != ILType_Void)
	{
		CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
			  "`return' with no value, in method returning non-void");
	}
	if(!StmtContextOK(info, 0, CS_STMT_FINALLY))
	{
		CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
			  		  "`return' used inside `finally' clause");
	}
	return CSSemValueDefault;
}

/*
 * Perform semantic analysis for the "return expression" statement.
 */
ILNode_SemAnalysis(ILNode_ReturnExpr)
{
	CSSemValue value;
	ILType *returnType;

	/* Perform semantic analysis on the expression */
	if(!CSSemExpectValue(node->expr, info, &(node->expr), &value))
	{
		CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "invalid return value");
		return CSSemValueDefault;
	}

	/* Determine if the value is compatible with the return type */
	returnType = ILTypeGetReturn(ILMethod_Signature
		(((ILNode_MethodDeclaration *)(info->currentMethod))->methodInfo));
	if(returnType == ILType_Void)
	{
		CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "`return' with a value, in method returning void");
	}
	else
	{
		/* Coerce to the return type */
		if(!ILCoerce(info, node->expr, &(node->expr), value.type, returnType))
		{
			CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
				  		  "incompatible types in return: "
						  		"no conversion from `%s' to `%s'",
						  CSTypeToName(value.type), CSTypeToName(returnType));
		}
	}

	/* Check that the return was not used inside a "finally" clause */
	if(!StmtContextOK(info, 0, CS_STMT_FINALLY))
	{
		CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
			  		  "`return' used inside `finally' clause");
	}

	/* Done */
	return CSSemValueDefault;
}

/*
 * Perform semantic analysis for the "throw" statement.
 */
ILNode_SemAnalysis(ILNode_Throw)
{
	CSSemValue value;
	if(!StmtContextOK(info, CS_STMT_CATCH, CS_STMT_FINALLY | CS_STMT_TRY))
	{
		CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
	  		  "`throw' with no value must be used inside a `catch' clause");
	}
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "throw expression" statement.
 */
ILNode_SemAnalysis(ILNode_ThrowExpr)
{
	CSSemValue value;
	ILType *exceptionClass;

	/* Perform semantic analysis on the value */
	if(!CSSemExpectValue(node->expr, info, &(node->expr), &value))
	{
		CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
	  		  		  "invalid throw expression");
		value.kind = CS_SEMKIND_RVALUE;
		value.type = ILType_Null;
	}

	/* Attempt to coerce the value to "System.Exception" */
	exceptionClass = ILFindSystemType(info, "Exception");
	if(!ILCoerce(info, node->expr, &(node->expr), value.type, exceptionClass))
	{
		CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
	  		  		  "no conversion from `%s' to `%s'",
					  CSTypeToName(value.type), CSTypeToName(exceptionClass));
	}

	/* Done */
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "try" statement.
 */
ILNode_SemAnalysis(ILNode_Try)
{
	CSSemValue value;

	/* Enter a "try" context */
	PushStmtContext(info, CS_STMT_TRY);

	/* Perform semantic analysis on the "try" body */
	StmtSem(node->stmt, info, &(node->stmt));

	/* Perform semantic analysis on the "catch" clauses */
	StmtSem(node->catchClauses, info, &(node->catchClauses));

	/* Perform semantic analysis on the "finally" clause */
	StmtSem(node->finallyClause, info, &(node->finallyClause));

	/* Exit from the "try" context */
	PopStmtContext(info);

	/* Done */
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "catch clause" statement.
 */
ILNode_SemAnalysis(ILNode_CatchClause)
{
	CSSemValue value;
	ILType *exceptionType = ILFindSystemType(info, "Exception");
	ILType *thrownType;
	ILScope *newScope;
	ILNode_MethodDeclaration *method =
		(ILNode_MethodDeclaration *)(info->currentMethod);

	/* Enter a "catch" context */
	PushStmtContext(info, CS_STMT_CATCH);

	/* Wrap the catch body in a new scope */
	newScope = ILScopeCreate(info, info->currentScope);
	node->stmt = ILNode_NewScope_create(node->stmt);
	((ILNode_NewScope *)(node->stmt))->scope = newScope;

	/* Validate the thrown value type */
	if(node->type)
	{
		thrownType = CSSemType(node->type, info, &(node->type));
		if(!ILCanCoerce(info->context, thrownType, exceptionType))
		{
			CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
		  		  		  "`%s' does not inherit from `%s'",
						  CSTypeToName(thrownType),
						  CSTypeToName(exceptionType));
			thrownType = exceptionType;
		}
	}
	else
	{
		thrownType = exceptionType;
	}
	node->classInfo = ILTypeToClass(info, thrownType);

	/* Declare a new local variable for the catch value */
	if(node->name)
	{
		/* Add the type to the local variable signature for this method */
		if(!(method->localVarSig))
		{
			method->localVarSig = ILTypeCreateLocalList(info->context);
			if(!(method->localVarSig))
			{
				CSOutOfMemory();
			}
		}
		if(!ILTypeAddLocal(info->context, method->localVarSig, thrownType))
		{
			CSOutOfMemory();
		}

		/* Create a local variable entry in the current scope */
		ILScopeDeclareLocal(newScope, node->name,
							ILTypeNumLocals(method->localVarSig) - 1,
							node->nameNode);

		/* Record the local variable index for the code generator */
		node->varIndex = ILTypeNumLocals(method->localVarSig) - 1;
	}

	/* Perform semantic analysis on the catch body */
	StmtSem(node->stmt, info, &(node->stmt));

	/* Exit from the "catch" context */
	PopStmtContext(info);

	/* Done */
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "finally clause" statement.
 */
ILNode_SemAnalysis(ILNode_FinallyClause)
{
	CSSemValue value;

	/* Enter a "finally" context */
	PushStmtContext(info, CS_STMT_FINALLY);

	/* Perform semantic analysis on the finally body */
	StmtSem(node->stmt, info, &(node->stmt));

	/* Exit from the "finally" context */
	PopStmtContext(info);

	/* Done */
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "lock" statement.
 */
ILNode_SemAnalysis(ILNode_Lock)
{
	CSSemValue value;
	ILType *objectType = ILFindSystemType(info, "Object");

	/* Perform semantic analysis on the lock expression */
	if(!CSSemExpectValue(node->expr, info, &(node->expr), &value))
	{
		CSErrorOnLine(yygetfilename(node->expr), yygetlinenum(node->expr),
					  "invalid lock expression");
		value.kind = CS_SEMKIND_RVALUE;
		value.type = objectType;
	}

	/* Coerce the lock expression to "System.Object" */
	if(!ILCoerce(info, node->expr, &(node->expr), value.type, objectType))
	{
		CSErrorOnLine(yygetfilename(node->expr), yygetlinenum(node->expr),
					  "no conversion from `%s' to `%s'",
					  CSTypeToName(value.type), CSTypeToName(objectType));
	}

	/* Enter a "try" context */
	PushStmtContext(info, CS_STMT_TRY);

	/* Perform semantic analysis on the lock statement body */
	StmtSem(node->stmt, info, &(node->stmt));

	/* Exit from the "try" context */
	PopStmtContext(info);

	/* Done */
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "using" statement.
 */
ILNode_SemAnalysis(ILNode_Using)
{
	/* TODO */
	CSSemValue value;
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Generate discard code for the "using" statement.
 */
ILNode_GenDiscard(ILNode_Using)
{
	/* TODO */
}

/*
 * Generate Java discard code for the "using" statement.
 */
JavaGenDiscard(ILNode_Using)
{
	/* TODO */
}

/*
 * Perform semantic analysis for the "unsafe" statement.
 */
ILNode_SemAnalysis(ILNode_Unsafe)
{
	CSSemValue value;
	CSUnsafeEnter(info, (ILNode *)node, "unsafe statement");
	StmtSem(node->stmt, info, &(node->stmt));
	CSUnsafeLeave(info);
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Generate discard code for the "unsafe" statement.
 */
ILNode_GenDiscard(ILNode_Unsafe)
{
	ILNode_GenDiscard(node->stmt, info);
}

/*
 * Generate Java discard code for the "unsafe" statement.
 */
JavaGenDiscard(ILNode_Unsafe)
{
	JavaGenDiscard(node->stmt, info);
}

/*
 * Perform semantic analysis for the "fixed" statement.
 */
ILNode_SemAnalysis(ILNode_Fixed)
{
	/* TODO */
	CSSemValue value;
	CSUnsafeMessage(info, (ILNode *)node, "unsafe `fixed' statement");
	if(info->outputIsJava)
	{
		CSErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "`fixed' disallowed when compiling to Java bytecode");
	}
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Generate discard code for the "fixed" statement.
 */
ILNode_GenDiscard(ILNode_Fixed)
{
	/* TODO */
}

/*
 * Generate Java discard code for the "fixed" statement.
 */
JavaGenDiscard(ILNode_Fixed)
{
	/* Nothing to do here: `fixed' is illegal for Java code */
}

/*
 * Perform semantic analysis for "fixed declarator" lists.
 */
ILNode_SemAnalysis(ILNode_FixedDeclList)
{
	/* TODO */
	CSSemValue value;
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "fix address" node.
 */
ILNode_SemAnalysis(ILNode_FixAddress)
{
	/* TODO */
	CSSemValue value;
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for the "fix expression" node.
 */
ILNode_SemAnalysis(ILNode_FixExpr)
{
	/* TODO */
	CSSemValue value;
	value.kind = CS_SEMKIND_VOID;
	value.type = 0;
	return value;
}

/*
 * Perform semantic analysis for local variable declarations.
 */
ILNode_SemAnalysis(ILNode_LocalVarDeclaration)
{
	ILType *type;
	ILNode_ListIter iter;
	ILNode *nameNode;
	char *name;
	ILScopeData *data;
	ILNode_MethodDeclaration *method;
	ILNode *errorNode;

	/* Locate the method that this local is declared within */
	method = (ILNode_MethodDeclaration *)(info->currentMethod);

	/* Perform semantic analysis on the local variable type */
	type = CSSemType(node->type, info, &(node->type));

	/* Scan through the variable names and declare them in the current scope */
	ILNode_ListIter_Init(&iter, node->varNames);
	while((nameNode = ILNode_ListIter_Next(&iter)) != 0)
	{
		name = ILQualIdentName(nameNode, 0);
		data = ILScopeLookup(info->currentScope, name, 0);
		if(data)
		{
			/* The name is already declared in this scope */
			CSErrorOnLine(yygetfilename(nameNode), yygetlinenum(nameNode),
						  "`%s' is already declared in this scope", name);
			errorNode = ILScopeDataGetNode(data);
			if(errorNode)
			{
				CSErrorOnLine(yygetfilename(errorNode), yygetlinenum(errorNode),
							  "previous declaration here");
			}
		}
		else
		{
			/* Add the type to the local variable signature for this method */
			if(!(method->localVarSig))
			{
				method->localVarSig = ILTypeCreateLocalList(info->context);
				if(!(method->localVarSig))
				{
					CSOutOfMemory();
				}
			}
			if(!ILTypeAddLocal(info->context, method->localVarSig, type))
			{
				CSOutOfMemory();
			}

			/* Create a local variable entry in the current scope */
			ILScopeDeclareLocal(info->currentScope, name,
								ILTypeNumLocals(method->localVarSig) - 1,
								nameNode);
		}
	}

	/* Return the default value to the caller */
	return CSSemValueDefault;
}

/*
 * Perform semantic analysis for local constant declarations.
 */
ILNode_SemAnalysis(ILNode_LocalConstDeclaration)
{
	/* TODO */
	return CSSemValueDefault;
}

/*
 * Perform semantic analysis for line number information blocks.
 */
ILNode_SemAnalysis(ILNode_LineInfo)
{
	return ILNode_SemAnalysis(node->stmt, info, &(node->stmt));
}
