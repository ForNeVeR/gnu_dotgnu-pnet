/*
 * cs_invoke.tc - Semantic analysis for method invocation.
 *
 * Copyright (C) 2001  Southern Storm Software, Pty Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

%decls %{

/*
 * Convert a program item (method, property, or delegate)
 * into a printable name, suitable for use in error messages.
 */
const char *CSItemToName(ILProgramItem *item);

/*
 * Information that is kept about an evaluated argument.
 */
typedef struct
{
	ILType	   *type;
	ILNode     *node;
	ILNode    **parent;
	ILParameterModifier modifier;

} CSEvalArg;

/*
 * Evaluate a list of arguments for a method invocation.
 * Returns the number of arguments, or -1 on error.
 */
int CSEvalArguments(ILGenInfo *info, ILNode *argList,
					ILNode **argListParent, CSEvalArg **args);

/*
 * Free an evaluated argument list.
 */
void CSEvalFreeArguments(CSEvalArg *args);

/*
 * Determine if a program item (method, property, or delegate)
 * is a candidate for evaluation.  Returns 0 if not a candidate,
 * 1 if a candidate in its normal form, and 2 if a candidate
 * in its expanded form.
 */
int CSItemIsCandidate(ILGenInfo *info, ILProgramItem *item,
					  CSEvalArg *args, int numArgs);

/*
 * Determine the best item candidate in a group.
 * Returns NULL if none of the methods are "best".
 */
ILProgramItem *CSBestCandidate(ILGenInfo *info, void *group,
						       CSEvalArg *args, int numArgs);

/*
 * Coerce the arguments and set up the final argument list.
 * Returns the item's return type.
 */
ILType *CSItemCoerceArgs(ILGenInfo *info, ILProgramItem *item,
						 CSEvalArg *args, int numArgs,
						 ILNode **argListParent);

/*
 * Report an error message for a failed item signature match,
 * listing the candidates for the call.
 */
void CSItemCandidateError(ILNode *node, char *itemName, int isCtor,
						  void *group, CSEvalArg *args, int numArgs);

%}

/*
 * Perform semantic analysis for the argument list operator.
 */
ILNode_SemAnalysis(ILNode_ArgList)
{
	CSSemValue value1;
	CSSemValue value2;
	value1 = ILNode_SemAnalysis(node->expr1, info, &(node->expr1));
	value2 = ILNode_SemAnalysis(node->expr2, info, &(node->expr2));
	if(!CSIsSemValue(value1.kind) || !CSIsSemValue(value2.kind))
	{
		CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "invalid operands to binary `,'");
	}
	return value2;
}

ILNode_SemAnalysis(ILNode_Argument)
{
	CSSemValue value;
	value = ILNode_SemAnalysis(node->expression, info, &(node->expression));
	if(node->modifier == ILParamMod_out ||
	   node->modifier == ILParamMod_ref)
	{
		if(value.kind != CS_SEMKIND_LVALUE ||
		   yyisa(node->expression, ILNode_LValueNoRef))
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  "invalid lvalue in `%s' argument",
						  (node->modifier == ILParamMod_out
						  		? "out" : "ref"));
			if(value.kind == CS_SEMKIND_RVALUE ||
			   value.kind == CS_SEMKIND_SVALUE)
			{
				value.kind = CS_SEMKIND_LVALUE;
			}
			else
			{
				value.kind = CS_SEMKIND_LVALUE;
				value.type = ILType_Int32;
			}
		}
		if(info->outputIsJava)
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
			  "`%s' arguments not permitted when compiling to Java bytecode",
			  (node->modifier == ILParamMod_out ? "out" : "ref"));
		}
	}
	return value;
}

%{

void CSItemCandidateError(ILNode *node, char *itemName, int isCtor,
						  void *group, CSEvalArg *args, int numArgs)
{
	unsigned long num;
	ILProgramItem *item;
	ILIntString str;
	int argNum;

	/* Report the item name and argument types */
	if(itemName)
	{
		/* Construct a list of the argument types for the error */
		str = ILInternString(itemName, -1);
		str = ILInternAppendedString(str, ILInternString("(", 1));
		for(argNum = 0; argNum < numArgs; ++argNum)
		{
			if(argNum != 0)
			{
				str = ILInternAppendedString(str, ILInternString(", ", 2));
			}
			if(args[argNum].modifier == ILParamMod_out)
			{
				str = ILInternAppendedString(str, ILInternString("out ", 4));
			}
			else if(args[argNum].modifier == ILParamMod_ref)
			{
				str = ILInternAppendedString(str, ILInternString("ref ", 4));
			}
			str = ILInternAppendedString
					(str, ILInternString
							((char *)CSTypeToName(args[argNum].type), -1));
		}
		str = ILInternAppendedString(str, ILInternString(")", 1));
		CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "no matching method for call to `%s'",
					  str.string);
	}
	else if(isCtor)
	{
		/* Don't know what the method name is */
		CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "no matching constructor");
	}
	else
	{
		/* Don't know what the method name is */
		CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "no matching method for call");
	}

	/* Report the candidates */
	num = 0;
	while((item = CSGetGroupMember(group, num)) != 0)
	{
		if(!num)
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  "candidates are: %s", CSItemToName(item));
		}
		else
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
						  "                %s", CSItemToName(item));
		}
		++num;
	}
}

%}

/*
 * Perform semantic analysis for a method invocation.
 */
ILNode_SemAnalysis(ILNode_InvocationExpression)
{
	CSSemValue value;
	CSSemValue method;
	ILProgramItem *itemInfo;
	ILMethod *methodInfo;
	ILType *retType;
	CSEvalArg *args;
	int numArgs;
	unsigned long itemNum;
	char *itemName;
	int candidateForm;
	ILNode_MethodDeclaration *caller;

	/* Get the method name for later error reporting */
	if(ILIsQualIdent(node->expr1))
	{
		itemName = ILQualIdentName(node->expr1, 0);
	}
	else if(yyisa(node->expr1, ILNode_MemberAccess))
	{
		itemName = ILQualIdentName
			(((ILNode_MemberAccess *)(node->expr1))->expr2, 0);
	}
	else
	{
		itemName = 0;
	}

	/* Perform semantic analysis on the method expression */
	method = ILNode_SemAnalysis(node->expr1, info, &(node->expr1));
	if(CSIsSemValue(method.kind) && ILTypeIsDelegate(method.type))
	{
		/* This is a delegate invocation: create a method group
		   that contains the "Invoke" method as its only member */
		method.kind = CS_SEMKIND_METHOD_GROUP;
		method.type = (ILType *)CSCreateMethodGroup
				(ILTypeGetDelegateMethod(method.type));
	}
	else if(method.kind != CS_SEMKIND_METHOD_GROUP)
	{
		CCErrorOnLine(yygetfilename(node->expr1), yygetlinenum(node->expr1),
					  "called object is not a method or delegate");
		return CSSemValueDefault;
	}

	/* Bail out if the method group is NULL.  This is used by "BaseInit"
	   to indicate no parent constructor in "System.Object" */
	if(method.type == 0)
	{
		if(node->expr2)
		{
			/* Cannot use arguments on "System.Object"'s base initializer */
			CCErrorOnLine(yygetfilename(node->expr2),
						  yygetlinenum(node->expr2),
						  "too many arguments to base type constructor");
		}
		value.kind = CS_SEMKIND_VOID;
		value.type = (ILType *)0;
		return value;
	}

	/* Evaluate the arguments */
	numArgs = CSEvalArguments(info, node->expr2, &(node->expr2), &args);
	if(numArgs < 0)
	{
		return CSSemValueDefault;
	}

	/* Find the set of candidate methods */
	itemNum = 0;
	while((itemInfo = CSGetGroupMember((void *)(method.type), itemNum)) != 0)
	{
		candidateForm = CSItemIsCandidate(info, itemInfo, args, numArgs);
		if(candidateForm)
		{
			CSSetGroupMemberForm((void *)(method.type), itemNum,
								 candidateForm);
			++itemNum;
		}
		else
		{
			method.type = (ILType *)CSRemoveGroupMember
								((void *)(method.type), itemNum);
		}
	}

	/* If there are no candidates left, then bail out */
	itemNum = 0;
	itemInfo = CSGetGroupMember((void *)(method.type), itemNum);
	if(!itemInfo)
	{
		CSItemCandidateError((ILNode *)node, itemName, 0,
						     (void *)(method.type), args, numArgs);
		CSEvalFreeArguments(args);
		return CSSemValueDefault;
	}

	/* There are two or more candidates, then try to find the best one */
	if(CSGetGroupMember((void *)(method.type), 1) != 0)
	{
		itemInfo = CSBestCandidate(info, (void *)(method.type),
								   args, numArgs);
		if(!itemInfo)
		{
			CSItemCandidateError((ILNode *)node, itemName, 0,
							     (void *)(method.type), args, numArgs);
			CSEvalFreeArguments(args);
			return CSSemValueDefault;
		}
	}

	/* Import the method into this image, and set it within the node */
	methodInfo = (ILMethod *)itemInfo;
	methodInfo = (ILMethod *)ILMemberImport
						(info->image, (ILMember *)methodInfo);
	node->methodInfo = methodInfo;

	/* Handle the "this" parameter if necessary */
	if(!ILMethod_IsStatic(methodInfo))
	{
		node->thisExpr = node->expr1;
		if(yyisa(node->thisExpr, ILNode_This))
		{
			caller = (ILNode_MethodDeclaration *)(info->currentMethod);
			if(!caller || (caller->modifiers & IL_META_METHODDEF_STATIC) != 0)
			{
				/* Attempt to call an instance method using "this"
				   from within a static method */
				CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "cannot access instance members in static methods");
			}
		}
	}

	/* Coerce the arguments and build the final argument list */
	retType = CSItemCoerceArgs(info, ILToProgramItem(methodInfo),
							   args, numArgs, &(node->expr2));
	CSEvalFreeArguments(args);

	/* The semantic value is the method's return type as an r-value */
	if(retType == ILType_Void)
	{
		value.kind = CS_SEMKIND_VOID;
		value.type = 0;
	}
	else
	{
		value.kind = CS_SEMKIND_RVALUE;
		value.type = retType;
	}
	return value;
}

/*
 * Perform semantic analysis for an object creation expression.
 */
ILNode_SemAnalysis(ILNode_ObjectCreationExpression)
{
	CSSemValue value;
	CSSemValue method;
	ILProgramItem *itemInfo;
	ILMethod *methodInfo;
	ILType *objectType;
	ILClass *objectClass;
	CSEvalArg *args;
	int numArgs;
	unsigned long itemNum;
	int candidateForm;

	/* Perform semantic analysis on the type */
	objectType = CSSemType(node->type, info, &(node->type));

	/* Set up the default return value */
	value.kind = CS_SEMKIND_RVALUE;
	value.type = objectType;

	/* The type must be a non-abstract class or a value type */
	if(ILType_IsClass(objectType))
	{
		objectClass = ILClassResolve(ILType_ToClass(objectType));
		if(ILClass_IsInterface(objectClass))
		{
			CCErrorOnLine(yygetfilename(node->type), yygetlinenum(node->type),
			  "cannot instantiate interface `%s' with the `new' operator",
			  CSTypeToName(objectType));
			return value;
		}
		else if(ILClass_IsAbstract(objectClass))
		{
			CCErrorOnLine(yygetfilename(node->type), yygetlinenum(node->type),
			  "cannot instantiate abstract class `%s' with the `new' operator",
			  CSTypeToName(objectType));
			return value;
		}
	}
	else if(ILTypeIsValue(objectType))
	{
		/* Check for the default constructor case */
		if(!(node->argList))
		{
			/* Replace this node with a default constructor call */
			*parent = ILNode_DefaultConstructor_create(objectType);
			yysetfilename(*parent, yygetfilename(node));
			yysetlinenum(*parent, yygetlinenum(node));
			return value;
		}
	}
	else
	{
		CCErrorOnLine(yygetfilename(node->type), yygetlinenum(node->type),
			  		  "`%s' is not a class or value type",
					  CSTypeToName(objectType));
		return value;
	}

	/* Get the list of accessible constructors for the type */
	method = CSResolveConstructor(info, node->type, objectType);
	if(method.kind != CS_SEMKIND_METHOD_GROUP)
	{
		CCErrorOnLine(yygetfilename(node->type), yygetlinenum(node->type),
					  "`%s' does not have an accessible constructor",
					  CSTypeToName(objectType));
		return value;
	}

	/* Evaluate the arguments */
	numArgs = CSEvalArguments(info, node->argList, &(node->argList), &args);
	if(numArgs < 0)
	{
		return value;
	}

	/* Find the set of candidate methods */
	itemNum = 0;
	while((itemInfo = CSGetGroupMember((void *)(method.type), itemNum)) != 0)
	{
		candidateForm = CSItemIsCandidate(info, itemInfo, args, numArgs);
		if(candidateForm)
		{
			CSSetGroupMemberForm((void *)(method.type), itemNum,
								 candidateForm);
			++itemNum;
		}
		else
		{
			method.type = (ILType *)CSRemoveGroupMember
								((void *)(method.type), itemNum);
		}
	}

	/* If there are no candidates left, then bail out */
	itemNum = 0;
	itemInfo = CSGetGroupMember((void *)(method.type), itemNum);
	if(!itemInfo)
	{
		CSItemCandidateError((ILNode *)node, 0, 1,
						     (void *)(method.type), args, numArgs);
		CSEvalFreeArguments(args);
		return value;
	}

	/* There are two or more candidates, then try to find the best one */
	if(CSGetGroupMember((void *)(method.type), 1) != 0)
	{
		itemInfo = CSBestCandidate(info, (void *)(method.type),
								   args, numArgs);
		if(!itemInfo)
		{
			CSItemCandidateError((ILNode *)node, 0, 1,
							     (void *)(method.type), args, numArgs);
			CSEvalFreeArguments(args);
			return value;
		}
	}

	/* Import the method into this image, and set it within the node */
	methodInfo = (ILMethod *)itemInfo;
	methodInfo = (ILMethod *)ILMemberImport
						(info->image, (ILMember *)methodInfo);
	node->methodInfo = methodInfo;

	/* Coerce the arguments and build the final argument list */
	CSItemCoerceArgs(info, ILToProgramItem(methodInfo),
					 args, numArgs, &(node->argList));
	CSEvalFreeArguments(args);

	/* Return the final semantic value */
	return value;
}

/*
 * Perform semantic analysis for a default constructor call.
 */
ILNode_SemAnalysis(ILNode_DefaultConstructor)
{
	/* This is a dummy: it won't be called in practice */
	return CSSemValueDefault;
}

/*
 * Perform semantic analysis for a reference to a base constructor.
 */
ILNode_SemAnalysis(ILNode_BaseInit)
{
	CSSemValue value;
	ILClass *classInfo;
	ILClass *parentInfo;

	/* If we are compiling "System.Object", then we need to
	   bail out with an empty method group.  This tells
	   "InvocationExpression" to ignore the call */
	classInfo = ((ILNode_ClassDefn *)(info->currentClass))->classInfo;
	parentInfo = (classInfo ? ILClass_Parent(classInfo) : 0);
	if(!parentInfo)
	{
		value.kind = CS_SEMKIND_METHOD_GROUP;
		value.type = (ILType *)0;
		return value;
	}

	/* If the current class is a value type, then bail out.
	   We don't want to call the base class constructor
	   in this case */
	if(ILClassIsValueType(classInfo))
	{
		value.kind = CS_SEMKIND_METHOD_GROUP;
		value.type = (ILType *)0;
		return value;
	}

	/* Resolve the constructor within the base class */
	value.kind = CS_SEMKIND_RVALUE;
	value.type = ILType_FromClass(parentInfo);
	value = CSResolveConstructor(info, (ILNode *)node, value.type);

	/* Report an error if we could not find any accessible constructors */
	if(value.kind != CS_SEMKIND_METHOD_GROUP)
	{
		CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "no accessible base class constructors");
	}

	/* Replace the current expression with "this" */
	*parent = ILNode_This_create();
	return value;
}

/*
 * Perform semantic analysis for a reference to a "this" constructor.
 */
ILNode_SemAnalysis(ILNode_ThisInit)
{
	CSSemValue value;
	ILClass *classInfo;

	/* Resolve the constructor within the current class */
	classInfo = ((ILNode_ClassDefn *)(info->currentClass))->classInfo;
	value.kind = CS_SEMKIND_RVALUE;
	value.type = ILType_FromClass(classInfo);
	value = CSResolveConstructor(info, (ILNode *)node, value.type);

	/* Replace the current expression with "this" */
	*parent = ILNode_This_create();
	return value;
}

/*
 * Perform semantic analysis for a reference to a non-static initializer.
 */
ILNode_SemAnalysis(ILNode_NonStaticInit)
{
	/* Non-static initializer calls are always "void" statements */
	return CSSemValueDefault;
}

/*
 * Perform semantic analysis for argument array nodes.
 */
ILNode_SemAnalysis(ILNode_ArgArray)
{
	/* This will never be called */
	return CSSemValueDefault;
}

%{

/*
 * Count the number of arguments in an ArgList.
 */
static unsigned CountArgList(ILNode *argList)
{
	unsigned count;
	if(!argList)
	{
		return 0;
	}
	count = 1;
	while(yyisa(argList, ILNode_ArgList))
	{
		++count;
		argList = ((ILNode_ArgList *)argList)->expr1;
	}
	return count;
}

/*
 * Get the parameter modifier for an argument.
 */
static ILParameterModifier GetParamModForArg(ILNode *arg)
{
	if(yyisa(arg, ILNode_Argument))
	{
		return ((ILNode_Argument *)arg)->modifier;
	}
	else
	{
		return ILParamMod_empty;
	}
}

int CSEvalArguments(ILGenInfo *info, ILNode *argList,
					ILNode **argListParent, CSEvalArg **args)
{
	int argCount;
	int argNum;
	CSEvalArg *argArray;
	ILNode *tempList;
	ILNode **tempParent;
	int tempNum;
	int haveErrors;
	CSSemValue value;

	/* Get the number of arguments that have been supplied */
	argCount = CountArgList(argList);

	/* Bail out if there are no arguments */
	if(!argCount)
	{
		*args = 0;
		return 0;
	}

	/* Allocate an argument array */
	argArray = (CSEvalArg *)ILMalloc(sizeof(CSEvalArg) * argCount);
	if(!argArray)
	{
		CCOutOfMemory();
	}

	/* Perform semantic analysis on the arguments and fill the array */
	haveErrors = 0;
	for(argNum = 0; argNum < argCount; ++argNum)
	{
		/* Find the argument node and its parent */
		tempList = argList;
		tempParent = argListParent;
		tempNum = argNum + 1;
		while(tempNum < argCount)
		{
			tempParent = &(((ILNode_ArgList *)tempList)->expr1);
			tempList = ((ILNode_ArgList *)tempList)->expr1;
			++tempNum;
		}
		if(yyisa(tempList, ILNode_ArgList))
		{
			tempParent = &(((ILNode_ArgList *)tempList)->expr2);
			tempList = ((ILNode_ArgList *)tempList)->expr2;
		}

		/* Populate the argument array element */
		value = ILNode_SemAnalysis(tempList, info, tempParent);
		argArray[argNum].node = *tempParent;
		argArray[argNum].parent = tempParent;
		argArray[argNum].modifier = GetParamModForArg(tempList);
		if(CSIsSemValue(value.kind))
		{
			argArray[argNum].type = value.type;
		}
		else
		{
			argArray[argNum].type = ILType_Void;
			CCErrorOnLine(yygetfilename(tempList),
						  yygetlinenum(tempList),
						  "invalid value for argument %u", argNum + 1);
			haveErrors = 1;
		}
	}

	/* Report either an error, or the argument count */
	if(haveErrors)
	{
		ILFree(argArray);
		*args = 0;
		return -1;
	}
	else
	{
		*args = argArray;
		return argCount;
	}
}

void CSEvalFreeArguments(CSEvalArg *args)
{
	if(args)
	{
		ILFree(args);
	}
}

/*
 * Get the "Invoke" method associated with a delegate class.
 */
static ILMethod *GetDelegateInvoke(ILClass *info)
{
	return ILTypeGetDelegateMethod(ILType_FromClass(info));
}

/*
 * Get the type and modifier information associated with
 * an item parameter.  The first parameter is 0.  Returns
 * ILType_Invalid if the parameter index is invalid.
 */
static ILType *GetItemParamType(ILProgramItem *item, ILType *signature,
								int paramNum, ILParameterModifier *paramMod)
{
	int numParams = ILTypeNumParams(signature);
	int firstParam;
	ILType *paramType;
	ILMethod *method;
	ILClass *classInfo;

	/* If we have an "explicit this" method, then we need to
	   adjust for the first parameter, which is always "this" */
	if((ILType_CallConv(signature) & IL_META_CALLCONV_HASTHIS) != 0 &&
	   (ILType_CallConv(signature) & IL_META_CALLCONV_EXPLICITTHIS) != 0 &&
	   numParams > 0)
	{
		firstParam = 2;
	}
	else
	{
		firstParam = 1;
	}

	/* Bail out if the parameter number is out of range */
	if(paramNum > (numParams - firstParam))
	{
		return ILType_Invalid;
	}

	/* Get the parameter type information and return it */
	if((method = ILProgramItemToMethod(item)) != 0)
	{
		*paramMod = ILGenGetParamInfo(method, signature, paramNum + firstParam,
									  &paramType);
	}
	else if((classInfo = ILProgramItemToClass(item)) != 0)
	{
		method = GetDelegateInvoke(classInfo);
		if(method)
		{
			*paramMod = ILGenGetParamInfo
					(method, signature, paramNum + firstParam, &paramType);
		}
		else
		{
			paramType = ILTypeGetParam(signature, paramNum + firstParam);
			*paramMod = ILParamMod_empty;
		}
	}
	else
	{
		paramType = ILTypeGetParam(signature, paramNum + firstParam);
		*paramMod = ILParamMod_empty;
	}
	return paramType;
}

/*
 * Get the type information associated with an item parameter,
 * given that its expansion form is known.
 */
static ILType *GetItemExpandedType(ILProgramItem *item, ILType *signature,
								   int form, int paramNum,
								   ILParameterModifier *paramMod)
{
	ILType *paramType;
	paramType = GetItemParamType(item, signature, paramNum, paramMod);
	if(paramType == ILType_Invalid)
	{
		return ILType_Invalid;
	}
	else if(*paramMod == ILParamMod_params)
	{
		if(form == 2)
		{
			/* We are using the "params" array in its expanded form */
			return paramType;
		}
		else
		{
			/* We are using the "params" array in its array form */
			return ILTypeGetParam(signature, ILTypeNumParams(signature));
		}
	}
	return paramType;
}

/*
 * Get the element type of a single-dimensional array,
 * or return ILType_Invalid if not such as array.
 */
static ILType *GetArrayElemType(ILType *type)
{
	if(type != 0 && ILType_IsComplex(type) &&
	   ILType_Kind(type) == IL_TYPE_COMPLEX_ARRAY)
	{
		return ILType_ElemType(type);
	}
	else
	{
		return ILType_Invalid;
	}
}

/*
 * Get the signature of a program item (method, property, or delegate).
 */
static ILType *GetItemSignature(ILProgramItem *item)
{
	ILMethod *method;
	ILProperty *property;
	ILClass *classInfo;

	/* Determine what kind of item we are dealing with */
	if((method = ILProgramItemToMethod(item)) != 0)
	{
		return ILMethod_Signature(method);
	}
	else if((property = ILProgramItemToProperty(item)) != 0)
	{
		return ILProperty_Signature(property);
	}
	else if((classInfo = ILProgramItemToClass(item)) != 0)
	{
		/* Look for the "Invoke" method within the delegate */
		method = GetDelegateInvoke(classInfo);
		if(method)
		{
			return ILMethod_Signature(method);
		}
	}

	/* If we get here, then we do not know how to obtain the signature */
	return 0;
}

int CSItemIsCandidate(ILGenInfo *info, ILProgramItem *item,
					  CSEvalArg *args, int numArgs)
{
	ILType *signature = GetItemSignature(item);
	int argNum, paramNum;
	ILParameterModifier paramMod;
	ILType *paramType;
	ILType *elemType;
	int matchParams;

	/* If the item does not have a signature, then bail out */
	if(!signature)
	{
		return 0;
	}

	/* Scan through the parameters looking for a match */
	paramNum = 0;
	matchParams = 0;
	for(argNum = 0; argNum < numArgs; ++argNum)
	{
		paramType = GetItemParamType(item, signature, paramNum, &paramMod);
		if(paramType == ILType_Invalid)
		{
			/* Too many arguments were supplied */
			return 0;
		}
		else if(paramMod == ILParamMod_params)
		{
			if(args[argNum].modifier != ILParamMod_empty)
			{
				return 0;
			}
			if(matchParams)
			{
				/* We already started matching as an element type,
				   so we must keep matching as an element type */
				if(!ILCanCoerce(info, args[argNum].type, paramType))
				{
					return 0;
				}
			}
			else
			{
				/* The match can either be as an array, or as an element type */
				elemType = GetArrayElemType(args[argNum].type);
				if(elemType != ILType_Invalid &&
				   ILCanCoerce(info, elemType, paramType))
				{
					/* Matched as an array */
					++paramNum;
				}
				else if(!ILCanCoerce(info, args[argNum].type, paramType))
				{
					/* Could not match as an array or as an element */
					return 0;
				}
				else
				{
					/* Match everything else as an element */
					matchParams = 1;
				}
			}
		}
		else if(paramMod != args[argNum].modifier)
		{
			/* Incorrect modifiers */
			return 0;
		}
		else if(paramMod == ILParamMod_empty)
		{
			/* Match anything that can coerce to the parameter type */
			if(!ILCanCoerce(info, args[argNum].type, paramType))
			{
				return 0;
			}
			++paramNum;
		}
		else
		{
			/* The type match must be exact for "ref" and "out" parameters */
			if(!ILTypeIdentical(args[argNum].type, paramType))
			{
				return 0;
			}
			++paramNum;
		}
	}

	/* Get the next parameter type, which must either be
	   a "params" array, or the end of the parameter list */
	paramType = GetItemParamType(item, signature, paramNum, &paramMod);
	if(paramType == ILType_Invalid)
	{
		/* The candidate was matched in its normal form */
		return 1;
	}
	else if(paramMod == ILParamMod_params)
	{
		/* The candidate was matched in its expanded form */
		return 2;
	}
	else
	{
		/* The candidate did not match */
		return 0;
	}
}

/*
 * Determine which of two items is better than the other one.
 * Returns IL_BETTER_T1 if "item1" is better, or IL_BETTER_T2
 * if "item2" is better, or IL_BETTER_NEITHER if neither is better.
 */
static int BetterItem(ILGenInfo *info,
					  ILProgramItem *item1, int form1,
					  ILProgramItem *item2, int form2,
					  CSEvalArg *args, int numArgs)
{
	ILType *signature1 = GetItemSignature(item1);
	ILType *signature2 = GetItemSignature(item2);
	int argNum;
	int paramNum1;
	int paramNum2;
	ILParameterModifier paramMod1;
	ILParameterModifier paramMod2;
	ILType *type1;
	ILType *type2;
	ILType *atype;
	int better, betterTest;

	/* Compare the argument types */
	paramNum1 = 0;
	paramNum2 = 0;
	better = IL_BETTER_NEITHER;
	for(argNum = 0; argNum < numArgs; ++argNum)
	{
		/* Get the types of the two parameters and the argument */
		type1 = GetItemExpandedType(item1, signature1,
									form1, paramNum1++, &paramMod1);
		type2 = GetItemExpandedType(item2, signature2,
									form2, paramNum2++, &paramMod2);
		atype = args[argNum].type;

		/* Skip the argument if "out" or "ref", because such arguments
		   must always be identical, so neither can be better */
		if(paramMod1 == ILParamMod_out || paramMod1 == ILParamMod_ref ||
		   paramMod2 == ILParamMod_out || paramMod2 == ILParamMod_ref)
		{
			continue;
		}

		/* Determine which is the better coercion */
		betterTest = ILBetterConversion(info, args[argNum].type, type1, type2);
		if(betterTest == IL_BETTER_T1)
		{
			if(better == IL_BETTER_T2)
			{
				/* The first item is better in this parameter,
				   but worse in others */
				better = -1;
			}
			else if(better != -1)
			{
				/* The first item is better so far */
				better = IL_BETTER_T1;
			}
		}
		else if(betterTest == IL_BETTER_T2)
		{
			if(better == IL_BETTER_T1)
			{
				/* The second item is better in this parameter,
				   but worse in others */
				better = -1;
			}
			else if(better != -1)
			{
				/* The second item is better so far */
				better = IL_BETTER_T2;
			}
		}

		/* Back up and revisit "params" parameters within expanded forms */
		if(paramMod1 == ILParamMod_params)
		{
			--paramNum1;
		}
		if(paramMod2 == ILParamMod_params)
		{
			--paramNum2;
		}
	}

	/* Return the result to the caller */
	if(better != -1)
	{
		return better;
	}
	else
	{
		return IL_BETTER_NEITHER;
	}
}

ILProgramItem *CSBestCandidate(ILGenInfo *info, void *group,
						       CSEvalArg *args, int numArgs)
{
	unsigned long itemNum = 1;
	ILProgramItem *bestItem = CSGetGroupMember(group, 0);
	ILProgramItem *testItem;
	int better;
	int form1 = CSGetGroupMemberForm(group, 0);
	int form2;
	int sawBetter = 0;
	while((testItem = CSGetGroupMember(group, itemNum)) != 0)
	{
		form2 = CSGetGroupMemberForm(group, itemNum);
		better = BetterItem(info, bestItem, form1, testItem,
							form2, args, numArgs);
		if(better == IL_BETTER_T1)
		{
			sawBetter = 1;
		}
		else if(better == IL_BETTER_T2)
		{
			bestItem = testItem;
			sawBetter = 1;
		}
		else if(better == IL_BETTER_NEITHER && (form1 == 2 && form2 != 2))
		{
			/* We've found an item that is just as applicable as
			   a previous one.  However, the previous one involved
			   "params" and this one doesn't.  So use this one */
			bestItem = testItem;
		}
		else if(better == IL_BETTER_NEITHER && (form1 != 2 && form2 == 2))
		{
			/* We've found an item that is just as applicable as
			   a previous one.  However, this one involved "params"
			   and the previous one didn't.  So use the previous one */
			sawBetter = 1;
		}
		++itemNum;
	}
	if(sawBetter)
	{
		return bestItem;
	}
	else
	{
		return 0;
	}
}

ILType *CSItemCoerceArgs(ILGenInfo *info, ILProgramItem *item,
						 CSEvalArg *args, int numArgs,
						 ILNode **argListParent)
{
	ILType *signature = GetItemSignature(item);
	int argNum, argNum2, paramNum;
	ILParameterModifier paramMod;
	ILType *paramType;
	ILType *elemType;
	ILNode *argList;
	ILNode *argArray;

	/* Coerce the fixed parameters */
	paramNum = 0;
	for(argNum = 0; argNum < numArgs; ++argNum)
	{
		paramType = GetItemParamType(item, signature, paramNum, &paramMod);
		if(paramMod == ILParamMod_params)
		{
			break;
		}
		else if(paramMod != ILParamMod_ref && paramMod != ILParamMod_out)
		{
			ILCoerce(info, args[argNum].node,
					 args[argNum].parent, args[argNum].type, paramType);
		}
		++paramNum;
	}

	/* Coerce the remaining "params" parameters */
	paramType = GetItemParamType(item, signature, paramNum, &paramMod);
	if(paramType != ILType_Invalid && paramMod == ILParamMod_params)
	{
		/* Determine how to repack the arguments */
		if(argNum < numArgs)
		{
			elemType = GetArrayElemType(args[argNum].type);
			if(elemType != ILType_Invalid &&
			   ILCanCoerce(info, elemType, paramType))
			{
				/* Pass the argument as an array */
				paramType = ILTypeGetParam
					(signature, ILTypeNumParams(signature));
				ILCoerce(info, args[argNum].node,
						 args[argNum].parent, args[argNum].type, paramType);
				argArray = 0;
			}
			else
			{
				/* Coerce the remaining arguments to the element type */
				for(argNum2 = argNum; argNum2 < numArgs; ++argNum2)
				{
					ILCoerce(info, args[argNum2].node,
							 args[argNum2].parent, args[argNum2].type,
							 paramType);
				}

				/* Build an array that contains the remaining arguments */
				argArray = 0;
				for(argNum2 = argNum; argNum2 < numArgs; ++argNum2)
				{
					if(argArray)
					{
						argArray = ILNode_ArgList_create
										(argArray, *(args[argNum2].parent));
					}
					else
					{
						argArray = *(args[argNum2].parent);
					}
				}
				argArray = ILNode_ArgArray_create
								(paramType, numArgs - argNum, argArray);
			}
		}
		else
		{
			/* No extra arguments, so create an empty array */
			argArray = ILNode_ArgArray_create(paramType, 0, 0);
		}

		/* Build a new argument list if necessary */
		if(argArray)
		{
			argList = 0;
			for(argNum2 = 0; argNum2 < argNum; ++argNum2)
			{
				if(argList)
				{
					argList = ILNode_ArgList_create
									(argList, *(args[argNum2].parent));
				}
				else
				{
					argList = *(args[argNum2].parent);
				}
			}
			if(argList)
			{
				argList = ILNode_ArgList_create(argList, argArray);
			}
			else
			{
				argList = argArray;
			}
			*argListParent = argList;
		}
	}

	/* Return the item's return type to the caller */
	return ILTypeGetReturn(signature);
}

const char *CSItemToName(ILProgramItem *item)
{
	ILType *signature = GetItemSignature(item);
	const char *name;
	ILIntString str;
	ILType *type;
	ILParameterModifier paramMod;
	unsigned numParams;
	unsigned param;
	int kind;
	ILMethod *method;
	ILProperty *property;
	ILClass *classInfo;
	ILClass *owner;

	/* Get the name of the item, and find an underlying method */
	if((method = ILProgramItemToMethod(item)) != 0)
	{
		name = ILMethod_Name(method);
		kind = IL_META_MEMBERKIND_METHOD;
		owner = ILMethod_Owner(method);
	}
	else if((property = ILProgramItemToProperty(item)) != 0)
	{
		name = ILProperty_Name(property);
		kind = IL_META_MEMBERKIND_PROPERTY;
		method = ILProperty_Getter(property);
		if(!method)
		{
			method = ILProperty_Setter(property);
		}
		owner = ILProperty_Owner(property);
	}
	else if((classInfo = ILProgramItemToClass(item)) != 0)
	{
		name = ILClass_Name(classInfo);
		kind = 0;
		method = GetDelegateInvoke(classInfo);
		owner = classInfo;
	}
	else
	{
		name = "unknown";
		kind = IL_META_MEMBERKIND_METHOD;
		method = 0;
		owner = 0;
	}

	/* Put "static" or "virtual" on the front if necessary */
	if(method && ILMethod_IsStatic(method))
	{
		str = ILInternString("static ", 7);
	}
	else if(method && ILMethod_IsVirtual(method))
	{
		str = ILInternString("virtual ", 8);
	}
	else
	{
		str = ILInternString("", 0);
	}

	/* Get the type of the class that contains the method */
	type = (owner ? ILType_FromClass(owner) : 0);

	/* The formatting is slightly different for constructors */
	if(!strcmp(name, ".ctor") || !strcmp(name, ".cctor"))
	{
		/* Append the class name to the string */
		str = ILInternAppendedString
				(str, ILInternString((char *)CSTypeToName(type), -1));
	}
	else
	{
		/* Convert the return type into a string */
		str = ILInternAppendedString
				(str, ILInternString((char *)CSTypeToName
										(ILTypeGetReturn(signature)), -1));
		str = ILInternAppendedString(str, ILInternString(" ", 1));

		/* Append the class name to the string */
		str = ILInternAppendedString
				(str, ILInternString((char *)CSTypeToName(type), -1));

		/* Don't add the method name for delegates */
		if(kind != 0)
		{
			/* Append a dot to the string */
			str = ILInternAppendedString(str, ILInternString(".", 1));

			/* Append the method name to the string */
			str = ILInternAppendedString(str, ILInternString((char *)name, -1));
		}
	}

	/* Add the parameter types to the string */
	if(kind == IL_META_MEMBERKIND_PROPERTY)
	{
		str = ILInternAppendedString(str, ILInternString("[", 1));
	}
	else
	{
		str = ILInternAppendedString(str, ILInternString("(", 1));
	}
	numParams = ILTypeNumParams(signature);
	for(param = 1; param <= numParams; ++param)
	{
		if(method && kind != IL_META_MEMBERKIND_PROPERTY)
		{
			paramMod = ILGenGetParamInfo(method, signature, param, &type);
		}
		else
		{
			type = ILTypeGetParam(signature, param);
			paramMod = ILParamMod_empty;
		}
		if(param != 1)
		{
			str = ILInternAppendedString(str, ILInternString(", ", 2));
		}
		if(paramMod == ILParamMod_out)
		{
			str = ILInternAppendedString(str, ILInternString("out ", 4));
		}
		else if(paramMod == ILParamMod_ref)
		{
			str = ILInternAppendedString(str, ILInternString("ref ", 4));
		}
		else if(paramMod == ILParamMod_params)
		{
			str = ILInternAppendedString(str, ILInternString("params ", 7));
		}
		str = ILInternAppendedString
				(str, ILInternString((char *)CSTypeToName(type), -1));
		if(paramMod == ILParamMod_params)
		{
			str = ILInternAppendedString(str, ILInternString("[]", 2));
		}
	}
	if(kind == IL_META_MEMBERKIND_PROPERTY)
	{
		str = ILInternAppendedString(str, ILInternString("]", 1));
	}
	else
	{
		str = ILInternAppendedString(str, ILInternString(")", 1));
	}

	/* Return the final string to the caller */
	return str.string;
}

%}
