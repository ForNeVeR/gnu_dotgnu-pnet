/*
 * cs_types.tc - Semantic analysis for C# type nodes.
 *
 * Copyright (C) 2001  Southern Storm Software, Pty Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

%end %{

int CSHasUnsafeType(ILNode *node)
{
	if(!node)
	{
		return 0;
	}
	else if(yykind(node) == yykindof(ILNode_ArrayType))
	{
		return CSHasUnsafeType(((ILNode_ArrayType *)node)->type);
	}
	else if(yykind(node) == yykindof(ILNode_PtrType))
	{
		return 1;
	}
	else if(yykind(node) == yykindof(ILNode_MemberAccess))
	{
		return CSHasUnsafeType(((ILNode_MemberAccess *)node)->expr1);
	}
	else if(yykind(node) == yykindof(ILNode_List))
	{
		ILNode_ListIter iter;
		ILNode *child;
		ILNode_ListIter_Init(&iter, node);
		while((child = ILNode_ListIter_Next(&iter)) != 0)
		{
			if(yykind(child) == yykindof(ILNode_FormalParameter))
			{
				if(CSHasUnsafeType(((ILNode_FormalParameter *)node)->type))
				{
					return 1;
				}
			}
		}
		return 0;
	}
	else
	{
		return 0;
	}
}

%}

/*
 * Perform semantic analysis for array types.  Array types are
 * constructed by the C# grammar with the rank specifiers in the
 * reverse of the true order, which this function fixes up.
 */
ILNode_SemAnalysis(ILNode_ArrayType)
{
	CSSemValue value;
	ILNode *elemType;
	ILNode **elemTypeParent;
	ILType *arrayType;
	ILType *type;

	/* Find the element type at the end of the rank specifiers */
	elemType = node->type;
	elemTypeParent = &(node->type);
	while(yykind(elemType) == yykindof(ILNode_ArrayType))
	{
		elemTypeParent = &(((ILNode_ArrayType *)elemType)->type);
		elemType = ((ILNode_ArrayType *)elemType)->type;
	}

	/* Perform semantic analysis on the element type */
	type = CSSemTypeLiteral(elemType, info, elemTypeParent);

	/* Create the array type from the outermost rank inwards */
	arrayType = ILTypeCreateArray(info->context, node->numDimensions, type);
	if(!arrayType)
	{
		CCOutOfMemory();
	}
	elemType = node->type;
	while(yykind(elemType) == yykindof(ILNode_ArrayType))
	{
		arrayType = ILTypeCreateArray
			(info->context, ((ILNode_ArrayType *)elemType)->numDimensions,
			 arrayType);
		if(!arrayType)
		{
			CCOutOfMemory();
		}
		elemType = ((ILNode_ArrayType *)elemType)->type;
	}

	/* Return the final array type */
	CSSemSetType(value, arrayType);
	return value;
}

/*
 * Perform semantic analysis for pointer types.
 */
ILNode_SemAnalysis(ILNode_PtrType)
{
	CSSemValue value;

	/* Perform semantic analysis on the element type */
	value = ILNode_SemAnalysis(node->type, info, &(node->type));
	if(!CSSemIsType(value))
	{
		CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "invalid pointer element type");
		CSSemSetType(value, ILType_Int32);
	}

	/* Create the pointer type */
	CSSemSetType(value, ILTypeCreateRef(info->context, IL_TYPE_COMPLEX_PTR,
								 		CSSemGetType(value)));
	if(!(CSSemGetType(value)))
	{
		CCOutOfMemory();
	}
	return value;
}

/*
 * Perform semantic analysis for primitive types.
 */
ILNode_SemAnalysis(ILNode_PrimitiveType)
{
	CSSemValue value;
	CSSemSetType(value, ILType_FromElement(node->elementType));
	return value;
}

/*
 * Perform semantic analysis for the "object" type.
 */
ILNode_SemAnalysis(ILNode_SystemType)
{
	CSSemValue value;
	CSSemSetType(value, ILFindSystemType(info, node->className));
	if(!(CSSemGetType(value)))
	{
		value=ILNode_SemAnalysis(
				ILQualIdentTwo("System",node->className),info,parent);
	}
	if(!(CSSemGetType(value)))
	{
		CCOutOfMemory();
	}
	return value;
}

%{

/*
 * Get the number of suffixes in a local variable type suffix list.
 */
static ILUInt32 SuffixListLen(ILNode *list)
{
	ILNode_ListIter iter;
	ILUInt32 count = 0;
	ILNode_ListIter_Init(&iter, list);
	while(ILNode_ListIter_Next(&iter))
	{
		++count;
	}
	return count;
}

/*
 * Get a particular suffix value from a local variable type suffix list.
 */
static ILUInt32 SuffixListValue(ILNode *list, ILUInt32 elemNum)
{
	ILNode_ListIter iter;
	ILNode *child;
	ILUInt32 count = 0;
	ILNode_ListIter_Init(&iter, list);
	while((child = ILNode_ListIter_Next(&iter)) != 0)
	{
		if(count == elemNum)
		{
			return ((ILNode_TypeSuffix *)child)->count;
		}
		++count;
	}
	return 0;
}

%}

/*
 * Perform semantic analysis for local variable types,
 * which have to split the main type from the suffixes.
 * Without the split, there are reduce/reduce conflicts
 * in the C# grammar.
 */
ILNode_SemAnalysis(ILNode_LocalVariableType)
{
	CSSemValue value;
	ILUInt32 len;
	ILUInt32 posn;
	ILUInt32 count;
	ILUInt32 numRanks;
	ILUInt32 tempRank;
	ILType *type;

	/* Perform semantic analysis on the element type */
	type = CSSemTypeVoid(node->type, info, &(node->type));

	/* If the element type is "void", then the first suffix
	   must indicate a pointer type */
	len = SuffixListLen(node->suffixes);
	if(type == ILType_Void)
	{
		if(!len || SuffixListValue(node->suffixes, 0) != 0)
		{
			CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "`void' not permitted as a local variable type");
			CSSemSetType(value, ILType_Int32);
			return value;
		}
	}

	/* Add the suffixes to the type */
	posn = 0;
	while(posn < len)
	{
		count = SuffixListValue(node->suffixes, posn);
		if(count != 0 && (posn + 1) == len)
		{
			/* Special case: single rank specifier */
			type = ILTypeCreateArray(info->context, count, type);
			if(!type)
			{
				CCOutOfMemory();
			}
			++posn;
		}
		else if(count != 0)
		{
			/* Construct an array type from a group of rank specifiers */
			numRanks = 1;
			while((posn + numRanks) < len &&
		       (count = SuffixListValue(node->suffixes, posn + numRanks)) != 0)
			{
				++numRanks;
			}
			tempRank = numRanks;
			while(tempRank > 0)
			{
				--tempRank;
				count = SuffixListValue(node->suffixes, posn + tempRank);
				type = ILTypeCreateArray(info->context, count, type);
				if(!type)
				{
					CCOutOfMemory();
				}
			}
			posn += numRanks;
		}
		else
		{
			/* Construct a pointer type */
			type = ILTypeCreateRef(info->context, IL_TYPE_COMPLEX_PTR, type);
			if(!type)
			{
				CCOutOfMemory();
			}
			++posn;
		}
	}
	CSSemSetType(value, type);
	return value;
}

/*
 * Perform semantic analysis for type suffixes.
 */
ILNode_SemAnalysis(ILNode_TypeSuffix)
{
	/* This is never actually called, so do nothing */
	return CSSemValueDefault;
}


/*
 * Perform semantic analysis for generic type actual parameters.
 */
ILNode_SemAnalysis(ILNode_TypeActuals)
{
	/* TODO */
	return CSSemValueDefault;
}

/*
 *  Perform semantic analysis  for a generic type or method reference
 *  with a bias to returning Type objects.
 */
ILNode_SemAnalysisType(ILNode_GenericReference)
{
	CSSemValue value;
	const char *name;
	int savedState=info->inSemType;
	char buffer[261];

	/* Get the type name with the generic arity appended */
	sprintf(buffer, "%s`%i",
			ILQualIdentName(node->identifier, 0),
			node->numArgs);
	name = buffer;

	info->inSemType = -1;

	/* Perform semantic analysis on the main part of the type */
	if(node->left)
	{
		CSSemValue value2;

		/* Get the semantic value for the left part of the identifier */
		value2 = ILNode_SemAnalysisType(node->left, info, &(node->left));

		/* Resolve the member */
		value = CSResolveMemberName(info, (ILNode *)node, value2, name, 1);
	}
	else
	{
		value = CSResolveSimpleNameQuiet(info, (ILNode *)node, name, 1);
	}
	info->inSemType = savedState;
	
	if(CSSemGetKind(value) == CS_SEMKIND_TYPE)
	{
		ILType *withType;
		/* TODO: perform the analysis for the TypeActuals. */

		/* Build the "with" type and return it */
		withType = ILTypeCreateWith(info->context, CSSemGetType(value));
		if(!withType)
		{
			CCOutOfMemory();
		}
		CSSemWithType(node->typeArguments, info, &(node->typeArguments),
					  withType);
		CSSemSetType(value, withType);

		/* Convert the result into an l-value or r-value and return it */
		return SemToLRValue((ILNode *)node, info, parent, value,
							name, node->left, &value);
	}
	else if(CSSemGetKind(value) == CS_SEMKIND_TYPE_NODE)
	{
		/* TODO: perform the analysis for the TypeActuals. */

		/* Convert the result into an l-value or r-value and return it */
		return SemToLRValue((ILNode *)node, info, parent, value,
							name, node->left, &value);

	}
	return CSSemValueDefault;
}

/*
 * Perform semantic analysis for a generic type or method reference.
 */
ILNode_SemAnalysis(ILNode_GenericReference)
{
	CSSemValue value;
	ILClass *classInfo;
	ILUInt32 numFormals;
	ILType *withType;
	const char *name;
	char buffer[261];

	/* Get the type name with the generic arity appended */
	sprintf(buffer, "%s`%i",
			ILQualIdentName(node->identifier, 0),
			node->numArgs);
	name = buffer;

	if(node->left)
	{
		CSSemValue value2;

		/* Get the semantic value for the left part of the identifier */
		value2 = ILNode_SemAnalysisType(node->left, info, &(node->left));

		/* Resolve the member */
		value = CSResolveMemberName(info, (ILNode *)node, value2, name, 1);
	}
	else
	{
		value = CSResolveSimpleNameQuiet(info, (ILNode *)node, name, 1);
	}
	if(!CSSemIsType(value))
	{
		CCErrorOnLine(yygetfilename(node->identifier), yygetlinenum(node->identifier),
					  "type name expected in generic type reference");
		return value;
	}

	/* Find the number of generic parameters that we expect */
	classInfo = ILClassResolve(ILTypeToClass(info, CSSemGetType(value)));
	numFormals = ILGenericParGetNumParams(ILToProgramItem(classInfo));

	/* Check the counts for consistency */
	/* TODO: This check is not correct for nested types. */
	if(numFormals != node->numArgs)
	{
		CCErrorOnLine(yygetfilename(node), yygetlinenum(node),
					  "incorrect number of generic parameters supplied to "
					  "`%s'; was %d but should be %d",
					  CSTypeToName(CSSemGetType(value)),
					  (int)node->numArgs, (int)numFormals);
	}

	/* Build the "with" type and return it */
	withType = ILTypeCreateWith(info->context, CSSemGetType(value));
	if(!withType)
	{
		CCOutOfMemory();
	}
	CSSemWithType(node->typeArguments, info, &(node->typeArguments), withType);
	CSSemSetType(value, withType);
	return value;
}

%end %{


%}
