<html>
<head>
<title>Using Portable.NET's C Compiler</title>
</head>
<body bgcolor="#ffffff">
<h1>Using Portable.NET's C Compiler</h1>

Rhys Weatherley, <a href="mailto:rweather@southern-storm.com.au">rweather@southern-storm.com.au</a>.<br>
Last Modified: $Date: 2004/02/28 07:20:49 $<p>

Copyright &copy; 2002 Southern Storm Software, Pty Ltd.<br>
Permission to distribute copies of this work under the terms of the
GNU Free Documentation License is hereby granted.<p>

<h2>1. Introduction</h2>

This document provides an overview of using Portable.NET's compiler,
"cscc", to build C applications and libraries to run within a
Common Language Infrastructure (CLI) environment.<p>

We assume that the user has already installed all of the Portable.NET
components, including the compiler and C system library.<p>

<blockquote>
<b>Note: This is preliminary documentation.  Not all listed features
may be implemented yet.</b>
</blockquote>

<h2>2. Hello World</h2>

The traditional "Hello World" program is as follows:<p>

<blockquote><pre>#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    printf("Hello World!\n");
    return 0;
}</pre></blockquote>

To compile and run this with Portable.NET, use the following commands:<p>

<blockquote><pre>$ cscc -o hello.exe hello.c
$ ilrun hello.exe
Hello World!
$ _</pre></blockquote>

As can be seen, this is very similar to using a traditional C compiler.
Just use the "<code>cscc</code>" command instead of "<code>gcc</code>"
or "<code>cc</code>".<p>

Now let's try something a little more complicated:<p>

<blockquote><pre>#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    printf("sizeof(int) = %u\n", sizeof(int));
    printf("sizeof(void *) = %u\n", sizeof(void *));
    return 0;
}</pre></blockquote>

Compiling and running this gives the following result:<p>

<blockquote><pre>$ cscc -o sizes.exe sizes.c
$ ilrun sizes.exe
sizeof(int) = 4
sizeof(void *) = 8
$ _</pre></blockquote>

If you were running this on a 32-bit operating system, this output
might seem a little puzzling.  Normally, "<code>sizeof(void *)</code>"
will be 8 bytes on a 64-bit operating system, not a 32-bit one.
Why isn't the value 4 instead?<p>

The output of the C compiler is designed to run on a Common
Language Runtime (CLR) implementation, not on a native operating
system.  When we compile the program, the compiler does not
know what kind of CLR will be used to execute it.<p>

The compiler builds the program as though it will be running on
a 64-bit CLR.  If the program is subsequently executed on a 32-bit
CLR, the program will function correctly, and pretend that it
is operating in a 64-bit environment.  This way, the compiler does
not need to know the actual characteristics of the CLR.<p>

Sometimes you may want to force the compiler to output 32-bit
code, or code that is tuned for the specifics of a particular
platform.  If you do this, then the program will not execute
on CLR's that have different characteristics.  i.e. it will no
longer be portable.<p>

The following two examples demonstrate how to build 32-bit programs,
and programs that use the native type layout policy:<p>

<blockquote><pre>$ cscc -m32bit-only -o sizes.exe sizes.c
$ cscc -mnative-types -o sizes.exe sizes.c</pre></blockquote>

If you want your program to be portable to many operating systems,
you should not use these options when compiling.<p>

<h2>3. Language features</h3>

As much as possible, we try to present a standard ANSI C interface
to the programmer.  This section describes some specific implementation
decisions and extensions that programmers may need to be aware of.<p>

<h3>3.1. Primitive types</h3>

The following primitive types are provided by the C compiler:<p>

<table border="1">
<tr><td>Type</td><td>Size</td><td>Description</td></tr>
<tr><td><code>void</code></td>
	<td>1 <sup>1</sup></td>
	<td>Void type</td></tr>
<tr><td><code>_Bool</code></td>
	<td>1</td>
	<td>8-bit boolean value (C# "<code>bool</code>")</td></tr>
<tr><td><code>char</code></td>
	<td>1</td>
	<td>Signed 8-bit integer</td></tr>
<tr><td><code>unsigned char</code></td>
	<td>1</td>
	<td>Unsigned 8-bit integer</td></tr>
<tr><td><code>short</code></td>
	<td>2</td>
	<td>Signed 16-bit integer</td></tr>
<tr><td><code>unsigned short</code></td>
	<td>2</td>
	<td>Unsigned 16-bit</td></tr>
<tr><td><code>__wchar__</code></td>
	<td>2</td>
	<td>16-bit wide character value (C# "<code>char</code>")</td></tr>
<tr><td><code>int</code></td>
	<td>4</td>
	<td>Signed 32-bit integer</td></tr>
<tr><td><code>unsigned int</code></td>
	<td>4</td>
	<td>Unsigned 32-bit integer</td></tr>
<tr><td><code>long</code></td>
	<td>4/8 <sup>2</sup></td>
	<td>Signed 32-bit or 64-bit integer</td></tr>
<tr><td><code>unsigned long</code></td>
	<td>4/8 <sup>2</sup></td>
	<td>Unsigned 32-bit or 64-bit integer</td></tr>
<tr><td><code>long long</code></td>
	<td>8</td>
	<td>Signed 64-bit integer</td></tr>
<tr><td><code>unsigned long long</code></td>
	<td>8</td>
	<td>Unsigned 64-bit integer</td></tr>
<tr><td><code>__native__ int</code></td>
	<td>? <sup>3</sup></td>
	<td>Signed native integer</td></tr>
<tr><td><code>unsigned __native__ int</code></td>
	<td>? <sup>3</sup></td>
	<td>Unsigned native integer</td></tr>
<tr><td><code>float</code></td>
	<td>4</td>
	<td>32-bit IEEE 754 floating-point</td></tr>
<tr><td><code>double</code></td>
	<td>8</td>
	<td>64-bit IEEE 754 floating-point</td></tr>
<tr><td><code>long double</code></td>
	<td>8</td>
	<td>Same as "<code>double</code>"</td></tr>
<tr><td><code>type *</code></td>
	<td>4/8 <sup>2</sup></td>
	<td>Pointer to "<code>type</code>"</td></tr>
</table><p>

<font size="-1">Note 1.  The size of "<code>void</code>" is 1, to be
consistent with gcc.<br>
Note 2.  These types are 4 bytes in size if "<code>-m32bit-only</code>"
was specified at compile time, and 8 bytes in size otherwise.<br>
Note 3.  The size of these types is determined at runtime, based on
the corresponding types in the runtime engine.</font>

<h3>3.2. Native structures</h3>

By default, the compiler lays out "<code>struct</code>" and
"<code>union</code>" types to simulate the behaviour of a 64-bit
operating system.  The "<code>-m32bit-only</code>" option can be
used to specify 32-bit layout instead.<p>

However, sometimes you need to access features of the native operating
system, even if writing a portable 64-bit application.  When you do,
you need to guarantee that "<code>struct</code>" and "<code>union</code>"
types exactly match what the operating system expects.<p>

Native structures can be defined by adding the "<code>__native__</code>"
keyword to their declaration:<p>

<blockquote><pre>struct __native__ A
{
    int item;
    struct A *next;
};</pre></blockquote>

In this structure, the "<code>next</code>" field is guaranteed to
occupy only enough space for a native pointer, and to be aligned on
an appropriate native word boundary.  If the "<code>__native__</code>"
keyword was not present, the "<code>next</code>" field would always
occupy a full 8 bytes, even if the CLR was only using 4-byte pointers
behind the scenes.<p>

If you use the "<code>-mnative-types</code>" command-line option, then
all structures will be laid out using the native policy, and there is
no need to use the "<code>__native__</code>" keyword.  But the resulting
program will only work on the system for which it was compiled.
It probably won't work on any other system.<p>

Unions may also have the "<code>__native__</code>" keyword:<p>

<blockquote><pre>union __native__ A
{
    int x;
    void *y;
};</pre></blockquote>

<h3>3.3. Restrictions on <code>setjmp</code> and <code>alloca</code></h3>

Because of the way the C compiler builds programs, the "<code>setjmp</code>"
and "<code>alloca</code>" constructs must be used carefully.  In particular,
they must be used at the "statement level" of an expression.<p>

The following code is correct:<p>

<blockquote><pre>jmp_buf env;

if(setjmp(env) != 0)
{
    /* longjmp occurred */
}</pre></blockquote>

But the following code will give an error when compiled:

<blockquote><pre>jmp_buf env;

if((1 + setjmp(env)) != 1)
{
    /* longjmp occurred */
}</pre></blockquote>

This is because the "<code>setjmp</code>" does not occur at the outermost
level of the expression (the value 1 is stored on the stack temporarily,
pending the addition operation).  The "<code>alloca</code>" construct must be
used in a similar manner.<p>

If you get such an error, you can split your code up a little bit.  For
example:

<blockquote><pre>jmp_buf env;
int result;

result = setjmp(env);
if((1 + result) != 1)
{
    /* longjmp occurred */
}</pre></blockquote>

The variable that you assign to will normally need to be a local
variable, global variable, or parameter.  Other kinds of variables
(e.g. array elements) will change the expression level and so cannot
be used.<p>

This restriction is imposed by the way that CLR's implement
"<code>setjmp</code>" and "<code>alloca</code>".  Most C programmers
already use these constructs at the statement level of an expression,
so this restriction is not expected to affect much existing code.<p>

<h3>3.4. Importing PInvoke functions</h3>

Native functions may be imported via PInvoke using function attributes.
For example:<p>

<blockquote><pre>extern int getpid(void) __attribute__((pinvoke("libc.so.6"), cdecl));</pre></blockquote><p>

The following attributes may be present:<p>

<dl>
<dt><code>pinvoke(<i>lib</i>)</code></dt>
<dd>Specify that the function is imported via PInvoke from the specified
	native library.</dd>

<dt><code>name(<i>str</i>)</code></dt>
<dd>Specify the raw name of the function in the DLL, if it is different
	from the name of the function.</dd>

<dt><code>ansi</code>, <code>unicode</code>, <code>auto</code></dt>
<dd>Specify the string marshalling conventions.</dd>

<dt><code>winapi</code>, <code>cdecl</code>, <code>stdcall</code>,
    <code>thiscall</code>, <code>fastcall</code></dt>
<dd>Specify the calling conventions.</dd>

<dt><code>nomangle</code>, <code>preservesig</code>, <code>lasterr</code></dt>
<dd>Other flags, corresponding to <code>ExactSpelling</code>,
    <code>PreserveSig</code>, and <code>SetLastError</code> in
	<code>DllImportAttribute</code>.</dd>
</dl>

All of these attributes can also be specified with leading and trailing
underscores; e.g. "<code>__pinvoke__</code>".<p>

<h3>3.5. Calling C# code from C</h3>

TODO: this section refers to functionality that isn't completely
implemented yet.<p>

Any C# type can be imported into C using the syntax
"<code>__csharp__ (<i>type</i>)</code>", where "<code><i>type</i></code>"
is any legal C# type name, include object types, value types, managed
arrays, etc.  The "<code>__csharp__</code>" wrapper is necessary to
avoid ambiguities in the compiler's parser.<p>

The "<code>__csharp__</code>" keyword can be combined with the
"<code>::</code>" operator to call methods in the C# code:<p>

<blockquote><pre>typedef __csharp__(System.Console) Console;
typedef __csharp__(System.String) String;

int main()
{
    (void)Console::WriteLine((String)"Hello World");
    return 0;
}</pre></blockquote><p>

The "<code>(void)</code>" is necessary to avoid ambiguities between
types used in local variable declarations and types used in method
invocation expressions.  If the method is used as a sub-expression,
the cast is not necessary.  For example:

<blockquote><pre>typedef __csharp__(System.Environment) Environment;

int ticks = Environment::get_TickCount();</pre></blockquote><p>

This example also demonstrates how C# properties are accessed from C:
you must call the underlying "<code>get</code>" or "<code>set</code>"
method.<p>

You can supply the assembly name explicitly using the syntax
"<code>__csharp__ ([<i>assembly</i>]<i>type</i>)</code>".  For example:<p>

<blockquote><pre>typedef __csharp__([System.Xml]System.Xml.XmlDocument) XmlDocument;</pre></blockquote><p>

The assembly qualifier is normally needed for types that are
not declared within "<code>mscorlib.dll</code>".<p>

If the method is an instance or virtual method, then the object
is supplied as the first parameter:<p>

<blockquote><pre>typedef __csharp__(System.Object) Object;

Object o = ...;
int hash = Object::GetHashCode(o);</pre></blockquote><p>

When the C compiler resolves methods, it will first check for an
instance method.  If none is found, it will check for a static
method.<p>

Another way to call C# code from C is to tag the C# class with
"<code>OpenSystem.C.GlobalScopeAttribute</code>":

<blockquote><pre>using OpenSystem.C;

[GlobalScope]
public class MyClass
{
    public static void cs_func()
    {
        ...
    }

}</pre></blockquote><p>

The "<code>cs_func</code>" method will be visible to the C code as a
regular C function.<p>

The value zero (0) can be used in any context where a C# reference
value is expected to represent the C# "<code>null</code>" value.
For example, the following sets an object to null:<p>

<blockquote><pre>typedef __csharp__ (System.Object) Object;

Object obj = 0;</pre></blockquote><p>

And the following two examples can be used to check to see if
"<code>obj</code>" is non-null later in the code:<p>

<blockquote><pre>if(obj != 0)          if(obj)
{                     {
    ...                  ...
}                     }</pre></blockquote><p>

Coercions or casts that are allowed between two C# types can also
be performed between the corresponding C types, including boxing and
unboxing, but not user-defined conversions.<p>

User-defined C# conversions and arithmetic operators are not supported
directly.  However, they can be accessed by explicitly calling the
"<code>op</code>" methods.  For example, to add two
"<code>Decimal</code>" values:<p>

<blockquote><pre>typedef __csharp__ (System.Decimal) Decimal;

Decimal a, b, c;
...
a = Decimal::op_Addition(b, c);</pre></blockquote><p>

The following table lists all of the C operators and the corresponding
"<code>op</code>" methods:<p>

<blockquote><table border="1">
<tr><td>Operator</td><td>Method Name</td></tr>
<tr><td>+</td><td><code>op_Addition</code>, <code>op_UnaryPlus</code></td></tr>
<tr><td>-</td><td><code>op_Subtraction</code>, <code>op_UnaryNegation</code></td></tr>
<tr><td>*</td><td><code>op_Multiply</code></td></tr>
<tr><td>/</td><td><code>op_Division</code></td></tr>
<tr><td>%</td><td><code>op_Modulus</code></td></tr>
<tr><td>&amp;</td><td><code>op_BitwiseAnd</code></td></tr>
<tr><td>|</td><td><code>op_BitwiseOr</code></td></tr>
<tr><td>^</td><td><code>op_BitwiseXor</code></td></tr>
<tr><td>&lt;&lt;</td><td><code>op_LeftShift</code></td></tr>
<tr><td>&gt;&gt;</td><td><code>op_RightShift</code></td></tr>
<tr><td>==</td><td><code>op_Equality</code></td></tr>
<tr><td>!=</td><td><code>op_Inequality</code></td></tr>
<tr><td>&lt;</td><td><code>op_LessThan</code></td></tr>
<tr><td>&gt;</td><td><code>op_GreaterThan</code></td></tr>
<tr><td>&lt;=</td><td><code>op_LessThanOrEqual</code></td></tr>
<tr><td>&gt;=</td><td><code>op_GreaterThanOrEqual</code></td></tr>
<tr><td>!</td><td><code>op_LogicalNot</code></td></tr>
<tr><td>~</td><td><code>op_OnesComplement</code></td></tr>
<tr><td>++</td><td><code>op_Increment</code></td></tr>
<tr><td>--</td><td><code>op_Decrement</code></td></tr>
<tr><td>Coerce</td><td><code>op_Implicit</code></td></tr>
<tr><td>Cast</td><td><code>op_Explicit</code></td></tr>
<tr><td>Check True</td><td><code>op_True</code></td></tr>
<tr><td>Check False</td><td><code>op_False</code></td></tr>
</table></blockquote><p>

<h3>3.6. Calling C code from C#</h3>

If the C function is in a library assembly, then you can access it as
though it was a regular C# method.  For example, the following program
will sleep for five seconds:

<blockquote><pre>public class Sleeper
{
    public static void Main()
    {
        libc.sleep(5);
    }
}</pre></blockquote><p>

It is compiled as follows:<p>

<blockquote><pre>$ cscc -o sleep.exe sleep.cs -llibc64</pre></blockquote><p>

To call C code from C# in the same program, you must declare the the
C function in your C# application as follows:<p>

<blockquote><pre>__module
{
    extern public static void c_func();

}</pre></blockquote><p>

where "<code>c_func</code>" is a function declared in your C code.
Use "<code>__module.c_func()</code>" to call the function from C#.
The "<code>__module</code>" keyword is needed because the name of the
type containing the C function is unknown until the program is linked.<p>

It is recommended that you place your C and C# code in separate assemblies
so that you don't need to use the "<code>__module</code>" keyword.  That
way, you can use any C# compiler you wish to build the C# parts of your
application (you will still need to use Portable.NET's C compiler for
the C parts of course).<p>

<h3>3.7. Weak and strong aliases</h3>

TODO

</body>
</html>
