<html>
<head>
<title>Internalcall methods for pnetlib</title>
</head>
<body bgcolor="#ffffff">
<h1>Internalcall methods for pnetlib</h1>

Rhys Weatherley, <a href="mailto:rweather@southern-storm.com.au">rweather@southern-storm.com.au</a>.<br>
Last Modified: $Date: 2001/12/07 05:08:39 $<p>

Copyright &copy; 2001 Southern Storm Software, Pty Ltd.<br>
Permission to distribute unmodified copies of this work is hereby granted.<p>

<h2>1. Introduction</h2>

This document describes the <code>internalcall</code> methods that
pnetlib assumes are provided by any Common Language Runtime (CLR)
implementation that uses it.
<a href="http://www.southern-storm.com.au/portable_net.html">Portable.NET</a>
is one such implementation.<p>

We take a slightly different approach to native methods than Microsoft
and <a href="http://www.go-mono.com/">Mono</a>.  Their base class libraries
contain a lot of platform-specific PInvoke's and other assumptions.
They both assume that a new version of the base class libraries must be
compiled for each individual platform.<p>

Intel's <a href="http://ocl.sourceforge.net/">OCL</a> library uses a
different approach.  It abstracts the details of the engine into an
interface called <code>IVirtualExecutionSystem</code>, and the details
of the operating system into an interface called <code>IOperatingSystem</code>.
All methods that need these services are diverted to instances of these
interfaces which provide the underlying implementation.<p>

There are two drawbacks to Intel's approach.  The first is that it still
requires a different library for each platform.  The second is that these
two interfaces will eventually contain hundreds of methods, all virtual.
This will create a huge maintainence burden, and will impact overall
performance.<p>

We try to isolate things a bit better, while maintaining an acceptable
level of performance.  The overriding design goal is: there is only one
base class library.  The C# parts of our library are the same on every
platform.  Platform-specific functionality is provided through native
methods that the runtime engine provides in the form of
<code>internalcall</code> methods.<p>

The methods fall into two categories: <code>System</code> and
<code>Platform</code>.  The methods in <code>System</code> provide
facilities that are platform-independent but need to be implemented in
the runtime engine.  e.g. reflection must be implemented in C because
there are no IL bytecodes for implementing it.  The <code>Decimal</code>
operators are implemented in C for speed, but they are otherwise
platform-independent.<p>

The methods in <code>Platform</code> are where the platform-specific
bits are plugged in.  These methods may behave very differently on
different platforms, and under different security policies.<p>

All <code>System</code> methods should be implemented by all runtime engines.
Some <code>Platform</code> natives may be stubbed out if the platform or
security policy does not allow the operation to complete.<p>

All classes defined in <code>Platform</code> must be declared
"<code>internal</code>" so that programs can only get access through
the public interfaces in System, and so that the <code>Platform</code>
namespace does not pollute the global namespace of programs
that use the library.<p>

<h2>Cross reference</h2>

<ul>
<li><a href="#System">System</a></li>
<ul>
<li><a href="#System_ArgIterator">System.ArgIterator</a></li>
	<ul>
		<li><a href="#System_ArgIterator_ctor">constructor</a></li>
		<li><a href="#System_ArgIterator_GetNextArg">GetNextArg</a></li>
		<li><a href="#System_ArgIterator_GetNextArgType">GetNextArgType</a></li>
		<li><a href="#System_ArgIterator_GetRemainingCount">GetRemainingCount</a></li>
	</ul>
<li><a href="#System_Array">System.Array</a></li>
	<ul>
		<li><a href="#System_Array_Clear">Clear</a></li>
		<li><a href="#System_Array_Initialize">Initialize</a></li>
		<li><a href="#System_Array_Copy">Copy</a></li>
		<li><a href="#System_Array_CreateArray">CreateArray</a></li>
		<li><a href="#System_Array_GetLength">GetLength</a></li>
		<li><a href="#System_Array_GetLowerBound">GetLowerBound</a></li>
		<li><a href="#System_Array_GetUpperBound">GetUpperBound</a></li>
		<li><a href="#System_Array_GetRank">GetRank</a></li>
		<li><a href="#System_Array_Get">Get</a></li>
		<li><a href="#System_Array_Set">Set</a></li>
	</ul>
<li><a href="#System_Decimal">System.Decimal</a></li>
	<ul>
		<li><a href="#System_Decimal_ctor">constructor</a></li>
		<li><a href="#System_Decimal_ToSingle">ToSingle</a></li>
		<li><a href="#System_Decimal_ToDouble">ToDouble</a></li>
		<li><a href="#System_Decimal_Add">Add</a></li>
		<li><a href="#System_Decimal_Compare">Compare</a></li>
		<li><a href="#System_Decimal_Divide">Divide</a></li>
		<li><a href="#System_Decimal_Floor">Floor</a></li>
		<li><a href="#System_Decimal_Remainder">Remainder</a></li>
		<li><a href="#System_Decimal_Multiply">Multiply</a></li>
		<li><a href="#System_Decimal_Negate">Negate</a></li>
		<li><a href="#System_Decimal_Round">Round</a></li>
		<li><a href="#System_Decimal_Subtract">Subtract</a></li>
		<li><a href="#System_Decimal_Truncate">Truncate</a></li>
	</ul>
<li><a href="#System_Delegate">System.Delegate</a></li>
	<ul>
		<li><a href="#System_Delegate_CreateBlankDelegate">CreateBlankDelegate</a></li>
	</ul>
<li><a href="#System_Double">System.Double</a></li>
	<ul>
		<li><a href="#System_Double_IsNaN">IsNaN</a></li>
		<li><a href="#System_Double_TestInfinity">TestInfinity</a></li>
	</ul>
<li><a href="#System_Enum">System.Enum</a></li>
	<ul>
		<li><a href="#System_Enum_GetEnumValue">GetEnumValue</a></li>
		<li><a href="#System_Enum_GetEnumName">GetEnumName</a></li>
		<li><a href="#System_Enum_IsEnumValue">IsEnumValue</a></li>
		<li><a href="#System_Enum_GetEnumValueFromName">GetEnumValueFromName</a></li>
		<li><a href="#System_Enum_EnumValueOr">EnumValueOr</a></li>
		<li><a href="#System_Enum_EnumIntToObject">EnumIntToObject</a></li>
		<li><a href="#System_Enum_EnumLongToObject">EnumLongToObject</a></li>
		<li><a href="#System_Enum_FormatEnumWithFlags">FormatEnumWithFlags</a></li>
	</ul>
<li><a href="#System_GC">System.GC</a></li>
	<ul>
		<li><a href="#System_GC_KeepAlive">KeepAlive</a></li>
		<li><a href="#System_GC_ReRegisterForFinalize">ReRegisterForFinalize</a></li>
		<li><a href="#System_GC_SuppressFinalize">SuppressFinalize</a></li>
		<li><a href="#System_GC_WaitForPendingFinalizers">WaitForPendingFinalizers</a></li>
	</ul>
<li><a href="#System_Guid">System.Guid</a></li>
	<ul>
		<li><a href="#System_Guid_NewGuid">NewGuid</a></li>
	</ul>
<li><a href="#System_Math">System.Math</a></li>
	<ul>
		<li><a href="#System_Math_Acos">Acos</a></li>
		<li><a href="#System_Math_Asin">Asin</a></li>
		<li><a href="#System_Math_Atan">Atan</a></li>
		<li><a href="#System_Math_Atan2">Atan2</a></li>
		<li><a href="#System_Math_Cos">Cos</a></li>
		<li><a href="#System_Math_Cosh">Cosh</a></li>
		<li><a href="#System_Math_Sin">Sin</a></li>
		<li><a href="#System_Math_Sinh">Sinh</a></li>
		<li><a href="#System_Math_Tan">Tan</a></li>
		<li><a href="#System_Math_Tanh">Tanh</a></li>
		<li><a href="#System_Math_Ceiling">Ceiling</a></li>
		<li><a href="#System_Math_Floor">Floor</a></li>
		<li><a href="#System_Math_Exp">Exp</a></li>
		<li><a href="#System_Math_Pow">Pow</a></li>
		<li><a href="#System_Math_IEEERemainder">IEEERemainder</a></li>
		<li><a href="#System_Math_Log">Log</a></li>
		<li><a href="#System_Math_Log10">Log10</a></li>
		<li><a href="#System_Math_Round">Round</a></li>
		<li><a href="#System_Math_RoundDouble">RoundDouble</a></li>
		<li><a href="#System_Math_Sqrt">Sqrt</a></li>
	</ul>
<li><a href="#System_Object">System.Object</a></li>
	<ul>
		<li><a href="#System_Object_GetType">GetType</a></li>
		<li><a href="#System_Object_GetHashCode">GetHashCode</a></li>
		<li><a href="#System_Object_Equals">Equals</a></li>
		<li><a href="#System_Object_MemberwiseClone">MemberwiseClone</a></li>
	</ul>
<li><a href="#System_RuntimeFieldHandle">System.RuntimeFieldHandle</a></li>
<li><a href="#System_RuntimeMethodHandle">System.RuntimeMethodHandle</a></li>
	<ul>
		<li><a href="#System_RuntimeMethodHandle_GetFunctionPointer">GetFunctionPointer</a></li>
	</ul>
<li><a href="#System_RuntimeTypeHandle">System.RuntimeTypeHandle</a></li>
<li><a href="#System_Single">System.Single</a></li>
	<ul>
		<li><a href="#System_Single_IsNaN">IsNaN</a></li>
		<li><a href="#System_Single_TestInfinity">TestInfinity</a></li>
	</ul>
<li><a href="#System_String">System.String</a></li>
	<ul>
		<li><a href="#System_String_ctor">constructor</a></li>
		<li><a href="#System_String_Compare">Compare</a></li>
		<li><a href="#System_String_InternalCompare">InternalCompare</a></li>
		<li><a href="#System_String_InternalOrdinal">InternalOrdinal</a></li>
		<li><a href="#System_String_NewString">NewString</a></li>
		<li><a href="#System_String_NewBuilder">NewBuilder</a></li>
		<li><a href="#System_String_Copy">Copy</a></li>
		<li><a href="#System_String_InsertSpace">InsertSpace</a></li>
		<li><a href="#System_String_RemoveSpace">RemoveSpace</a></li>
		<li><a href="#System_String_FinalizeBuilder">FillSubstring</a></li>
		<li><a href="#System_String_Concat">Concat</a></li>
		<li><a href="#System_String_CopyToChecked">CopyToChecked</a></li>
		<li><a href="#System_String_Equals">Equals</a></li>
		<li><a href="#System_String_EqualRange">EqualRange</a></li>
		<li><a href="#System_String_GetHashCode">GetHashCode</a></li>
		<li><a href="#System_String_IndexOf">IndexOf</a></li>
		<li><a href="#System_String_IndexOfAny">IndexOfAny</a></li>
		<li><a href="#System_String_LastIndexOf">LastIndexOf</a></li>
		<li><a href="#System_String_LastIndexOfAny">LastIndexOfAny</a></li>
		<li><a href="#System_String_Intern">Intern</a></li>
		<li><a href="#System_String_IsInterned">IsInterned</a></li>
		<li><a href="#System_String_CharFill">CharFill</a></li>
		<li><a href="#System_String_Replace">Replace</a></li>
		<li><a href="#System_String_Trim">Trim</a></li>
		<li><a href="#System_String_GetChar">GetChar</a></li>
		<li><a href="#System_String_SetChar">SetChar</a></li>
	</ul>
<li><a href="#System_Type">System.Type</a></li>
	<ul>
		<li><a href="#System_Type_GetType">GetType</a></li>
		<li><a href="#System_Type_GetTypeHandle">GetTypeHandle</a></li>
		<li><a href="#System_Type_GetTypeFromHandle">GetTypeFromHandle</a></li>
	</ul>
<li><a href="#System_TypedReference">System.TypedReference</a></li>
	<ul>
		<li><a href="#System_TypedReference_ClrMakeTypedReference">ClrMakeTypedReference</a></li>
		<li><a href="#System_TypedReference_SetTypedReference">SetTypedReference</a></li>
		<li><a href="#System_TypedReference_ToObject">ToObject</a></li>
	</ul>
</ul>
<li><a href="#System_Diagnostics">System.Diagnostics</a></li>
<ul>
<li><a href="#System_Diagnostics_Debugger">System.Diagnostics.Debugger</a></li>
	<ul>
		<li><a href="#System_Diagnostics_Debugger_InternalIsAttached">InternalIsAttached</a></li>
		<li><a href="#System_Diagnostics_Debugger_Break">Break</a></li>
		<li><a href="#System_Diagnostics_Debugger_IsLogging">IsLogging</a></li>
		<li><a href="#System_Diagnostics_Debugger_InternalLaunch">InternalLaunch</a></li>
		<li><a href="#System_Diagnostics_Debugger_Log">Log</a></li>
	</ul>
<li><a href="#System_Diagnostics_StackFrame">System.Diagnostics.StackFrame</a></li>
	<ul>
		<li><a href="#System_Diagnostics_StackFrame_InternalGetTotalFrames">InternalGetTotalFrames</a></li>
		<li><a href="#System_Diagnostics_StackFrame_InternalGetMethod">InternalGetMethod</a></li>
		<li><a href="#System_Diagnostics_StackFrame_InternalGetILOffset">InternalGetILOffset</a></li>
		<li><a href="#System_Diagnostics_StackFrame_InternalGetNativeOffset">InternalGetNativeOffset</a></li>
		<li><a href="#System_Diagnostics_StackFrame_InternalGetDebugInfo">InternalGetDebugInfo</a></li>
		<li><a href="#System_Diagnostics_StackFrame_GetExceptionStackTrace">GetExceptionStackTrace</a></li>
	</ul>
</ul>
<li><a href="#Reflection">System.Reflection</a></li>
<ul>
<li><a href="#Reflection_Assembly">System.Reflection.Assembly</a></li>
	<ul>
		<li><a href="#Reflection_Assembly_GetCallingAssembly">GetCallingAssembly</a></li>
		<li><a href="#Reflection_Assembly_GetExecutingAssembly">GetExecutingAssembly</a></li>
		<li><a href="#Reflection_Assembly_GetEntryAssembly">GetEntryAssembly</a></li>
		<li><a href="#Reflection_Assembly_GetExportedTypes">GetExportedTypes</a></li>
		<li><a href="#Reflection_Assembly_GetFile">GetFile</a></li>
		<li><a href="#Reflection_Assembly_GetType">GetType</a></li>
		<li><a href="#Reflection_Assembly_GetTypes">GetTypes</a></li>
		<li><a href="#Reflection_Assembly_LoadFromName">LoadFromName</a></li>
		<li><a href="#Reflection_Assembly_LoadFromFile">LoadFromFile</a></li>
	</ul>
<li><a href="#Reflection_ClrConstructor">System.Reflection.ClrConstructor</a></li>
	<ul>
		<li><a href="#Reflection_ClrConstructor_Invoke">Invoke</a></li>
	</ul>
<li><a href="#Reflection_ClrField">System.Reflection.ClrField</a></li>
	<ul>
		<li><a href="#Reflection_ClrField_GetValue">GetValue</a></li>
		<li><a href="#Reflection_ClrField_SetValue">SetValue</a></li>
		<li><a href="#Reflection_ClrField_GetFieldType">GetFieldType</a></li>
		<li><a href="#Reflection_ClrField_GetValueDirect">GetValueDirect</a></li>
		<li><a href="#Reflection_ClrField_SetValueDirect">SetValueDirect</a></li>
	</ul>
<li><a href="#Reflection_ClrHelpers">System.Reflection.ClrHelpers</a></li>
	<ul>
		<li><a href="#Reflection_ClrHelpers_GetCustomAttributes">GetCustomAttributes</a></li>
		<li><a href="#Reflection_ClrHelpers_IsDefined">IsDefined</a></li>
		<li><a href="#Reflection_ClrHelpers_GetDeclaringType">GetDeclaringType</a></li>
		<li><a href="#Reflection_ClrHelpers_GetName">GetName</a></li>
		<li><a href="#Reflection_ClrHelpers_GetParameter">GetParameter</a></li>
		<li><a href="#Reflection_ClrHelpers_GetParameterType">GetParameterType</a></li>
		<li><a href="#Reflection_ClrHelpers_GetNumParameters">GetNumParameters</a></li>
		<li><a href="#Reflection_ClrHelpers_GetMemberAttrs">GetMemberAttrs</a></li>
		<li><a href="#Reflection_ClrHelpers_GetCallConv">GetCallConv</a></li>
		<li><a href="#Reflection_ClrHelpers_GetImplAttrs">GetImplAttrs</a></li>
		<li><a href="#Reflection_ClrHelpers_GetSemantics">GetSemantics</a></li>
		<li><a href="#Reflection_ClrHelpers_HasSemantics">HasSemantics</a></li>
		<li><a href="#Reflection_ClrHelpers_CanAccess">CanAccess</a></li>
	</ul>
<li><a href="#Reflection_ClrMethod">System.Reflection.ClrMethod</a></li>
	<ul>
		<li><a href="#Reflection_ClrMethod_Invoke">Invoke</a></li>
		<li><a href="#Reflection_ClrMethod_GetBaseDefinition">GetBaseDefinition</a></li>
	</ul>
<li><a href="#Reflection_ClrParameter">System.Reflection.ClrParameter</a></li>
	<ul>
		<li><a href="#Reflection_ClrParameter_GetParamAttrs">GetParamAttrs</a></li>
		<li><a href="#Reflection_ClrParameter_GetParamName">GetParamName</a></li>
		<li><a href="#Reflection_ClrParameter_GetDefault">GetDefault</a></li>
	</ul>
<li><a href="#Reflection_ClrProperty">System.Reflection.ClrProperty</a></li>
	<ul>
		<li><a href="#Reflection_ClrProperty_GetPropertyType">GetPropertyType</a></li>
	</ul>
<li><a href="#Reflection_ClrType">System.Reflection.ClrType</a></li>
	<ul>
		<li><a href="#Reflection_ClrType_GetClrArrayRank">GetClrArrayRank</a></li>
		<li><a href="#Reflection_ClrType_GetAttributeFlagsImpl">GetAttributeFlagsImpl</a></li>
		<li><a href="#Reflection_ClrType_GetElementType">GetElementType</a></li>
		<li><a href="#Reflection_ClrType_GetInterface">GetInterface</a></li>
		<li><a href="#Reflection_ClrType_GetInterfaces">GetInterfaces</a></li>
		<li><a href="#Reflection_ClrType_GetMemberImpl">GetMemberImpl</a></li>
		<li><a href="#Reflection_ClrType_GetMembersImpl">GetMembersImpl</a></li>
		<li><a href="#Reflection_ClrType_GetClrTypeCategory">GetClrTypeCategory</a></li>
		<li><a href="#Reflection_ClrType_IsSubclassOf">IsSubclassOf</a></li>
		<li><a href="#Reflection_ClrType_IsClrNestedType">IsClrNestedType</a></li>
		<li><a href="#Reflection_ClrType_GetClrAssembly">GetClrAssembly</a></li>
		<li><a href="#Reflection_ClrType_GetClrBaseType">GetClrBaseType</a></li>
		<li><a href="#Reflection_ClrType_GetClrFullName">GetClrFullName</a></li>
		<li><a href="#Reflection_ClrType_GetClrGUID">GetClrGUID</a></li>
		<li><a href="#Reflection_ClrType_GetClrModule">GetClrModule</a></li>
		<li><a href="#Reflection_ClrType_GetClrNestedDeclaringType">GetClrNestedDeclaringType</a></li>
		<li><a href="#Reflection_ClrType_GetClrName">GetClrName</a></li>
		<li><a href="#Reflection_ClrType_GetClrNamespace">GetClrNamespace</a></li>
	</ul>
<li><a href="#Reflection_FieldInfo">System.Reflection.FieldInfo</a></li>
	<ul>
		<li><a href="#Reflection_FieldInfo_GetFieldFromHandle">GetFieldFromHandle</a></li>
	</ul>
<li><a href="#Reflection_MethodBase">System.Reflection.MethodBase</a></li>
	<ul>
		<li><a href="#Reflection_MethodBase_GetMethodFromHandle">GetMethodFromHandle</a></li>
		<li><a href="#Reflection_MethodBase_GetCurrentMethod">GetCurrentMethod</a></li>
	</ul>
<li><a href="#Reflection_Module">System.Reflection.Module</a></li>
	<ul>
		<li><a href="#Reflection_Module_GetType">GetType</a></li>
		<li><a href="#Reflection_Module_GetTypes">GetTypes</a></li>
		<li><a href="#Reflection_Module_IsResource">IsResource</a></li>
		<li><a href="#Reflection_Module_GetModuleType">GetModuleType</a></li>
		<li><a href="#Reflection_Module_GetAssembly">GetAssembly</a></li>
		<li><a href="#Reflection_Module_GetFullName">GetFullName</a></li>
	</ul>
</ul>
<li><a href="#System_Runtime">System.Runtime</a></li>
<ul>
<li><a href="#CompilerServices_RuntimeHelpers">System.Runtime.CompilerServices.RuntimeHelpers</a></li>
	<ul>
		<li><a href="#CompilerServices_RuntimeHelpers_InitializeArray">InitializeArray</a></li>
		<li><a href="#CompilerServices_RuntimeHelpers_RunClassConstructor">RunClassConstructor</a></li>
		<li><a href="#CompilerServices_RuntimeHelpers_InternalOffsetToStringValue">InternalOffsetToStringValue</a></li>
		<li><a href="#CompilerServices_RuntimeHelpers_GetObjectValue">GetObjectValue</a></li>
	</ul>
<li><a href="#InteropServices_GCHandle">System.Runtime.InteropServices.GCHandle</a></li>
	<ul>
		<li><a href="#InteropServices_GCHandle_GCAddrOfPinnedObject">GCAddrOfPinnedObject</a></li>
		<li><a href="#InteropServices_GCHandle_GCAlloc">GCAlloc</a></li>
		<li><a href="#InteropServices_GCHandle_GCFree">GCFree</a></li>
		<li><a href="#InteropServices_GCHandle_GCValidate">GCValidate</a></li>
		<li><a href="#InteropServices_GCHandle_GCGetTarget">GCGetTarget</a></li>
		<li><a href="#InteropServices_GCHandle_GCSetTarget">GCSetTarget</a></li>
	</ul>
</ul>
<li><a href="#System_Text">System.Text</a></li>
<ul>
<li><a href="#System_Text_DefaultEncoding">System.Text.DefaultEncoding</a></li>
	<ul>
		<li><a href="#System_Text_DefaultEncoding_InternalGetByteCount">InternalGetByteCount</a></li>
		<li><a href="#System_Text_DefaultEncoding_InternalGetBytes">InternalGetBytes</a></li>
		<li><a href="#System_Text_DefaultEncoding_InternalGetCharCount">InternalGetCharCount</a></li>
		<li><a href="#System_Text_DefaultEncoding_InternalGetChars">InternalGetChars</a></li>
		<li><a href="#System_Text_DefaultEncoding_InternalGetMaxByteCount">InternalGetMaxByteCount</a></li>
		<li><a href="#System_Text_DefaultEncoding_InternalGetMaxCharCount">InternalGetMaxCharCount</a></li>
		<li><a href="#System_Text_DefaultEncoding_InternalGetString">InternalGetString</a></li>
	</ul>
</ul>
<li><a href="#System_Threading">System.Threading</a></li>
<ul>
<li><a href="#Threading_Interlocked">System.Threading.Interlocked</a></li>
	<ul>
		<li><a href="#Threading_Interlocked_CompareExchange">CompareExchange</a></li>
		<li><a href="#Threading_Interlocked_Decrement">Decrement</a></li>
		<li><a href="#Threading_Interlocked_Exchange">Exchange</a></li>
		<li><a href="#Threading_Interlocked_Increment">Increment</a></li>
	</ul>
<li><a href="#Threading_Monitor">System.Threading.Monitor</a></li>
	<ul>
		<li><a href="#Threading_Monitor_Enter">Enter</a></li>
		<li><a href="#Threading_Monitor_InternalTryEnter">InternalTryEnter</a></li>
		<li><a href="#Threading_Monitor_Exit">Exit</a></li>
		<li><a href="#Threading_Monitor_InternalWait">InternalWait</a></li>
		<li><a href="#Threading_Monitor_Pulse">Pulse</a></li>
		<li><a href="#Threading_Monitor_PulseAll">PulseAll</a></li>
	</ul>
<li><a href="#Threading_Mutex">System.Threading.Mutex</a></li>
	<ul>
		<li><a href="#Threading_Mutex_InternalCreateMutex">InternalCreateMutex</a></li>
		<li><a href="#Threading_Mutex_InternalReleaseMutex">InternalReleaseMutex</a></li>
	</ul>
<li><a href="#Threading_Mutex">System.Threading.Thread</a></li>
	<ul>
		<li><a href="#Threading_Thread_FinalizeThread">FinalizeThread</a></li>
		<li><a href="#Threading_Thread_Abort">Abort</a></li>
		<li><a href="#Threading_Thread_InternalJoin">InternalJoin</a></li>
		<li><a href="#Threading_Thread_MemoryBarrier">MemoryBarrier</a></li>
		<li><a href="#Threading_Thread_ResetAbort">ResetAbort</a></li>
		<li><a href="#Threading_Thread_InternalSleep">InternalSleep</a></li>
		<li><a href="#Threading_Thread_Start">Start</a></li>
		<li><a href="#Threading_Thread_VolatileRead">VolatileRead</a></li>
		<li><a href="#Threading_Thread_VolatileWrite">VolatileWrite</a></li>
		<li><a href="#Threading_Thread_InternalCurrentThread">InternalCurrentThread</a></li>
		<li><a href="#Threading_Thread_InternalSetBackground">InternalSetBackground</a></li>
		<li><a href="#Threading_Thread_InternalGetPriority">InternalGetPriority</a></li>
		<li><a href="#Threading_Thread_InternalSetPriority">InternalSetPriority</a></li>
		<li><a href="#Threading_Thread_InternalGetState">InternalGetState</a></li>
	</ul>
<li><a href="#Threading_WaitHandle">System.Threading.WaitHandle</a></li>
	<ul>
		<li><a href="#Threading_WaitHandle_InternalClose">InternalClose</a></li>
		<li><a href="#Threading_WaitHandle_InternalWaitAll">InternalWaitAll</a></li>
		<li><a href="#Threading_WaitHandle_InternalWaitAny">InternalWaitAny</a></li>
		<li><a href="#Threading_WaitHandle_InternalWaitOne">InternalWaitOne</a></li>
	</ul>
</ul>
<li><a href="#Platform">Platform</a></li>
<ul>
<li><a href="#Platform_DirMethods">Platform.DirMethods</a></li>
	<ul>
		<li><a href="#Platform_DirMethods_GetPathInfo">GetPathInfo</a></li>
		<li><a href="#Platform_DirMethods_GetSystemDirectory">GetSystemDirectory</a></li>
	</ul>
<li><a href="#Platform_FileMethods">Platform.FileMethods</a></li>
	<ul>
		<li><a href="#Platform_FileMethods_GetInvalidHandle">GetInvalidHandle</a></li>
		<li><a href="#Platform_FileMethods_ValidatePathname">ValidatePathname</a></li>
		<li><a href="#Platform_FileMethods_Open">Open</a></li>
		<li><a href="#Platform_FileMethods_HasAsync">HasAsync</a></li>
		<li><a href="#Platform_FileMethods_CanSeek">CanSeek</a></li>
		<li><a href="#Platform_FileMethods_CheckHandleAccess">CheckHandleAccess</a></li>
		<li><a href="#Platform_FileMethods_Seek">Seek</a></li>
		<li><a href="#Platform_FileMethods_Write">Write</a></li>
		<li><a href="#Platform_FileMethods_Read">Read</a></li>
		<li><a href="#Platform_FileMethods_Close">Close</a></li>
		<li><a href="#Platform_FileMethods_FlushWrite">FlushWrite</a></li>
		<li><a href="#Platform_FileMethods_SetLength">SetLength</a></li>
		<li><a href="#Platform_FileMethods_GetErrno">GetErrno</a></li>
		<li><a href="#Platform_FileMethods_GetErrnoMessage">GetErrnoMessage</a></li>
	</ul>
<li><a href="#Platform_Errno">Platform.Errno</a></li>
<li><a href="#Platform_Stdio">Platform.Stdio</a></li>
	<ul>
		<li><a href="#Platform_Stdio_StdClose">StdClose</a></li>
		<li><a href="#Platform_Stdio_StdFlush">StdFlush</a></li>
		<li><a href="#Platform_Stdio_StdWrite">StdWrite</a></li>
		<li><a href="#Platform_Stdio_StdRead">StdRead</a></li>
		<li><a href="#Platform_Stdio_StdPeek">StdPeek</a></li>
	</ul>
<li><a href="#Platform_SysCharInfo">Platform.SysCharInfo</a></li>
	<ul>
		<li><a href="#Platform_SysCharInfo_GetUnicodeCategory">GetUnicodeCategory</a></li>
		<li><a href="#Platform_SysCharInfo_GetNumericValue">GetNumericValue</a></li>
		<li><a href="#Platform_SysCharInfo_GetNewLine">GetNewLine</a></li>
	</ul>
<li><a href="#Platform_TaskMethods">Platform.TaskMethods</a></li>
	<ul>
		<li><a href="#Platform_TaskMethods_Exit">Exit</a></li>
		<li><a href="#Platform_TaskMethods_SetExitCode">SetExitCode</a></li>
		<li><a href="#Platform_TaskMethods_GetCommandLineArgs">GetCommandLineArgs</a></li>
		<li><a href="#Platform_TaskMethods_GetEnvironmentVariable">GetEnvironmentVariable</a></li>
		<li><a href="#Platform_TaskMethods_GetEnvironmentCount">GetEnvironmentCount</a></li>
		<li><a href="#Platform_TaskMethods_GetEnvironmentKey">GetEnvironmentKey</a></li>
		<li><a href="#Platform_TaskMethods_GetEnvironmentValue">GetEnvironmentValue</a></li>
	</ul>
<li><a href="#Platform_TimeMethods">Platform.TimeMethods</a></li>
	<ul>
		<li><a href="#Platform_TimeMethods_GetCurrentTime">GetCurrentTime</a></li>
		<li><a href="#Platform_TimeMethods_GetCurrentUtcTime">GetCurrentUtcTime</a></li>
		<li><a href="#Platform_TimeMethods_GetTimeZoneAdjust">GetTimeZoneAdjust</a></li>
		<li><a href="#Platform_TimeMethods_GetUpTime">GetUpTime</a></li>
	</ul>
</ul>
</ul>

<a name="System"><h2>System</h2>

<a name="System_ArgIterator"><h3>System.ArgIterator</h3>

<a name="System_ArgIterator_ctor">
<pre>public ArgIterator(RuntimeArgumentHandle);
public ArgIterator(RuntimeArgumentHandle, void *);</pre>

<blockquote>
Construct a new argument iterator object.
</blockquote>

<a name="System_ArgIterator_GetNextArg">
<pre>public TypedReference GetNextArg();
public TypedReference GetNextArg(RuntimeTypeHandle type);</pre>

<blockquote>
Get the next argument from an argument iterator object, and advance
the iterator.  If <code>type</code> is supplied, then it indicates to
get the next argument with the specified type.
</blockquote>

<a name="System_ArgIterator_GetNextArgType">
<pre>public RuntimeTypeHandle GetNextArgType();</pre>

<blockquote>
Get the type of the next argument, but do not advance the iterator.
</blockquote>

<a name="System_ArgIterator_GetRemainingCount">
<pre>public int GetRemainingCount();</pre>

<blockquote>
Get the number of arguments that remain to be processed by the iterator.
</blockquote>

<a name="System_Array"><h3>System.Array</h3>

<a name="System_Array_Clear">
<pre>public static void Clear(Array array, int index, int length);</pre>

<blockquote>
Clear the contents of an array sub-range to all-zeroes, or all-nulls,
depending upon the element type.  The CLR is responsible for checking
the arguments and throwing exceptions where necessary.
</blockquote>

<a name="System_Array_Initialize">
<pre>public void Initialize();</pre>

<blockquote>
Call the default value type constructor for all elements within the
array.  If the array does not contain value types, or the types do
not have a default constructor, then this method does nothing.
</blockquote>

<a name="System_Array_Copy">
<pre>public static void Copy(Array sourceArray, int sourceIndex,
                        Array destArray, int destIndex,
                        int length);</pre>

<blockquote>
Copy the contents of a source array to a destination array.  This may
involve converting the elements into the destination array's element
type.  See the ECMA specifications for further information on the behaviour
of this method, and the exceptions that it may throw.
</blockquote>

<a name="System_Array_CreateArray">
<pre>private static Array CreateArray(IntPtr elementType,
                                 int rank, int length1,
                                 int length2, int length3);</pre>

<blockquote>
Create an array of elements.  This may be called for single, two,
or three-dimensional arrays that have no lower bounds.  The number
of <code>length</code> arguments to use is specified by <code>rank</code>.
The CLR can assume that all arguments have been validated.
</blockquote>

<a name="System_Array_CreateArray_2">
<pre>private static Array CreateArray(IntPtr elementType,
                                 int[] lengths, int[] lowerBounds);</pre>

<blockquote>
Create an array of elements.  This is called for creating arbitrarily-sized
arrays.  The CLR can assume that all arguments have been validated.
</blockquote>

<a name="System_Array_GetLength">
<pre>private int GetLength();</pre>

<blockquote>
Get the length of the array.  If the array is single-dimensional,
this will be the same as calling <code>GetLength(0)</code>.  If
the array is multi-dimensional, this will be the product of the
length of all dimensions.
</blockquote>

<a name="System_Array_GetLength_2">
<pre>public int GetLength(int dimension);</pre>

<blockquote>
Get the length of a specific array dimension.
</blockquote>

<a name="System_Array_GetLowerBound">
<pre>public int GetLowerBound(int dimension);</pre>

<blockquote>
Get the lower bound of a specific array dimension.
</blockquote>

<a name="System_Array_GetUpperBound">
<pre>public int GetUpperBound(int dimension);</pre>

<blockquote>
Get the upper bound of a specific array dimension.
</blockquote>

<a name="System_Array_GetRank">
<pre>private int GetRank();</pre>

<blockquote>
Get the rank of the array.
</blockquote>

<a name="System_Array_Get">
<pre>private Object Get(int index1, int index2, int index3);</pre>

<blockquote>
Get the value at a specific position within the array.  Throws
<code>IndexOutOfRangeException</code> if any of the indices are
out of range.  This method is called for arrays with 1, 2, and 3
dimensions.  The CLR should ignore extraneous arguments.
</blockquote>

<a name="System_Array_Get_2">
<pre>private Object Get(int[] indices);</pre>

<blockquote>
Get the value at a specific position within the array.  Throws
<code>IndexOutOfRangeException</code> if any of the indices are
out of range.
</blockquote>

<a name="System_Array_Set">
<pre>private void Set(Object value, int index1, int index2, int index3);</pre>

<blockquote>
Set the value at a specific position within the array.  Throws
<code>IndexOutOfRangeException</code> if any of the indices are
out of range.  This method is called for arrays with 1, 2, and 3
dimensions.  The CLR should ignore extraneous arguments.
</blockquote>

<a name="System_Array_Set_2">
<pre>private void Set(Object value, int[] indices);</pre>

<blockquote>
Set the value at a specific position within the array.  Throws
<code>IndexOutOfRangeException</code> if any of the indices are
out of range.
</blockquote>

<a name="System_Decimal"><h3>System.Decimal</h3>

The System.Decimal type is represented as four 32-bit integer fields,
as follows:

<blockquote><pre>private int flags, high, middle, low;</pre></blockquote>

The high bit of <code>flags</code> is non-zero to indicate a negative
number.  Bits 16-23 hold a scale factor, between 0 and 28 inclusive.
The three words <code>high</code>, <code>middle</code>, and
<code>low</code> form a 96-bit mantissa for the <code>Decimal</code>
value, with the power of 10 specified by the scale factor.<p>

The <code>Decimal</code> operators use the "round half even" rounding
mode.  Values less than 0.5 round down.  Values greater than 0.5 round
up.  Values equal to 0.5 round either up or down, depending upon which
will give an even result.<p>

Further information on the representation of <code>Decimal</code> may
be found in the ECMA specifications for C# and in the pnetlib source code.<p>

<a name="System_Decimal_ctor">
<pre>public Decimal(float value);
public Decimal(double value);</pre>

<blockquote>
Construct <code>Decimal</code> values from <code>float</code>
and <code>double</code> values.  If <code>value</code> is out of range,
NaN, or an infinity, then throw an <code>OverflowException</code>
exception.<p>

The CLR can call the <code>Decimal.ThrowOverflow()</code> method to
throw the exception.  This will ensure that the exception message will
be appropriately translated into foreign languages.  The same applies
for all of the remaining <code>Decimal</code> methods that throw
exceptions.
</blockquote>

<a name="System_Decimal_ToSingle">
<a name="System_Decimal_ToDouble">
<pre>public static float ToSingle(decimal value);
public static float ToDouble(decimal value);</pre>

<blockquote>
Convert <code>Decimal</code> values into either <code>float</code>
or <code>double</code>.  No exceptions are thrown.
</blockquote>

<a name="System_Decimal_Add">
<pre>public static decimal Add(decimal x, decimal y);</pre>

<blockquote>
Add two <code>Decimal</code> values, throwing an exception on overflow.
</blockquote>

<a name="System_Decimal_Compare">
<pre>public static int Compare(decimal x, decimal y);</pre>

<blockquote>
Compare two <code>Decimal</code> values.  Returns -1, 0, or 1, depending
upon whether the comparison is less than, equal to, or greater than.
</blockquote>

<a name="System_Decimal_Divide">
<pre>public static decimal Divide(decimal x, decimal y);</pre>

<blockquote>
Divide two <code>Decimal</code> values and return the quotient.
Throws <code>OverflowException</code> if the result is too large to
be represented as a <code>Decimal</code> value.  Throws
<code>DivideByZeroException</code> if <code>y</code> is zero.<p>

The CLR can call the <code>Decimal.ThrowDivZero()</code> method to
throw the exception.  This will ensure that the exception message will
be appropriately translated into foreign languages.  The same applies
for the <code>Remainder</code> method.
</blockquote>

<a name="System_Decimal_Floor">
<pre>public static decimal Floor(decimal x);</pre>

<blockquote>
Compute the next lower integer value below or equal to <code>x</code>.
</blockquote>

<a name="System_Decimal_Remainder">
<pre>public static decimal Remainder(decimal x, decimal y);</pre>

<blockquote>
Divide two <code>Decimal</code> values and return the remainder.
Throws <code>OverflowException</code> if the quotient is too large to
be represented as a <code>Decimal</code> value.  Throws
<code>DivideByZeroException</code> if <code>y</code> is zero.
</blockquote>

<a name="System_Decimal_Multiply">
<pre>public static decimal Multiply(decimal x, decimal y);</pre>

<blockquote>
Multiply two <code>Decimal</code> values and return the product.
Throws <code>OverflowException</code> if overflow occurs.
</blockquote>

<a name="System_Decimal_Negate">
<pre>public static decimal Negate(decimal x);</pre>

<blockquote>
Negate a <code>Decimal</code> value.  No exceptions are thrown.
</blockquote>

<a name="System_Decimal_Round">
<pre>public static decimal Round(decimal x, int decimals);</pre>

<blockquote>
Round a <code>Decimal</code> value to a specific number of decimal
places.  The <code>decimals</code> value must be between 0 and 28
inclusive, or an <code>ArgumentOutOfRangeException</code> is thrown.
Overflow will cause an <code>OverflowException</code> to be thrown.<p>

The CLR can call the <code>Decimal.ThrowDecimals()</code> method to
throw the <code>ArgumentOutOfRangeException</code>.  This will ensure
that the exception message will be appropriately translated into
foreign languages.
</blockquote>

<a name="System_Decimal_Subtract">
<pre>public static decimal Subtract(decimal x, decimal y);</pre>

<blockquote>
Subtract two <code>Decimal</code> values, throwing an exception on overflow.
</blockquote>

<a name="System_Decimal_Truncate">
<pre>public static decimal Truncate(decimal x);</pre>

<blockquote>
Truncate a <code>Decimal</code> value to an integer, towards zero.
</blockquote>

<a name="System_Delegate"><h3>System.Delegate</h3>

The CLR can assume that the <code>System.Delegate</code> and
<code>System.MulticastDelegate</code> classes have the
following field definitions:<p>

<blockquote><pre>public abstract class Delegate
{
    internal Object     target;
    internal MethodInfo method;
}

public abstract class MulticastDelegate : Delegate
{
    private MulticastDelegate prev;
}</pre></blockquote>

The CLR will use these structures when creating delegates from function
pointers.  The correct delegate creation algorithm is as follows:

<ul>
	<li>Create an instance of the required delegate class.</li>
	<li>Populate the <code>target</code> and <code>method</code>
		fields with the correct values based on the function pointer
		data.</li>
	<li>If the delegate is multicast, then initialize <code>prev</code>
		to <code>null</code>.</li>
	<li>Initialize all other fields to zero.</li>
</ul>

The <code>prev</code> field can be used by the runtime engine to optimise
the invocation of multicast delegates.  If it is <code>null</code>, then
the delegate's invocation list consists of a single entry defined
by <code>target</code> and <code>method</code>.  Otherwise, the
delegate should be invoked by doing a recursive call on <code>prev</code>,
and then invoking the main entry defined by <code>target</code>
and <code>method</code>.<p>

<a name="System_Delegate_CreateBlankDelegate">
<pre>private static Delegate CreateBlankDelegate(Type type, ClrMethod method);</pre>

<blockquote>
Creates an object which is an instance of the specified <code>type</code>,
but does not call the constructor or otherwise initialize the object fields.
This is used by <code>Delegate.CreateDelegate</code> to construct an
object that it will fill in with method details later.<p>

The <code>method</code> parameter is used to validate the delegate's
signature.  If the delegate's <code>Invoke</code> method does not
have the same signature as <code>method</code>, then
<code>CreateBlankDelegate</code> should return <code>null</code>.<p>

The <code>method</code> parameter will be <code>null</code> if the
method is not a runtime engine method.  In this case,
<code>CreateBlankDelegate</code> should return a new delegate only if
the delegate type has no signature (i.e., no <code>Invoke</code> method).
</blockquote>

<a name="System_Double"><h3>System.Double</h3>

<a name="System_Double_IsNaN">
<pre>public static bool IsNaN(double d);</pre>

<blockquote>
Returns <code>true</code> if <code>d</code> is not a number.
</blockquote>

<a name="System_Double_TestInfinity">
<pre>private static int TestInfinity(double d);</pre>

<blockquote>
Returns -1 if <code>d</code> is negative infinity, 1 if <code>d</code>
is positive infinity, and 0 otherwise.
</blockquote>

<a name="System_Enum"><h3>System.Enum</h3>

<a name="System_Enum_GetEnumValue">
<pre>private Object GetEnumValue();</pre>

<blockquote>
Get the value of this enumerated type instance as a boxed object.
The type of the returned value will be one of <code>System.Byte</code>,
<code>System.SByte</code>, <code>System.Int16</code>,
<code>System.UInt16</code>, <code>System.Int32</code>,
<code>System.UInt32</code>, <code>System.Int64</code>,
and <code>System.UInt64</code>, depending upon the enumerated type's
underlying type.
</blockquote>

<a name="System_Enum_GetEnumName">
<pre>private static String GetEnumName(Type enumType, Object value);</pre>

<blockquote>
Get the name of an enumerated constant given a value in the
underlying type of the specified enumerated type.  Returns <code>null</code>
if the value does not correspond to an enumerated constant in the type.
</blockquote>

<a name="System_Enum_IsEnumValue">
<pre>private static bool IsEnumValue(Type enumType, Object value);</pre>

<blockquote>
Determine if <code>value</code> is a legitimate value for the specified
enumerated type.  The value will be a member of the enumerated type's
underlying type.
</blockquote>

<a name="System_Enum_GetEnumValueFromName">
<pre>private static Object GetEnumValueFromName
               (Type enumType, Object value, bool ignoreCase);</pre>

<blockquote>
Get an enumerated value by name.  The name may either be a constant name,
or an integer value.  The return type is either an enumerated value in
the specified type, or <code>null</code> if the name is invalid.
</blockquote>

<a name="System_Enum_EnumValueOr">
<pre>private static Object EnumValueOr(Object value1, Object value2);</pre>

<blockquote>
Form the OR of two enumerated values to produce a new enumerated value
of the same type.
</blockquote>

<a name="System_Enum_EnumIntToObject">
<pre>private static Object EnumIntToObject(Type enumType, int value);</pre>

<blockquote>
Convert an integer value into a boxed enumerated value of the specified type.
</blockquote>

<a name="System_Enum_EnumLongToObject">
<pre>private static Object EnumLongToObject(Type enumType, int value);</pre>

<blockquote>
Convert a long integer value into a boxed enumerated value of
the specified type.
</blockquote>

<a name="System_Enum_FormatEnumWithFlags">
<pre>private static String FormatEnumWithFlags(Type enumType, Object value);</pre>

<blockquote>
Format an enumerated value that may involve flag bits.
</blockquote>

<a name="System_GC"><h3>System.GC</h3>

<a name="System_GC_KeepAlive">
<pre>public static void KeepAlive(Object obj);</pre>

<blockquote>
Keep an object reference alive.
</blockquote>

<a name="System_GC_ReRegisterForFinalize">
<pre>public static void ReRegisterForFinalize(Object obj);</pre>

<blockquote>
Re-register an object for finalization that had previously been
de-registered by <code>SuppressFinalize</code>.  Use of this is
security-sensitive, and the CLR may choose to ignore the call.
</blockquote>

<a name="System_GC_SuppressFinalize">
<pre>public static void SuppressFinalize(Object obj);</pre>

<blockquote>
Suppress finalization for an object.  Use of this is security-sensitive,
and the CLR may choose to ignore the call.
</blockquote>

<a name="System_GC_WaitForPendingFinalizers">
<pre>public static void WaitForPendingFinalizers();</pre>

<blockquote>
Wait for all pending object finalizers to be run.
</blockquote>

<a name="System_Guid"><h3>System.Guid</h3>

<a name="System_Guid_NewGuid">
<pre>public static Guid NewGuid();</pre>

<blockquote>
Create a new, random, GUID value and return it.  Note: it is recommended
that this be the output of a secure random number generator, and not be
based on host-specific or user-specific information.  GUID's based on
host or user information can be a threat to the user's privacy.
</blockquote>

<a name="System_Math"><h3>System.Math</h3>

<a name="System_Math_Acos">
<a name="System_Math_Asin">
<a name="System_Math_Atan">
<a name="System_Math_Atan2">
<a name="System_Math_Cos">
<a name="System_Math_Cosh">
<a name="System_Math_Sin">
<a name="System_Math_Sinh">
<a name="System_Math_Tan">
<a name="System_Math_Tanh">
<pre>public static double Acos(double d);
public static double Asin(double d);
public static double Atan(double d);
public static double Atan2(double y, double x);
public static double Cos(double d);
public static double Cosh(double d);
public static double Sin(double d);
public static double Sinh(double d);
public static double Tan(double d);
public static double Tanh(double d);</pre>

<blockquote>
Perform various trigonometric functions on <code>double</code> values.
</blockquote>

<a name="System_Math_Ceiling">
<pre>public static double Ceiling(double d);</pre>

<blockquote>
Compute the ceiling of a <code>double</code> value.
</blockquote>

<a name="System_Math_Floor">
<pre>public static double Floor(double d);</pre>

<blockquote>
Compute the floor of a <code>double</code> value.
</blockquote>

<a name="System_Math_Exp">
<pre>public static double Exp(double d);</pre>

<blockquote>
Compute <i>e</i> raised to the power of a <code>double</code> value.
</blockquote>

<a name="System_Math_Pow">
<pre>public static double Pow(double x, double y);</pre>

<blockquote>
Compute <code>x</code> raised to the power of <code>y</code>.
</blockquote>

<a name="System_Math_IEEERemainder">
<pre>public static double IEEERemainder(double x, double y);</pre>

<blockquote>
Compute the IEEE remainder of dividing two <code>double</code> values.
</blockquote>

<a name="System_Math_Log">
<pre>public static double Log(double d);</pre>

<blockquote>
Compute the logarithm, in base <i>e</i>, of a <code>double</code> value.
</blockquote>

<a name="System_Math_Log10">
<pre>public static double Log10(double d);</pre>

<blockquote>
Compute the logarithm, in base 10, of a <code>double</code> value.
</blockquote>

<a name="System_Math_Round">
<pre>public static double Round(double d);</pre>

<blockquote>
Round a <code>double</code> value to the nearest integer.
</blockquote>

<a name="System_Math_RoundDouble">
<pre>private static double RoundDouble(double d, int digits);</pre>

<blockquote>
Round a <code>double</code> value to a certain number of decimal
digits.  The CLR can assume that <code>digits</code> has already
been validated by the caller.
</blockquote>

<a name="System_Math_Sqrt">
<pre>public static double Sqrt(double d);</pre>

<blockquote>
Compute the square root of a <code>double</code> value.
</blockquote>

<a name="System_Object"><h3>System.Object</h3>

<a name="System_Object_GetType">
<pre>public Type GetType();</pre>

<blockquote>
Get the type associated with the object.  The same value must be
returned for multiple calls on the same object, and for two objects
with identical types.  The returned value will typically be an
instance of <code>ClrType</code>, which subclasses <code>Type</code>.
</blockquote>

<a name="System_Object_GetHashCode">
<pre>public virtual int GetHashCode();</pre>

<blockquote>
Get the default hash code associated with the object.  Normally this
is just the object pointer, cast to <code>int</code>.  On platforms
with 64-bit pointers, this may either truncate the pointer or attempt
to combine the high and low words into the final hash value.
</blockquote>

<a name="System_Object_Equals">
<pre>public virtual bool Equals(Object obj);</pre>

<blockquote>
Default implementation of "Equals".  Returns true only if <code>this</code>
and <code>obj</code> refer to the same object.
</blockquote>

<a name="System_Object_MemberwiseClone">
<pre>protected Object MemberwiseClone();</pre>

<blockquote>
Perform a memberwise clone on the object.
</blockquote>

<a name="System_RuntimeFieldHandle"><h3>System.RuntimeFieldHandle</h3>

Runtime field handles are pushed onto the evaluation stack using
the <code>ldtoken</code> instruction.  We assume that the data structure
contains a single <code>IntPtr</code> value that points to CLR-specific
data.  The class library does not attempt to interpret this value any
further, but it will pass it to various <code>internalcall</code> API's
that deal with field reflection.<p>

<a name="System_RuntimeMethodHandle"><h3>System.RuntimeMethodHandle</h3>

Runtime method handles are pushed onto the evaluation stack using
the <code>ldtoken</code> instruction.  We assume that the data structure
contains a single <code>IntPtr</code> value that points to CLR-specific
data.  The class library does not attempt to interpret this value any
further, but it will pass it to various <code>internalcall</code> API's
that deal with method reflection.<p>

<a name="System_RuntimeMethodHandle_GetFunctionPointer">
<pre>public IntPtr GetFunctionPointer();</pre>

<blockquote>
Get the function pointer that corresponds to a method handle.  The
returned value may be a native function pointer value, or it may simply
be the method handle as a pointer.  The behaviour is CLR-specific.
</blockquote>

<a name="System_RuntimeTypeHandle"><h3>System.RuntimeTypeHandle</h3>

Runtime type handles are pushed onto the evaluation stack using
the <code>ldtoken</code> instruction.  We assume that the data structure
contains a single <code>IntPtr</code> value that points to CLR-specific
data.  The class library does not attempt to interpret this value any
further, but it will pass it to various <code>internalcall</code> API's
that deal with type reflection.<p>

<a name="System_Single"><h3>System.Single</h3>

<a name="System_Single_IsNaN">
<pre>public static bool IsNaN(float f);</pre>

<blockquote>
Returns <code>true</code> if <code>f</code> is not a number.
</blockquote>

<a name="System_Single_TestInfinity">
<pre>private static int TestInfinity(float f);</pre>

<blockquote>
Returns -1 if <code>f</code> is negative infinity, 1 if <code>f</code>
is positive infinity, and 0 otherwise.
</blockquote>

<a name="System_String"><h3>System.String</h3>

The class library assumes that strings are represented in a particular
manner by the runtime engine.  The definition of the fields within
the class library is as follows:

<blockquote><pre>class String
{
	private int capacity;
	private int length;
	private char firstChar;

}</pre></blockquote>

The length of the string is <code>length</code>, and the first character
starts at the address of <code>capacity</code> in memory.  The
<code>capacity</code> field will typically be equal to or greater
than <code>length</code>, and indicates how many characters of space
are available in the string.  This is used by the <code>StringBuilder</code>
class to insert additional characters into a string while it is being
built.<p>

String objects begin with the above header and are variable in length.
The length is determined by the constructor.  The entire string is stored
in a single heap memory block.  Other implementations, particularly Java,
store the string header and character array separately.<p>

<a name="System_String_ctor">
<pre>public String(char[] value, int startIndex, int length);
public String(char[] value);
public String(char c, int count);
public String(char *value, int startIndex, int length);
public String(char *value);
public String(sbyte *value, int startIndex, int length, Encoding enc);
public String(sbyte *value, int startIndex, int length);
public String(sbyte *value);</pre>

<blockquote>
Construct a new string object with the specified contents.
</blockquote>

<a name="System_String_Compare">
<pre>public static int Compare(String strA, String strB);</pre>

<blockquote>
Compare two strings using the prevailing locale settings.  The comparison
is case-sensitive.
</blockquote>

<a name="System_String_InternalCompare">
<pre>private static int InternalCompare(String strA, int indexA, int lengthA,
                                   String strB, int indexB, int lengthB,
                                   bool ignoreCase, CultureInfo culture);</pre>

<blockquote>
Compare two sub-strings using the specified culture settings.  If
<code>culture</code> is <code>null</code>, then use the prevailing
locale settings.  The comparison is case-insensitive if
<code>ignoreCase</code> is <code>false</code>.<p>

It is possible for <code>lengthA</code> and <code>lengthB</code> to
be different: e.g., if <code>lengthA</code> is less than <code>lengthB</code>
and the first <code>lengthA</code> characters of <code>strA</code> are
identical to the first <code>lengthA</code> characters of <code>strB</code>,
then <code>strA</code> is less than <code>strB</code>.
</blockquote>

<a name="System_String_InternalOrdinal">
<pre>private static int InternalOrdinal(String strA, int indexA, int lengthA,
                                   String strB, int indexB, int lengthB);</pre>

<blockquote>
Compare two sub-strings using ordinal character comparisons.  Locale
and culture information is not used.  It is possible for
<code>lengthA</code> and <code>lengthB</code> to be different:
e.g., if <code>lengthA</code> is less than <code>lengthB</code>
and the first <code>lengthA</code> characters of <code>strA</code> are
identical to the first <code>lengthA</code> characters of <code>strB</code>,
then <code>strA</code> is less than <code>strB</code>.
</blockquote>

<a name="System_String_NewString">
<pre>internal static String NewString(int length);</pre>

<blockquote>
Allocate a string of the specified <code>length</code>, and populate
it with zeroes.  This is used by methods such as <code>Concat</code>
and <code>Insert</code> to build blank strings ready to be filled
with new characters.  The CLR can assume that the <code>length</code>
argument is valid.
</blockquote>

<a name="System_String_NewBuilder">
<pre>internal static String NewBuilder(int capacity);</pre>

<blockquote>
Allocate a string object with its capacity initialized
to <code>capacity</code>, and its <code>length</code> initialized
to zero.  This is used by the <code>StringBuilder</code> class
to assist in the process of building strings.
</blockquote>

<a name="System_String_Copy">
<pre>internal static void Copy(String dest, int destPos, String src);</pre>

<blockquote>
Copy the entire contents of <code>src</code> to <code>dest</code>,
starting at <code>destPos</code>.  The CLR can assume that all
arguments are valid.<p>

It is possible for <code>destPos</code> to be greater than or equal to
the length of <code>dest</code> if the string object is being constructed
by a <code>StringBuilder</code>.  The CLR should not range-check this value.
</blockquote>

<a name="System_String_Copy_2">
<pre>internal static void Copy(String dest, int destPos,
                          String src, int srcPos, int length);</pre>

<blockquote>
Copy <code>length</code> characters from the contents of the string
<code>src</code>, starting at <code>srcPos</code>, to the contents of
<code>dest</code> The CLR can assume that all arguments are valid.<p>

It is possible for <code>destPos</code> to be greater than or equal to
the length of <code>dest</code> if the string object is being constructed
by a <code>StringBuilder</code>.  The CLR should not range-check this value.
</blockquote>

<a name="System_String_InsertSpace">
<pre>internal static void InsertSpace(String str, int srcPos, int destPos);</pre>

<blockquote>
Insert space into a string by moving all characters starting at
<code>srcPos</code> to a new location starting at <code>destPos</code>.
</blockquote>

<a name="System_String_RemoveSpace">
<pre>internal static void RemoveSpace(String str, int index, int length);</pre>

<blockquote>
Remove <code>length</code> characters from a string starting at
<code>index</code>.
</blockquote>

<a name="System_String_Concat">
<pre>public static String Concat(String str1, String str2);
public static String Concat(String str1, String str2, String str3);</pre>

<blockquote>
Concatenate two (or three) strings together.  These are specified as
<code>internalcall</code> methods because the runtime engine may have
an efficient mechanism to concatenate strings.
</blockquote>

<a name="System_String_CopyToChecked">
<pre>private void CopyToChecked(int sourceIndex, char[] dest,
                           int destIndex, int count);</pre>

<blockquote>
Copy the contents of a string into a destination array.  The CLR can
assume that the arguments have already been checked for validity.
</blockquote>

<a name="System_String_Equals">
<pre>public static bool Equals(String a, String b);</pre>

<blockquote>
Compare two strings for ordinal equality.
</blockquote>

<a name="System_String_EqualRange">
<pre>private bool EqualRange(int srcIndex, int count,
                        String dest, int destIndex);</pre>

<blockquote>
Compare sub-ranges of two strings for ordinal equality.  The CLR
can assume that the arguments are valid.
</blockquote>

<a name="System_String_GetHashCode">
<pre>public override int GetHashCode();</pre>

<blockquote>
Get a hash value for the string.
</blockquote>

<a name="System_String_IndexOf">
<pre>public int IndexOf(char value, int startIndex, int count);</pre>

<blockquote>
Get the index of a specific character within the string.  See the ECMA
specification for information on the exceptions that this method may throw.
</blockquote>

<a name="System_String_IndexOfAny">
<pre>public int IndexOfAny(char[] anyOf, int startIndex, int count);</pre>

<blockquote>
Get the index of a character within the string that appears in the
<code>anyOf</code> array.  See the ECMA specification for information on
the exceptions that this method may throw.
</blockquote>

<a name="System_String_LastIndexOf">
<pre>public int LastIndexOf(char value, int startIndex, int count);</pre>

<blockquote>
Get the last index of a specific character within the string.  See the ECMA
specification for information on the exceptions that this method may throw.
</blockquote>

<a name="System_String_LastIndexOfAny">
<pre>public int LastIndexOfAny(char[] anyOf, int startIndex, int count);</pre>

<blockquote>
Get the last index of a character within the string that appears in the
<code>anyOf</code> array.  See the ECMA specification for information on
the exceptions that this method may throw.
</blockquote>

<a name="System_String_Intern">
<pre>public static String Intern(String str);</pre>

<blockquote>
Intern a string and return the new value.  If <code>str</code> is already
intern'ed or <code>null</code>, this method will return <code>str</code>.
</blockquote>

<a name="System_String_IsInterned">
<pre>public static String IsInterned(String str);</pre>

<blockquote>
Determine if <code>str</code> is intern'ed.  If it is, then return
<code>str</code>.  Otherwise return <code>null</code>.
</blockquote>

<a name="System_String_CharFill">
<pre>private static void CharFill(String str, int start, int count, char ch);</pre>

<blockquote>
Fill a sub-range within a string with a specified character.  The CLR
can assume that the arguments are valid.
</blockquote>

<a name="System_String_CharFill_2">
<pre>private static void CharFill(String str, int start, char[] chars,
                             int count, char ch);</pre>

<blockquote>
Fill a sub-range within a string with a range of characters from an array.
</blockquote>

<a name="System_String_Replace">
<pre>public String Replace(char oldChar, char newChar);</pre>

<blockquote>
Replace all occurrences of <code>oldChar</code> in the string with
<code>newChar</code>, and return a newly allocated string with the
replacements.
</blockquote>

<pre>public String Replace(String oldValue, String newValue);</pre>

<blockquote>
Replace all occurrences of <code>oldValue</code> in the string with
<code>newValue</code>, and return a newly allocated string with the
replacements.
</blockquote>

<a name="System_String_Trim">
<pre>private String Trim(char[] trimChars, int trimFlags);</pre>

<blockquote>
Trim any characters that are contained in the specified array from
the string.  The <code>trimFlags</code> argument specifies where the
characters should be trimmed from: the bit <code>TrimFlag_Front</code> (1)
indicates the front, and the bit <code>TrimFlag_End</code> (2)
indicates the end.  Setting both bits will trim both ends of the string.
</blockquote>

<a name="System_String_GetChar">
<pre>private char GetChar(int posn);</pre>

<blockquote>
Gets the character at <code>posn</code> within the string.  Throws
an <code>IndexOutOfRangeException</code> if <code>posn</code> is
invalid.
</blockquote>

<a name="System_String_SetChar">
<pre>private void SetChar(int posn, char ch);</pre>

<blockquote>
Sets the character at <code>posn</code> within the string to <code>ch</code>.
Throws an <code>IndexOutOfRangeException</code> if <code>posn</code> is
invalid.
</blockquote>

<a name="System_Type"><h3>System.Type</h3>

<a name="System_Type_GetType">
<pre>public static Type GetType(String name, bool throwOnError, bool ignoreCase);</pre>

<blockquote>
Get a type by name from the executing image.  If <code>throwOnError</code>
is <code>true</code>, then throw a <code>TypeLoadException</code> if the
type cannot be found.  Otherwise return <code>null</code>.  If
<code>ignoreCase</code> is true, then ignore case when comparing names.<p>

Note: the Microsoft .NET Framework ignores the <code>ignoreCase</code> value
if the name is 128 or more characters in length, and performs a
case-sensitive search regardless.
</blockquote>

<a name="System_Type_GetTypeHandle">
<pre>public static RuntimeTypeHandle GetTypeHandle(Object obj);</pre>

<blockquote>
Get the type handle associated with the type of the specified object.
</blockquote>

<a name="System_Type_GetTypeFromHandle">
<pre>public static Type GetTypeFromHandle(RuntimeTypeHandle handle);</pre>

<blockquote>
Get the type that corresponds to the specified <code>handle</code>.
The returned value will typically be an instance of <code>ClrType</code>,
which subclasses <code>Type</code>.  The CLR is required to return the
same object for multiple calls to this method with the same handle.
</blockquote>

<a name="System_TypedReference"><h3>System.TypedReference</h3>

<a name="System_TypedReference_ClrMakeTypedReference">
<pre>private static TypedReference ClrMakeTypedReference(Object target, FieldInfo[] flds);</pre>

<blockquote>
Make a typed reference from a target and a set of fields.  The fields are
guaranteed to be non-null and members of the <code>ClrField</code> class.
This method may throw an exception if the fields are not valid for the object.
</blockquote>

<a name="System_TypedReference_SetTypedReference">
<pre>public static void SetTypedReference(TypedReference target, Object value);</pre>

<blockquote>
Set the value within a typed reference.
</blockquote>

<a name="System_TypedReference_ToObject">
<pre>public static Object ToObject(TypedReference value);</pre>

<blockquote>
Convert a typed reference into an object.
</blockquote>

<a name="System_Diagnostics"><h2>System.Diagnostics</h2>

<a name="System_Diagnostics_Debugger"><h3>System.Diagnostics.Debugger</h3>

<a name="System_Diagnostics_Debugger_InternalIsAttached">
<pre>private static bool InternalIsAttached();</pre>

<blockquote>
Determine if a debugger is currently attached to the executing process.
If the CLR does not support debugging, this will always return
<code>false</code>.
</blockquote>

<a name="System_Diagnostics_Debugger_Break">
<pre>public static void Break();</pre>

<blockquote>
Cause an explicit breakpoint to occur within the attached debugger.
If the CLR does not support debugging, or there is no debugger attached,
calls to this method are ignored.
</blockquote>

<a name="System_Diagnostics_Debugger_IsLogging">
<pre>public static bool IsLogging();</pre>

<blockquote>
Determine if the attached debugger is currently logging messages.
If the CLR does not support debugging, or log message during debugging,
this method will always return <code>false</code>.
</blockquote>

<a name="System_Diagnostics_Debugger_InternalLaunch">
<pre>private static bool InternalLaunch();</pre>

<blockquote>
Launch the debugger and attach it to this process if it is not already
attached.  If the CLR does not support debugging, or attaching a debugger
to a running process, then this method will always return <code>false</code>.
If the debugger is already attached, this method will simply return
<code>true</code>.
</blockquote>

<a name="System_Diagnostics_Debugger_Log">
<pre>public static void Log(int level, String category, String message);</pre>

<blockquote>
Log a message with the debugger's logging facility.  If the CLR does
not support debug logging, or it is currently disabled, then calls
to this method will be ignored.
</blockquote>

<a name="System_Diagnostics_StackFrame"><h3>System.Diagnostics.StackFrame</h3>

<a name="System_Diagnostics_StackFrame_InternalGetTotalFrames">
<pre>private static int InternalGetTotalFrames();</pre>

<blockquote>
Get the total number of stack frames that are on the stack in the
current thread, excluding the frame that was set up to call
<code>InternalGetTotalFrames</code>.
</blockquote>

<a name="System_Diagnostics_StackFrame_InternalGetMethod">
<pre>private static RuntimeMethodHandle InternalGetMethod(int skipFrames);</pre>

<blockquote>
Get the method handle from a stack frame that is <code>skipFrames</code>
items up the stack.  The value 0 indicates the method that called
<code>InternalGetMethod</code>.
</blockquote>

<a name="System_Diagnostics_StackFrame_InternalGetILOffset">
<pre>private static int InternalGetILOffset(int skipFrames);</pre>

<blockquote>
Get the offset within the Intermediate Language (IL) bytecode of
the current execution position within the method that is
<code>skipFrames</code> items up the stack.  If the offset cannot
be determined, this method should return -1.
</blockquote>

<a name="System_Diagnostics_StackFrame_InternalGetNativeOffset">
<pre>private static int InternalGetNativeOffset(int skipFrames);</pre>

<blockquote>
Get the offset within the native code of the current execution position 
within the method that is <code>skipFrames</code> items up the stack.
If the offset cannot be determined, this method should return -1.
</blockquote>

<a name="System_Diagnostics_StackFrame_InternalGetDebugInfo">
<pre>private static String InternalGetDebugInfo(RuntimeMethodHandle method, int offset,
                                           out int line, out int column);</pre>

<blockquote>
Get debug line number information about a specific IL offset within
the specified method.  The line number is returned in <code>line</code>
(0 if the line number cannot be determined).  The column number is returned
in <code>column</code> (0 if the column number cannot be determined).
The filename is returned from the method (<code>null</code> if the filename
cannot be determined).
</blockquote>

<a name="System_Diagnostics_StackFrame_GetExceptionStackTrace">
<pre>private static PackedStackFrame[] GetExceptionStackTrace();</pre>

<blockquote>
Get the stack trace for the current position in the program in response
to an exception object being created.  The CLR must skip over any method
frames that correspond to exception constructor calls, and then begin
collecting information.  The data is returned in an array of
<code>PackedStackFrame</code> structures.  The first element in this
array corresponds to the stack frame that threw the exception.
The <code>PackedStackFrame</code> structure has the following definition:

<blockquote><pre>internal struct PackedStackFrame
{
    public RuntimeMethodHandle  method;
    public int                  offset;
    public int                  nativeOffset;
}</pre></blockquote>

This information can usually be collected very quickly, without having
to consult the reflection system to resolve method objects.  The exception
object caches this information until it is needed.<p>

Exception constructor calls can be recognised on the stack by looking
for methods called "<code>.ctor</code>" in a class that inherits from
<code>System.Exception</code>.  Because exception constructors normally
do not throw exceptions, this should be sufficient in most cases.<p>

If an exception constructor did throw an exception, it will appear to
have come from the method that threw the original exception.  The impact
of this is not serious, because stack frames are typically only used for
debug string output.
</blockquote>

<a name="Reflection"><h2>System.Reflection</h2>

The following sections describe the internalcall methods that must be
supplied by the runtime engine to implement reflection.  In many cases,
the runtime engine is expected to construct an object that represents
an underlying program construct.  e.g. an assembly, method, type, etc.<p>

The runtime engine can assume that all of the reflection classes that
it needs to instantiate have the following representation:<p>

<blockquote><pre>class Name
{
    private IntPtr privateData;
}
</pre></blockquote>

That is, the objects contain a single pointer field.  The runtime engine
is responsible for filling in this field with an appropriate value that
can be used to perform other reflection operations.  The engine must return
the same object for multiple requests for the same program construct.<p>

The engine is also responsible for checking the permissions of the caller
against the access levels of the program constructs.  For example, an
application cannot access a <code>private</code> member unless it is
in the application's assembly or the application has
<code>ReflectionPermission</code>.<p>

Permission checking proceeds as follows:

<ul>
	<li>The runtime engine searches up the call stack for a method
		that does not appear within the library assembly.  This is
		the "accessing method".</li>
	<li>If the accessing method does not have permission to access
		the reflected object, and the method does not have
		<code>ReflectionPermission</code>, then access is denied.</li>
	<li>If all of the methods on the call stack are within the
		system library assembly, then access is allowed.</li>
</ul>

Sometimes it is necessary for the system library to get private
access to the internals of an object even if the caller does not
have the necessary permissions.  The <code>ValueType</code> class
is one such example.<p>

The convention that we have adopted is that a method that needs
private access will have the <code>ClrReflection</code> attribute.
This attribute can only be used on methods within the system library
assembly.  It will be ignored on methods in other assemblies.<p>

<a name="Reflection_Assembly"><h3>System.Reflection.Assembly</h3>

<a name="Reflection_Assembly_GetCallingAssembly">
<pre>public static Assembly GetCallingAssembly();</pre>

<blockquote>
Get the assembly object that contains the method that called the method
that called <code>GetCallingAssembly</code>.
</blockquote>

<a name="Reflection_Assembly_GetExecutingAssembly">
<pre>public static Assembly GetExecutingAssembly();</pre>

<blockquote>
Get the assembly object that contains the method that called
<code>GetExecutingAssembly</code>.
</blockquote>

<a name="Reflection_Assembly_GetEntryAssembly">
<pre>public static Assembly GetEntryAssembly();</pre>

<blockquote>
Get the assembly object that contains the entry point method
for the application.
</blockquote>

<a name="Reflection_Assembly_GetExportedTypes">
<pre>public virtual Type[] GetExportedTypes();</pre>

<blockquote>
Return an array of all types that have been exported from the assembly.
</blockquote>

<a name="Reflection_Assembly_GetFile">
<pre>public virtual FileStream GetFile(String name);</pre>

<blockquote>
Description TBD.
</blockquote>

<a name="Reflection_Assembly_GetType">
<pre>public virtual Type GetType(String name, bool throwOnError, bool ignoreCase);</pre>

<blockquote>
Locate a specific type within the assembly and return it to the caller.
If <code>throwOnError</code> is <code>true</code>, then an exception should
be thrown if the type does not exist.  If <code>ignoreCase</code> is
<code>true</code>, then the name match is case-insensitive.<p>

Note: Microsoft's .NET framework requires that names of 128 or more
characters will cause <code>ignoreCase</code> to be ignored, and a
case-sensitive search to be performed regardless.
</blockquote>

<a name="Reflection_Assembly_GetTypes">
<pre>public virtual Type[] GetTypes();</pre>

<blockquote>
Get an array of all types within the assembly.  Note: the array will not
include types that the caller cannot access.
</blockquote>

<a name="Reflection_Assembly_LoadFromName">
<pre>private static Assembly LoadFromName(String name, out int error);</pre>

<blockquote>
Load an assembly given its base name.  e.g. "<code>System</code>".  The
exact file resolution algorithm used is system-dependent.  This method
returns <code>null</code> if an error occurs, with the reason for the
error returned in <code>error</code>:<p>
<ul>
	<li><code>LoadError_InvalidName</code>: the name string was invalid.
		The caller will have already checked for <code>null</code>, so
		it isn't necessary for the engine to handle this case.</li>
	<li><code>LoadError_FileNotFound</code>: the file containing the
		assembly could not be located.</li>
	<li><code>LoadError_BadImage</code>: there was something wrong with
		the assembly image.</li>
	<li><code>LoadError_Security</code>: the caller has insufficient
		security credentials to load the assembly.</li>
</ul>
</blockquote>

<a name="Reflection_Assembly_LoadFromFile">
<pre>private static Assembly LoadFromFile(String name, out int error);</pre>

<blockquote>
Load an assembly given its actual filename.  Unlike <code>LoadFromName</code>,
this will not perform name resolution.
</blockquote>

<a name="Reflection_ClrConstructor"><h3>System.Reflection.ClrConstructor</h3>

<a name="Reflection_ClrConstructor_Invoke">
<pre>public override Object Invoke(BindingFlags invokeAttr, Binder binder,
                              Object[] parameters, CultureInfo culture);</pre>

<blockquote>
Invoke this constructor with the specified parameters and return the
new object.
</blockquote>

<a name="Reflection_ClrField"><h3>System.Reflection.ClrField</h3>

<a name="Reflection_ClrField_GetValue">
<pre>public override Object GetValue(Object obj);</pre>

<blockquote>
Get the value of a field within a specified object.  The object will
be <code>null</code> for a static field.  If the field has an associated
literal, then this will return the value of the literal.
</blockquote>

<a name="Reflection_ClrField_SetValue">
<pre>public override void SetValue(Object obj, Object value);</pre>

<blockquote>
Set the value of a field within a specified object.  The object will
be <code>null</code> for a static field.
</blockquote>

<a name="Reflection_ClrField_GetFieldType">
<pre>private static Type GetFieldType(IntPtr item);</pre>

<blockquote>
Get the type of a field program item.  The <code>item</code> value will
be the same as the <code>privateData</code> member within the
<code>ClrField</code> class.
</blockquote>

<a name="Reflection_ClrField_GetValueDirect">
<pre>public override Object GetValueDirect(TypedReference obj);</pre>

<blockquote>
Get the value of a field within a specified object that is represented
as a typed reference.
</blockquote>

<a name="Reflection_ClrField_SetValueDirect">
<pre>public override void SetValueDirect(TypedReference obj, Object value);</pre>

<blockquote>
Set the value of a field within a specified object that is represented
as a typed reference.
</blockquote>

<a name="Reflection_ClrHelpers"><h3>System.Reflection.ClrHelpers</h3>

The <code>ClrHelpers</code> class contains a number of common methods
that are used across multiple program construct kinds.  These methods
take an <code>IntPtr</code> argument which corresponds to the
<code>privateData</code> field in the program construct's object.<p>

<a name="Reflection_ClrHelpers_GetCustomAttributes">
<pre>public static Object[] GetCustomAttributes(IntPtr item, IntPtr type, bool inherit);</pre>

<blockquote>
Get an array of all custom attributes on the specified <code>item</code>
that match the given <code>type</code>.  If <code>type</code> is zero,
then get all custom attributes irrespective of type.  If <code>inherit</code>
is <code>true</code>, then inspect ancestor classes in the inheritance
hierarchy for additional attributes.
</blockquote>

<a name="Reflection_ClrHelpers_IsDefined">
<pre>public static bool IsDefined(IntPtr item, IntPtr type, bool inherit);</pre>

<blockquote>
Determine if attributes of a specified type are defined on the program item.
</blockquote>

<a name="Reflection_ClrHelpers_GetDeclaringType">
<pre>public static IntPtr GetDeclaringType(IntPtr item);</pre>

<blockquote>
Get the <code>privateData</code> value for the type in which the
specified item member is declared.  The return value will be turned
into a <code>RuntimeTypeHandle</code> value, and then into a
<code>Type</code>.
</blockquote>

<a name="Reflection_ClrHelpers_GetName">
<pre>public static String GetName(IntPtr item);</pre>

<blockquote>
Get the name that is associated with a particular program item.
</blockquote>

<a name="Reflection_ClrHelpers_GetParameter">
<pre>public static IntPtr GetParameter(IntPtr item, int num);</pre>

<blockquote>
Get a parameter information block for a specific parameter on the
given method or property <code>item</code>.  The value <code>num</code>
will be zero to get information about the return type, and 1 for the
first parameter.  If there is no parameter information associated
with the parameter, this method should return zero.
</blockquote>

<a name="Reflection_ClrHelpers_GetParameterType">
<pre>public static Type GetParameterType(IntPtr item, int num);</pre>

<blockquote>
Get a parameter type for a specific parameter on the given method or
property <code>item</code>.  The value <code>num</code> will be zero
to get information about the return type, or 1 for the first parameter.
</blockquote>

<a name="Reflection_ClrHelpers_GetNumParameters">
<pre>public static int GetNumParameters(IntPtr item);</pre>

<blockquote>
Get the number of parameters that are declared for the specified
method or property <code>item</code>.
</blockquote>

<a name="Reflection_ClrHelpers_GetMemberAttrs">
<pre>public static int GetMemberAttrs(IntPtr item);</pre>

<blockquote>
Get the attribute flags that are associated with a specific type member
item (field, method, event, or property).
</blockquote>

<a name="Reflection_ClrHelpers_GetCallConv">
<pre>public static CallingConventions GetCallConv(IntPtr item);</pre>

<blockquote>
Get the calling conventions for a specified method <code>item</code>.
</blockquote>

<a name="Reflection_ClrHelpers_GetImplAttrs">
<pre>public static MethodImplAttributes GetImplAttrs(IntPtr item);</pre>

<blockquote>
Get the method implementation attributes that are associated with
a specific method <code>item</code>.
</blockquote>

<a name="Reflection_ClrHelpers_GetSemantics">
<pre>public static MethodInfo GetSemantics
           (IntPtr item, MethodSemanticsAttributes type, bool nonPublic);</pre>

<blockquote>
Get the method that corresponds to a particular semantics <code>type</code>
and on event or property <code>item</code>.  The return value will typically
be an instance of <code>ClrMethod</code>.  If <code>nonPublic</code> is
<code>false</code>, then only return public semantics methods.<p>

Note: this method may return <code>null</code> if the method is not
accessible to the caller due to permissions issues.
</blockquote>

<a name="Reflection_ClrHelpers_HasSemantics">
<pre>public static bool HasSemantics
           (IntPtr item, MethodSemanticsAttributes type, bool nonPublic);</pre>

<blockquote>
Determine if the event or property <code>item</code> has the specified
method semantics <code>type</code>.  If <code>nonPublic</code> is
<code>false</code>, then only return public semantics methods.
</blockquote>

<a name="Reflection_ClrHelpers_CanAccess">
<pre>public static bool CanAccess(IntPtr item);</pre>

<blockquote>
Determine if the caller has sufficient permissions to access the
specified program item (type, field, constructor, method, event,
or property).  This is used by the library to check an item that
was obtained previously and cached, but which may not be accessible
in the context in which it is now used.
</blockquote>

<a name="Reflection_ClrMethod"><h3>System.Reflection.ClrMethod</h3>

<a name="Reflection_ClrMethod_Invoke">
<pre>public override Object Invoke(Object obj, BindingFlags invokeAttr, Binder binder,
                              Object[] parameters, CultureInfo culture);</pre>

<blockquote>
Invoke this method with the specified parameters and return the result.
</blockquote>

<a name="Reflection_ClrMethod_GetBaseDefinition">
<pre>private static MethodInfo GetBaseDefinition(IntPtr handle);</pre>

<blockquote>
If the specified method is virtual, then find the base definition in
the parent class or in an ancestor class.  Returns <code>null</code>
if no suitable method found.
</blockquote>

<a name="Reflection_ClrParameter"><h3>System.Reflection.ClrParameter</h3>

<a name="Reflection_ClrParameter_GetParamAttrs">
<pre>private static ParameterAttributes GetParamAttrs(IntPtr item);</pre>

<blockquote>
Get the attributes for a specified parameter <code>item</code>.  This
value is from a previous call to <code>ClrHelpers.GetParameter</code>.
</blockquote>

<a name="Reflection_ClrParameter_GetParamType">
<pre>private static String GetParamName(IntPtr item);</pre>

<blockquote>
Get the name that is associated with a specified parameter <code>item</code>.
Returns <code>null</code> if the parameter does not have a name.
</blockquote>

<a name="Reflection_ClrParameter_GetDefault">
<pre>private static Object GetDefault(IntPtr item);</pre>

<blockquote>
Get the default value that is associated with a specified parameter
<code>item</code>.  Returns <code>null</code> if the parameter does
not have a default value.
</blockquote>

<a name="Reflection_ClrProperty"><h3>System.Reflection.ClrProperty</h3>

<a name="Reflection_ClrEvent_GetPropertyType">
<pre>private static Type GetPropertyType(IntPtr item);</pre>

<blockquote>
Get the type of a property program item.  The <code>item</code> value will
be the same as the <code>privateData</code> member within the
<code>ClrProperty</code> class.
</blockquote>

<a name="Reflection_ClrType"><h3>System.Reflection.ClrType</h3>

<a name="Reflection_ClrType_GetClrArrayRank">
<pre>private int GetClrArrayRank();</pre>

<blockquote>
Get the rank of this array type.  If the type is not an array, this
should return zero.
</blockquote>

<a name="Reflection_ClrType_GetAttributeFlagsImpl">
<pre>protected override TypeAttributes GetAttributeFlagsImpl();</pre>

<blockquote>
Get the attribute flags for this type.
</blockquote>

<a name="Reflection_ClrType_GetElementType">
<pre>public override Type GetElementType();</pre>

<blockquote>
Get the element type if this type is an array, pointer, or byref.
Returns <code>null</code> otherwise.
</blockquote>

<a name="Reflection_ClrType_GetInterface">
<pre>public override Type GetInterface(String name, bool ignoreCase);</pre>

<blockquote>
Get a particular interface that this type implements.  Returns
<code>null</code> if the type does not implement the interface,
or the interface is inaccessible due to permission issues.<p>

If the name is 128 or more characters in length, then
<code>ignoreCase</code> is itself ignored.  This is a requirement
of Microsoft's .NET Framework.
</blockquote>

<a name="Reflection_ClrType_GetInterfaces">
<pre>public override Type[] GetInterfaces();</pre>

<blockquote>
Get an array of all interfaces that this type implements.  The runtime
engine will exclude interfaces that are not accessible to the caller
due to permission issues.
</blockquote>

<a name="Reflection_ClrType_GetMemberImpl">
<pre>private MemberInfo GetMemberImpl(String name, MemberTypes memberTypes,
                                 BindingFlags bindingAttr, Binder binder,
                                 CallingConventions callingConventions,
                                 Type[] types, ParameterModifier[] modifiers);</pre>

<blockquote>
Search the type for a member that matches the specified conditions.
This method is called for any kind of type member: methods, constructors,
fields, events, properties, or nested types.  The <code>memberTypes</code>
parameter is a bitmask that specifies the kinds of members that should
be inspected.  The other parameters provide information to further narrow
the search.<p>

This method returns the member, <code>null</code>, or throws an
<code>AmbiguousMatchException</code> if there is more than one member
that matches the specified conditions.  The returned member will usually be
an instance of <code>ClrMethod</code>, <code>ClrConstructor</code>,
<code>ClrField</code>, <code>ClrEvent</code>, <code>ClrProperty</code>,
or <code>ClrType</code>.
</blockquote>

<a name="Reflection_ClrType_GetMembersImpl">
<pre>private Object GetMembersImpl(MemberTypes memberTypes,
                              BindingFlags bindingAttr,
                              Type arrayType, String name);</pre>

<blockquote>
Get an array of all members that match the specified conditions.
The <code>memberTypes</code> parameter indicates the kind of members
that should be returned.  If <code>name</code> is not <code>null</code>,
then only return members with the given name.<p>

The <code>arrayType</code> parameter indicates the type of the array to
be created.  This is normally one of <code>MemberInfo[]</code>,
<code>MethodInfo[]</code>, <code>ConstructorInfo[]</code>,
<code>FieldInfo[]</code>, <code>EventInfo[]</code>,
<code>PropertyInfo[]</code>, or <code>Type[]</code>, depending
upon the type of lookup that is being performed.
</blockquote>

<a name="Reflection_ClrType_GetClrTypeCategory">
<pre>private ClrTypeCategory GetClrTypeCategory();</pre>

<blockquote>
Get the category value for this type.  Array, pointer, etc.  See the
<code>ClrTypeCategory</code> enumeration for a list of values.
</blockquote>

<a name="Reflection_ClrType_IsSubclassOf">
<pre>private bool IsSubclassOf(Type c);</pre>

<blockquote>
Determine if this type is a subclass of <code>c</code>.
</blockquote>

<a name="Reflection_ClrType_IsClrNestedType">
<pre>private bool IsClrNestedType();</pre>

<blockquote>
Determine if this type is nested within another type.
</blockquote>

<a name="Reflection_ClrType_GetClrAssembly">
<pre>private Assembly GetClrAssembly();</pre>

<blockquote>
Get the assembly that this type is a member of.
</blockquote>

<a name="Reflection_ClrType_GetClrBaseType">
<pre>private Type GetClrBaseType();</pre>

<blockquote>
Get the base type for this type, or <code>null</code> if it has no
base type (i.e. <code>System.Object</code>).
</blockquote>

<a name="Reflection_ClrType_GetClrFullName">
<pre>private String GetClrFullName();</pre>

<blockquote>
Get the full name of this type, including name, namespace, and suffixes
that indicate arrays, pointers, etc.
</blockquote>

<a name="Reflection_ClrType_GetClrGUID">
<pre>private Guid GetClrGUID();</pre>

<blockquote>
Get the GUID value for this type.  If the runtime engine does not
support GUID's, then it should return a value that is cleared to
all-zeroes.
</blockquote>

<a name="Reflection_ClrType_GetClrModule">
<pre>private Module GetClrModule();</pre>

<blockquote>
Get the module that this type is a member of.
</blockquote>

<a name="Reflection_ClrType_GetClrNestedDeclaringType">
<pre>private Type GetClrNestedDeclaringType();</pre>

<blockquote>
Get the declaring type that contains this type if it is nested.
Returns <code>null</code> if the type is not nested.
</blockquote>

<a name="Reflection_ClrType_GetClrName">
<pre>private String GetClrName();</pre>

<blockquote>
Get this type's name.
</blockquote>

<a name="Reflection_ClrType_GetClrNamespace">
<pre>private String GetClrNamespace();</pre>

<blockquote>
Get this type's namespace.
</blockquote>

<a name="Reflection_FieldInfo"><h3>System.Reflection.FieldInfo</h3>

<a name="Reflection_FieldInfo_GetFieldFromHandle">
<pre>public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle);</pre>

<blockquote>
Get a field object given its handle.  This will typically return an
instance of <code>ClrField</code>.
</blockquote>

<a name="Reflection_MethodBase"><h3>System.Reflection.MethodBase</h3>

<a name="Reflection_MethodBase_GetMethodFromHandle">
<pre>public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle);</pre>

<blockquote>
Get a method object given its handle.  This will typically return an
instance of either <code>ClrMethod</code> or <code>ClrConstructor</code>.
</blockquote>

<a name="Reflection_MethodBase_GetCurrentMethod">
<pre>public static MethodBase CurrentMethod();</pre>

<blockquote>
Get the current method that called <code>GetCurrentMethod</code>.
</blockquote>

<a name="Reflection_Module"><h3>System.Reflection.Module</h3>

<a name="Reflection_Module_GetType">
<pre>public virtual Type GetType(String name, bool throwOnError, bool ignoreCase);</pre>

<blockquote>
Locate a specific type within the module and return it to the caller.
If <code>throwOnError</code> is <code>true</code>, then an exception should
be thrown if the type does not exist.  If <code>ignoreCase</code> is
<code>true</code>, then the name match is case-insensitive.<p>

Note: Microsoft's .NET framework requires that names of 128 or more
characters will cause <code>ignoreCase</code> to be ignored, and a
case-sensitive search to be performed regardless.
</blockquote>

<a name="Reflection_Module_GetTypes">
<pre>public virtual Type[] GetTypes();</pre>

<blockquote>
Get an array of all types in this module.
</blockquote>

<a name="Reflection_Module_IsResource">
<pre>public bool IsResource();</pre>

<blockquote>
Determine if this module only contains resources.
</blockquote>

<a name="Reflection_Module_GetModuleType">
<pre>internal virtual Type GetModuleType();</pre>

<blockquote>
Get the type information object for the global "<code>&lt;Module&gt;</code>"
type within the module.
</blockquote>

<a name="Reflection_Module_GetAssembly">
<pre>private Assembly GetAssembly();</pre>

<blockquote>
Get the assembly that this module resides in.
</blockquote>

<a name="Reflection_Module_GetAssembly">
<pre>private String GetFullName();</pre>

<blockquote>
Get the full name of the module.
</blockquote>

<a name="System_Runtime"><h2>System.Runtime</h2>

<a name="CompilerServices_RuntimeHelpers"><h3>System.Runtime.CompilerServices.RuntimeHelpers</h3>

<a name="CompilerServices_RuntimeHelpers_InitializeArray">
<pre>public static void InitializeArray(Array array, RuntimeFieldHandle field);</pre>

<blockquote>
Initialize the contents of a primitive array from the contents of an
RVA-based field.
</blockquote>

<a name="CompilerServices_RuntimeHelpers_RunClassConstructor">
<pre>public static void RunClassConstructor(RuntimeTypeHandle type);</pre>

<blockquote>
Run the static class constructor for a specified type.  The CLR may provide
a facility to mark a class constructor once it has been executed so that
subsequent calls to this method will do nothing.
</blockquote>

<a name="CompilerServices_RuntimeHelpers_InternalOffsetToStringData">
<pre>public static int InternalOffsetToStringData();</pre>

<blockquote>
Returns the offset from the start of an object of the
<code>String.firstChar</code> field on the current platform.  This is
provided as an internalcall method because different systems may
layout the <code>System.String</code> class differently.
</blockquote>

<a name="CompilerServices_RuntimeHelpers_GetObjectValue">
<pre>public static Object GetObjectValue(Object value);</pre>

<blockquote>
Box the specified <code>value</code> and return it as an object.
If the object is already boxed, return <code>value</code>.<p>

Note: in the current system, it is impossible to construct an object
that isn't already boxed, so it is unclear what this is supposed to
achieve other than always returning <code>value</code>.  It is provided
for compatibility with the Microsoft .NET Framework.
</blockquote>

<a name="InteropServices_GCHandle"><h3>System.Runtime.InteropServices.GCHandle</h3>

<a name="InteropServices_GCHandle_GCAddrOfPinnedObject">
<pre>private static IntPtr GCAddrOfPinnedObject(int handle);</pre>

<blockquote>
Get the physical address that is associated with a pinned GC object handle.
</blockquote>

<a name="InteropServices_GCHandle_GCAlloc">
<pre>private static int GCAlloc(Object value, GCHandleType type);</pre>

<blockquote>
Allocate a new GC object handle for the specified value and type.
</blockquote>

<a name="InteropServices_GCHandle_GCAlloc">
<pre>private static void GCFree(int handle);</pre>

<blockquote>
Free a GC object handle that is no longer required.
</blockquote>

<a name="InteropServices_GCHandle_GCValidate">
<pre>private static bool GCValidate(int handle);</pre>

<blockquote>
Validate a GC object handle.  Returns <code>false</code> if the handle
has been free'd or it was never allocated as a GC object.
</blockquote>

<a name="InteropServices_GCHandle_GCGetTarget">
<pre>private static Object GCGetTarget(int handle);</pre>

<blockquote>
Get the target object that is associated with a GC object handle.
</blockquote>

<a name="InteropServices_GCHandle_GCSetTarget">
<pre>private static void GCGetTarget(int handle, Object value, bool isPinned);</pre>

<blockquote>
Set the target that is associated with a GC object handle and
optionally pin it.
</blockquote>

<a name="System_Text"><h2>System.Text</h2>

<a name="System_Text_DefaultEncoding"><h3>System.Text.DefaultEncoding</h3>

The <code>System.Text.DefaultEncoding</code> class implements the default
character set encoding on the underlying platform.  The CLR is responsible
for converting between the default encoding and Unicode by providing
the facilities in this class.  The CLR can assume that the arguments to
the following methods have been fully validated.<p>

<a name="System_Text_DefaultEncoding_InternalGetByteCount">
<pre>private static int InternalGetByteCount(char[] chars, int index, int count);</pre>

<blockquote>
Get the number of bytes in the default encoding that are required to encode
the characters in the specified range of the <code>chars</code> array.
</blockquote>

<a name="System_Text_DefaultEncoding_InternalGetByteCount">
<pre>private static int InternalGetByteCount(String s, int index, int count);</pre>

<blockquote>
Get the number of bytes in the default encoding that are required to encode
the characters in the specified range of the <code>s</code> string.
</blockquote>

<a name="System_Text_DefaultEncoding_InternalGetBytes">
<pre>private static int InternalGetBytes(char[] chars, int charIndex, int charCount,
                                    byte[] bytes, int byteIndex);</pre>

<blockquote>
Get the bytes in the default encoding that correspond to the characters
in the specified range of the <code>chars</code> array.  The bytes
are written to the array <code>bytes</code>, starting at
<code>byteIndex</code>.  The number of bytes written is returned
from the method.  If insufficient space is available in the <code>bytes</code>
array for the bytes, then this method should return -1.
</blockquote>

<a name="System_Text_DefaultEncoding_InternalGetBytes_2">
<pre>private static int InternalGetBytes(String s, int charIndex, int charCount,
                                    byte[] bytes, int byteIndex);</pre>

<blockquote>
Get the bytes in the default encoding that correspond to the characters
in the specified range of the <code>s</code> string.  The bytes
are written to the array <code>bytes</code>, starting at
<code>byteIndex</code>.  The number of bytes written is returned
from the method.  If insufficient space is available in the <code>bytes</code>
array for the bytes, then this method should return -1.
</blockquote>

<a name="System_Text_DefaultEncoding_InternalGetCharCount">
<pre>private static int InternalGetCharCount(byte[] bytes, int index, int count);</pre>

<blockquote>
Get the number of characters that are required to decode the specified
range of bytes from the <code>bytes</code> array.
</blockquote>

<a name="System_Text_DefaultEncoding_InternalGetChars">
<pre>private static int InternalGetChars(byte[] bytes, int byteIndex, int byteCount,
                                    char[] chars, int charIndex);</pre>

<blockquote>
Convert the characters in the default encoding into Unicode characters
from the specified range of the <code>bytes</code> array.  The characters
are written to the array <code>chars</code>, starting at
<code>charIndex</code>.  The number of characters written is returned
from the method.  If insufficient space is available in the <code>chars</code>
array for the characters, then this method should return -1.
</blockquote>

<a name="System_Text_DefaultEncoding_InternalGetMaxByteCount">
<pre>private static int InternalGetMaxByteCount(int charCount);</pre>

<blockquote>
Get the maximum number of bytes of buffer space that may be required
to convert <code>charCount</code> characters into the default encoding.
</blockquote>

<a name="System_Text_DefaultEncoding_InternalGetMaxCharCount">
<pre>private static int InternalGetMaxCharCount(int byteCount);</pre>

<blockquote>
Get the maximum number of characters of buffer space that may be required
to convert <code>byteCount</code> bytes from the default encoding.
</blockquote>

<a name="System_Text_DefaultEncoding_InternalGetString">
<pre>private static String InternalGetString(byte[] bytes, int index, int count);</pre>

<blockquote>
Convert the specified range of bytes within the <code>bytes</code> array
into a string.
</blockquote>

<a name="System_Threading"><h2>System.Threading</h2>

<a name="Threading_Interlocked"><h3>System.Threading.Interlocked</h3>

The <code>System.Threading.Interlocked</code> class provides a number
of methods for performing atomic operations in a multi-threaded environment.
The CLR must perform these operations in an atomic manner.

<a name="Threading_Interlocked_CompareExchange">
<pre>public static int CompareExchange(ref int location1, int value, int comparand);
public static float CompareExchange(ref float location1, float value, float comparand);
public static Object CompareExchange(ref Object location1, Object value, Object comparand);</pre>

<blockquote>
Compare the contents of <code>location1</code> with <code>comparand</code>.
If they are the same, then write <code>value</code> to that location and
return the original value of <code>location1</code> from the method.
Otherwise return the value of <code>location1</code>.
</blockquote>

<a name="Threading_Interlocked_Decrement">
<pre>public static int Decrement(ref int location);
public static long Decrement(ref long location);</pre>

<blockquote>
Decrement the contents of <code>location</code> and return its new value.
</blockquote>

<a name="Threading_Interlocked_Exchange">
<pre>public static int Exchange(ref int location1, int value);
public static float Exchange(ref float location1, float value);
public static Object Exchange(ref Object location1, Object value);</pre>

<blockquote>
Exchange the contents of <code>location1</code> with <code>value</code>
and return the original value of <code>location1</code>.
</blockquote>

<a name="Threading_Interlocked_Increment">
<pre>public static int Increment(ref int location);
public static long Increment(ref long location);</pre>

<blockquote>
Increment the contents of <code>location</code> and return its new value.
</blockquote>

<a name="Threading_Monitor"><h3>System.Threading.Monitor</h3>

<a name="Threading_Monitor_Enter">
<pre>public static void Enter(Object obj);</pre>

<blockquote>
Enter a monitor on an object.  If the system is single-threaded,
this does nothing because there are no other threads to block
the operation.
</blockquote>

<a name="Threading_Monitor_InternalTryEnter">
<pre>public static bool InternalTryEnter(Object obj, int timeout);</pre>

<blockquote>
Try to enter a monitor, with a specified timeout in milliseconds.
A timeout value of -1 means "wait indefinitely", and a value of 0
means "test and return immediately".  Returns <code>true</code>
if the monitor was successfully entered.  If the system is
single-threaded, this always returns <code>true</code> because
there are no other threads to block the operation.
</blockquote>

<a name="Threading_Monitor_Exit">
<pre>public static void Exit(Object obj);</pre>

<blockquote>
Exit from a monitor on an object.  If the system is single-threaded,
this does nothing.
</blockquote>

<a name="Threading_Monitor_InternalWait">
<pre>public static bool InternalWait(Object obj, int timeout);</pre>

<blockquote>
Release the monitor lock on an object and wait for a pulse to
reawaken the current thread.  A timeout value of -1 means
"wait indefinitely", and a value of 0 means "test and return
immediately".  Returns <code>false</code> if the timeout expired.
The timeout is in milliseconds.<p>

If the system is single-threaded, this method will always return
<code>false</code>.  Using <code>Wait</code>, <code>Pulse</code>,
and <code>PulseAll</code> in a single-threaded environment is
not recommended.
</blockquote>

<a name="Threading_Monitor_Pulse">
<pre>public static void Pulse(Object obj);</pre>

<blockquote>
Notify the next waiting thread on a monitor that it can wake up and
reacquire the monitor lock.  If the system is single-threaded, then
this method does nothing.
</blockquote>

<a name="Threading_Monitor_PulseAll">
<pre>public static void PulseAll(Object obj);</pre>

<blockquote>
Notify all waiting threads on a monitor that they can wake up and
reacquire the monitor lock.  If the system is single-threaded, then
this method does nothing.
</blockquote>

<a name="Threading_Mutex"><h3>System.Threading.Mutex</h3>

<a name="Threading_Mutex_InternalCreateMutex">
<pre>private static IntPtr InternalCreateMutex(bool initiallyOwned, String name, out bool gotOwnership);</pre>

<blockquote>
Create a CLR mutex object and return a handle for it.
If <code>initiallyOwned</code> is <code>true</code>, then
acquire the ownership of the mutex for the current thread.
If <code>name</code> is not <code>null</code>, then the
mutex is attached to the specified name.  The <code>gotOwnership</code>
parameter will be set to <code>true</code> if ownership of the
mutex could be initially acquired.  The returned value must be
usable as a <code>WaitHandle</code>.
</blockquote>

<a name="Threading_Mutex_InternalReleaseMutex">
<pre>private static void InternalReleaseMutex(IntPtr mutex);</pre>

<blockquote>
Release a mutex that was previously acquired with a <code>Wait</code>
operation.
</blockquote>

<a name="Threading_Thread"><h3>System.Threading.Thread</h3>

The CLR can assume that the <code>Thread</code> class starts with the
following fields:

<blockquote><pre>public sealed class Thread
{
    private IntPtr privateData;
    private Object stateInfo;
    private ThreadStart start;
    private String name;
}</pre></blockquote>

There may be other fields besides these, but these will always be present
at the start of the object in the specified order.<p>

<a name="Threading_Thread_FinalizeThread">
<pre>private void FinalizeThread();</pre>

<blockquote>
This method is called when the <code>Thread</code> object is collected
by the garbage collector.  If the thread is still active, it should
be shut down.
</blockquote>

<a name="Threading_Thread_Abort">
<pre>public void Abort();</pre>

<blockquote>
Abort this thread.
</blockquote>

<a name="Threading_Thread_InternalJoin">
<pre>private void InternalJoin(int timeout);</pre>

<blockquote>
Attempt to join the executing thread with the thread represented
by this thread object.  A timeout value of -1 indicates "wait
indefinitely" and a timeout value of 0 indicates "test and return
immediately".  The timeout value is in milliseconds.
</blockquote>

<a name="Threading_Thread_MemoryBarrier">
<pre>public static void MemoryBarrier();</pre>

<blockquote>
Insert a memory barrier at this point in thread execution, to ensure
that all pending memory loads and stores will be flushed.
</blockquote>

<a name="Threading_Thread_ResetAbort">
<pre>public static void ResetAbort();</pre>

<blockquote>
Reset the pending abort on the current thread.
</blockquote>

<a name="Threading_Thread_InternalSleep">
<pre>private static void InternalSleep(int timeout);</pre>

<blockquote>
Put the current thread to sleep for a certain period of time.
A timeout value of -1 indicates that the thread should be put
to sleep forever (or at least until it is aborted).  A timeout
value of 0 indicates that control should return the thread
immediately, perhaps after yielding a timeslice.
</blockquote>

<a name="Threading_Thread_Start">
<pre>public void Start();</pre>

<blockquote>
Start execution of the thread represented by <code>this</code>.
</blockquote>

<a name="Threading_Thread_VolatileRead">
<pre>public static byte VolatileRead(ref byte address);
public static sbyte VolatileRead(ref sbyte address);
public static short VolatileRead(ref short address);
public static ushort VolatileRead(ref ushort address);
public static int VolatileRead(ref int address);
public static uint VolatileRead(ref uint address);
public static long VolatileRead(ref long address);
public static ulong VolatileRead(ref ulong address);
public static IntPtr VolatileRead(ref IntPtr address);
public static UIntPtr VolatileRead(ref UIntPtr address);
public static float VolatileRead(ref float address);
public static double VolatileRead(ref double address);
public static Object VolatileRead(ref Object address);</pre>

<blockquote>
Read a value from a specific address in such a way that the value
will be treated as volatile.  This method will ensure that the
operation is performed atomically with respect to volatile writes
to the same address.
</blockquote>

<a name="Threading_Thread_VolatileWrite">
<pre>public static void VolatileWrite(ref byte address, byte value);
public static void VolatileWrite(ref sbyte address, sbyte value);
public static void VolatileWrite(ref short address, short value);
public static void VolatileWrite(ref ushort address, ushort value);
public static void VolatileWrite(ref int address, int value);
public static void VolatileWrite(ref uint address, uint value);
public static void VolatileWrite(ref long address, long value);
public static void VolatileWrite(ref ulong address, ulong value);
public static void VolatileWrite(ref IntPtr address, IntPtr value);
public static void VolatileWrite(ref UIntPtr address, UIntPtr value);
public static void VolatileWrite(ref float address, float value);
public static void VolatileWrite(ref double address, double value);
public static void VolatileWrite(ref Object address, Object value);</pre>

<blockquote>
Read a value to a specific address in such a way that the value
will be treated as volatile.  This method will ensure that the
operation is performed atomically with respect to volatile reads
from the same address.
</blockquote>

<a name="Threading_Thread_InternalCurrentThread">
<pre>private static Thread InternalCurrentThread();</pre>

<blockquote>
Get the object that represents the currently executing thread.
</blockquote>

<a name="Threading_Thread_InternalSetBackground">
<pre>private void InternalSetBackground(bool value);</pre>

<blockquote>
Set the background state of the thread.  The program will exit when
all non-background threads have terminated.  Setting a thread to
background prevents it from keeping the program alive when the
"main" thread exits.
</blockquote>

<a name="Threading_Thread_InternalGetPriority">
<pre>private ThreadPriority InternalGetPriority();</pre>

<blockquote>
Get the priority of the thread.
</blockquote>

<a name="Threading_Thread_InternalSetPriority">
<pre>private void InternalSetPriority(ThreadPriority value);</pre>

<blockquote>
Set the priority of the thread to <code>value</code>.
</blockquote>

<a name="Threading_Thread_InternalGetState">
<pre>private ThreadState InternalGetState();</pre>

<blockquote>
Get the current state of the thread.  i.e. Running, Stopped, Waiting,
Background, etc.
</blockquote>

<a name="Threading_WaitHandle"><h3>System.Threading.WaitHandle</h3>

The <code>WaitHandle</code> class is the base for a number of different
"waiting objects" within the library, including <code>Mutex</code>.
The CLR can assume that the field definition of this class is as follows:

<blockquote><pre>public abstract class WaitHandle
{
    private IntPtr privateData;
}</pre></blockquote>

The <code>privateData</code> field holds a pointer to a CLR-specific
handle that represents the wait object.<p>

<a name="Threading_WaitHandle_InternalClose">
<pre>private static void InternalClose(IntPtr privateData);</pre>

<blockquote>
Close a CLR wait object.
</blockquote>

<a name="Threading_WaitHandle_InternalWaitAll">
<pre>private static bool InternalWaitAll(WaitHandle[] waitHandles, int timeout,
                                    bool exitContext);</pre>

<blockquote>
Wait until all handles in an array become active.  The CLR can assume
that the parameters have been validated.  A timeout value of -1 indicates
"wait indefinitely" and a timeout value of 0 indicates "test and return
immediately".  Returns <code>true</code> if any of the handles have
become active, or <code>false</code> if a timeout occurred.  The timeout
is in milliseconds.
</blockquote>

<a name="Threading_WaitHandle_InternalWaitAny">
<pre>private static int InternalWaitAny(WaitHandle[] waitHandles, int timeout,
                                   bool exitContext);</pre>

<blockquote>
Wait until any handle in an array become active.  The CLR can assume
that the parameters have been validated.  A timeout value of -1 indicates
"wait indefinitely" and a timeout value of 0 indicates "test and return
immediately".  Returns the index of the handle that became active,
or -1 if a timeout occurred.  The timeout is in milliseconds.
</blockquote>

<a name="Threading_WaitHandle_InternalWaitOne">
<pre>private static bool InternalWaitOne(IntPtr privateData, int timeout);</pre>

<blockquote>
Wait until a particular handle becomes active.  A timeout value of -1
indicates "wait indefinitely" and a timeout value of 0 indicates
"test and return immediately".  Returns <code>true</code> if the handle
became active, or <code>false</code> if a timeout occurred.  The timeout
is in milliseconds.
</blockquote>

<a name="Platform"><h2>Platform</h2>

<a name="Platform_DirMethods"><h3>Platform.DirMethods</h3>

This class contains directory manipulation functions for the filesystem.<p>

<a name="Platform_DirMethods_GetPathInfo">
<pre>public static PathInfo GetPathInfo();</pre>

<blockquote>
Retrieves path character information from the runtime engine.
i.e. the separators to be used for directories, PATH's, etc.
The following is the definition of <code>Platform.PathInfo</code>:

<pre>
struct PathInfo
{
    public char   dirSeparator;
    public char   altDirSeparator;
    public char   volumeSeparator;
    public char   pathSeparator;
    public char[] invalidPathChars;
}
</pre>

The fields have the following meaning:

<dl>
<dt><code>dirSeparator</code></dt>
<dd>The primary directory separator to use on this platform.  Usually
	<code>'/'</code> for Unix systems and <code>'\'</code> for Windows
	systems.  This must be set to a non-zero value.</dd>

<dt><code>altDirSeparator</code></dt>
<dd>The alternative directory separator to use on this platform.
	Usually <code>0</code> for Unix systems and <code>'/'</code>
	for Windows systems.  The value <code>0</code> is used to indicate
	that there is no alternative directory separator.</dd>

<dt><code>volumeSeparator</code></dt>
<dd>The separator to use for volume names.  Usually <code>0</code>
    for Unix systems and <code>':'</code> for Windows systems.
	The value <code>0</code> is used to indicate that there is no
	volume separator.</dd>

<dt><code>pathSeparator</code></dt>
<dd>The separator to use for PATH values.  Usually <code>':'</code>
    for Unix systems and <code>';'</code> for Windows systems.
	This must be set to a non-zero value.</dd>

<dt><code>invalidPathChars</code></dt>
<dd>An array of characters that are invalid to use within pathnames on
	this system.  An empty array or <code>null</code> indicates that
	all characters are valid, with special meanings only for the
	separator characters listed above.</dd>
</dl>
</blockquote>

<a name="Platform_DirMethods_GetSystemDirectory">
<pre>public static String GetSystemDirectory();</pre>

<blockquote>
Get the full pathname of the "System" directory on this machine.
This is highly Windows-specific.  If the platform does not have
such a directory, this method should return <code>null</code>.
</blockquote>

<a name="Platform_FileMethods"><h3>Platform.FileMethods</h3>

The <code>FileMethods</code> class provides a number of primitive methods
for accessing raw binary file streams within the underlying operating
system's filespace.<p>

<a name="Platform_FileMethods_GetInvalidHandle">
<pre>public static IntPtr GetInvalidHandle();</pre>

<blockquote>
Get a value that represents an invalid operating system file handle.
Usually this is some sentinel value such as 0 or -1, coerced to
<code>IntPtr</code>.  It can be any value, as long as it is not
possible to encounter a legitimate file handle with this value.
</blockquote>

<a name="Platform_FileMethods_ValidatePathname">
<pre>public static bool ValidatePathname(String path);</pre>

<blockquote>
Validate that the supplied pathname is legitimate according to
the underlying filesystem's pathname rules.
</blockquote>

<a name="Platform_FileMethods_Open">
<pre>public static bool Open(String path, FileMode mode, FileAccess access,
                        FileShare share, out IntPtr handle);</pre>

<blockquote>
Attempt to open a file with the specified mode, access, and sharing flags.
If the file could be opened, a handle is returned in <code>handle</code>,
and the method returns <code>true</code>.  If the file could not be
opened, the method returns <code>false</code>, and <code>GetErrno</code>
should be consulted to determine the reason for the failure.
</blockquote>

<a name="Platform_FileMethods_HasAsync">
<pre>public static bool HasAsync();</pre>

<blockquote>
Determine if the system has support for asynchronous file handle operations.
</blockquote>

<a name="Platform_FileMethods_CanSeek">
<pre>public static bool CanSeek(IntPtr handle);</pre>

<blockquote>
Determine if it is possible to seek on the specified file handle.
This method must leave the current file position unchanged.
</blockquote>

<a name="Platform_FileMethods_CheckHandleAccess">
<pre>public static bool CheckHandleAccess(IntPtr handle, FileAccess access);</pre>

<blockquote>
Check to see if an existing file handle was opened for the specified access.
</blockquote>

<a name="Platform_FileMethods_Seek">
<pre>public static long Seek(IntPtr handle, long offset, SeekOrigin origin);</pre>

<blockquote>
Seek to a particular position on a file handle.  Returns -1 if the offset
is out of range, or an error occurred.  Consult <code>GetErrno</code>
for the reason for the error.
</blockquote>

<a name="Platform_FileMethods_Write">
<pre>public static bool Write(IntPtr handle, byte[] buffer, int offset, int count);</pre>

<blockquote>
Write the contents of a buffer to a file handle.  Returns false if
an I/O error occurred.  Consult <code>GetErrno</code> for the reason for
an I/O error.
</blockquote>

<a name="Platform_FileMethods_Read">
<pre>public static int Read(IntPtr handle, byte[] buffer, int offset, int count);</pre>

<blockquote>
Read data from a file handle into a supplied buffer.  Returns -1 in
an I/O error occurred, 0 at end of file, or the number of bytes
read otherwise.  Console <code>GetErrno</code> for the reason for
an I/O error.
</blockquote>

<a name="Platform_FileMethods_Close">
<pre>public static bool Close(IntPtr handle);</pre>

<blockquote>
Close a particular file handle.  Returns <code>false</code> if an
I/O error occurred.  Consult <code>GetErrno</code> for the reason
for an I/O error.
</blockquote>

<a name="Platform_FileMethods_FlushWrite">
<pre>public static bool FlushWrite(IntPtr handle);</pre>

<blockquote>
Flush all data that was previously written to a file handle,
in response to a user-level "Flush" request.  Normally thi will
do nothing unless the platform provides its own buffering.
Returns <code>false</code> if an I/O error occurred.
Consult <code>GetErrno</code> for the reason for an I/O error.
</blockquote>

<a name="Platform_FileMethods_SetLength">
<pre>public static bool SetLength(IntPtr handle, long value);</pre>

<blockquote>
Set the length of a file to a new value.  Returns <code>false</code>
if an I/O error occurred.  Consult <code>GetErrno</code> for the
reason for an I/O error.
</blockquote>

<a name="Platform_FileMethods_GetErrno">
<pre>public static Errno GetErrno();</pre>

<blockquote>
Get the last-occurring system error code for the currently
executing thread.
</blockquote>

<a name="Platform_FileMethods_GetErrnoMessage">
<pre>public static String GetErrnoMessage(Errno errno);</pre>

<blockquote>
Get a descriptive message for the error code <code>errno</code> from
the underlying system.  If the system does not have an appropriate
message, this method will return <code>null</code>.
</blockquote>

<a name="Platform_Errno"><h3>Platform.Errno</h3>

The <code>Errno</code> enumerated type defines a large number of
Posix-style error codes that may be returned for failed operating
system calls.<p>

Every system has its own error numbering system.  It is the responsibility
of the CLR to convert the system error numbers into the constants from
the <code>Errno</code> type so that the C# library has a consistent set
of values to use, regardless of the underlying platform.<p>

<a name="Platform_Stdio"><h3>Platform.Stdio</h3>

The <code>Stdio</code> class provides a number of primitive methods
for manipulating <code>stdin</code>, <code>stdout</code>, and
</code>stderr</code> from the <code>System.Console</code> class.
It can only be used to access these three streams, and only for
character-based data.  Binary file streams are handled by
<code>Platform.FileMethods</code>.<p>

Note: it is usually possible to access these standard streams as
file descriptors 0, 1, and 2 through regular filesystem operations
such as those in <code>Platform.FileMethods</code>, but that usage
is not portable between systems.<p>

Some operating systems, particularly for embedded systems, may not
have standard input and output streams in the same sense as desktop
platforms.  They may not have a regular filesystem at all.  However,
they may have functions that can be used to report messages to
debuggers or logging facilities.  This class can be used to
redirect <code>System.Console</code> to those functions.<p>

CLR's on GUI systems may wish to disable <code>System.Console</code>
or divert it to a logging facility, because it isn't normally
visible in the GUI.  This class provides a convenient place where
such diversion can be performed.<p>

The methods below use the descriptors 0, 1, and 2 to mean standard
input, standard output, and standard error, respectively.  The
CLR is free to disable any of these.  For example, it may always
indicate EOF when <code>StdRead</code> is called if reading from
standard input is disallowed.<p>

<a name="Platform_Stdio_StdClose">
<pre>public static void StdClose(int fd);</pre>

<blockquote>
Close the specified stream.  The CLR may ignore this call if closing
a standard stream has been disallowed for security reasons.
</blockquote>

<a name="Platform_Stdio_StdFlush">
<pre>public static void StdFlush(int fd);</pre>

<blockquote>
Flush the contents of the specified stream.
</blockquote>

<a name="Platform_Stdio_StdWrite">
<pre>public static void StdWrite(int fd, char value);
public static void StdWrite(int fd, char[] value, int index, int count);
public static void StdWrite(int fd, String value);</pre>

<blockquote>
Write values of various types to the specified output stream.  This
may convert from Unicode into a local character set.
</blockquote>

<a name="Platform_Stdio_StdRead">
<pre>public static int StdRead(int fd);</pre>

<blockquote>
Read a single character from the specified input stream.  Returns the
<code>char</code> value, coerced to <code>int</code>, or -1 at EOF or
on error.  This method may convert from a local character set into
Unicode.
</blockquote>

<pre>public static int StdRead(int fd, char[] value, int index, int count);</pre>

<blockquote>
Read a buffer of characters from the specified input stream.  Returns the
number of characters read, 0 at EOF, or -1 on error.  This method may
convert from a local character set into Unicode.
</blockquote>

<a name="Platform_Stdio_StdPeek">
<pre>public static int StdPeek(int fd);</pre>

<blockquote>
Peek at the next character from the specified input stream, but leave
the current stream position unchanged.  Returns the <code>char</code>
value, coerced to <code>int</code>, or -1 at EOF or on error.
This method may convert from a local character set into Unicode.
</blockquote>

<a name="Platform_SysCharInfo"><h3>Platform.SysCharInfo</h3>

<a name="Platform_SysCharInfo_GetUnicodeCategory">
<pre>public static UnicodeCategory GetUnicodeCategory(char ch);</pre>

<blockquote>
Get the category that a specific Unicode character falls
within (uppercase, lowercase, digit, space, currency, etc).<p>

This is usually implemented with a large lookup table.  Some
systems may have functions to perform this lookup already, and
other CLR's may have to provide their own implementation.<p>

CLR implementations on small memory footprint devices may want
to use a smaller table that is tailored to a particular locale.<p>

Making this <code>internalcall</code> gives the CLR maximum flexibility
as to how this is implemented, and what trade-offs may apply.
</blockquote>

<a name="Platform_SysCharInfo_GetNumericValue">
<pre>public static double GetNumericValue(char ch);</pre>

<blockquote>
Get the numeric value associated with a Unicode character.
e.g. the "1/4" character ('\u00BC') returns "0.25".  This is also
usually implemented with a lookup table.<p>

This method returns -1.0 if there is no numeric value associated
with the character.
</blockquote>

<a name="Platform_SysCharInfo_GetNewLine">
<pre>public static String GetNewLine();</pre>

<blockquote>
Get the newline string to be used on this platform.  This
will typically be either <code>"\n"</code> or <code>"\r\n"</code>.
This value is cached by <code>Environment.NewLine</code>, which
is the portable way to obtain the string.
</blockquote>

<a name="Platform_TaskMethods"><h3>Platform.TaskMethods</h3>

Contains methods related to tasks, such as processes and threads.<p>

<a name="Platform_TaskMethods_Exit">
<pre>public static void Exit(int exitCode);</pre>

<blockquote>
Exit from the current process.  This will only be called if
the program has the necessary security permissions, so it is
safe to exit immediately.
</blockquote>

<a name="Platform_TaskMethods_SetExitCode">
<pre>public static void SetExitCode(int exitCode);</pre>

<blockquote>
Set the exit code to use when the current process exits by
returning from its <code>Main</code> method.  The default
value should be zero.<p>

This value is only used if the <code>Main</code> method is
declared as returning <code>void</code>.
</blockquote>

<a name="Platform_TaskMethods_GetCommandLineArgs">
<pre>public static String[] GetCommandLineArgs();</pre>

<blockquote>
Get the command-line arguments for the current process.
Returns <code>null</code> if the platform does not support
command-line arguments.  The first returned argument is the
name of the executable.<p>

This value is different from that passed to the <code>Main</code>
method.  The argument to <code>Main</code> does not include
the name of the executable.<p>
</blockquote>

<a name="Platform_TaskMethods_GetEnvironmentVariable">
<pre>public static String GetEnvironmentVariable(String variable);</pre>

<blockquote>
Get the value of a named environment variable.  Returns <code>null</code>
if the variable is not present.
</blockquote>

<a name="Platform_TaskMethods_GetEnvironmentCount">
<pre>public static int GetEnvironmentCount();</pre>

<blockquote>
Get the number of environment variables that are associated
with the current task.  Returns zero if the environment is empty,
or not accessible to the program.
</blockquote>

<a name="Platform_TaskMethods_GetEnvironmentKey">
<pre>public static String GetEnvironmentKey(int posn);</pre>

<blockquote>
Get the key (or variable name) associated with the environment
variable at a specific index.  Returns <code>null</code>
if the index is invalid.
</blockquote>

<a name="Platform_TaskMethods_GetEnvironmentValue">
<pre>public static String GetEnvironmentValue(int posn);</pre>

<blockquote>
Get the value associated with the environment variable at a
specific index.  Returns <code>null</code> if the index is invalid.
</blockquote>

<a name="Platform_TimeMethods"><h3>Platform.TimeMethods</h3>

<a name="Platform_TimeMethods_GetCurrentTime">
<pre>public static long GetCurrentTime();</pre>

<blockquote>
Get the current time in tenths of a microsecond since
12:00am 1 Jan 0001 as a 64-bit value.  This returns local time.
It is the responsibility of the CLR to convert from the system's
epoch into this one, and to handle local timezone conversions.
The CLR should return the most accurate time value that it can
obtain, even if it isn't accurate to a tenth of a microsecond.
</blockquote>

<a name="Platform_TimeMethods_GetCurrentUtcTime">
<pre>public static long GetCurrentUtcTime();</pre>

<blockquote>
Get the current time in tenths of a microsecond since
12:00am 1 Jan 0001 as a 64-bit value.  This returns UTC time
(sometimes incorrectly called "GMT").  It is the responsibility of
the CLR to convert from the system's epoch into this one.  The
CLR should return the most accurate time value that it can obtain,
even if it isn't accurate to a tenth of a microsecond.
</blockquote>

<a name="Platform_TimeMethods_GetTimeZoneAdjust">
<pre>public static int GetTimeZoneAdjust();</pre>

<blockquote>
Gets the number of seconds West of UTC for the local timezone,
including any applicable daylight savings adjustments.
</blockquote>

<a name="Platform_TimeMethods_GetUpTime">
<pre>public static int GetUpTime();</pre>

<blockquote>
Get the number of milliseconds since the system was last rebooted.
This is typically called <code>GetTickCount</code> under Windows.<p>

Some systems have no way to discover the time since reboot.
The CLR may return the time since the engine was started instead.
</blockquote>
