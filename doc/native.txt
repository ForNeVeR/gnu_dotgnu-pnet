Native methods required to use the "runtime" library:
====================================================

Introduction:
------------

We take a slightly different approach to native methods than Microsoft.
Their "mscorlib" library contains a lot of Windows-specific PInvoke's and
other assumptions.  This would require a substantial rewrite to move
the code to any other platform.

We try to isolate things a bit better.  The overriding design goal is:
there can be only one core library.  Our equivalent of "mscorlib" is
the same on every platform.  Any platform-specific stuff is provided
through native methods that the runtime engine provides.

Natives fall into two categories: System and Platform.  The natives in
System provide facilities that are platform-independent but need to be
implemented in the runtime engine.  e.g. reflection must be implemented
in C because there are no IL bytecodes for implementing it.  The Decimal
operators are implemented in C for speed, but they are otherwise
platform-independent.

The natives in Platform are where the platform-specific bits are plugged in.
These methods may behave very differently on different platforms, and under
different security policies.

All System natives should be implemented by all runtime engines.  Some
Platform natives may be stubbed out if the platform or security policy
does not allow the operation to complete.

All classes defined in Platform must be declared "internal" so that programs
can only get access through the public interfaces in System, and so that
the "Platform" namespace does not pollute the global namespace of programs
that use the library.

Natives in System namespaces:
----------------------------

System.Object:

	public Type GetType();

		Get the type associated with the object.

	public virtual int GetHashCode();

		Get the default hash code associated with the object.

	public virtual bool Equals(Object obj);

		Default implementation of "Equals".

	protected Object MemberwiseClone();

		Perform a memberwise clone on the object.

System.Decimal:

	public Decimal(float value);
	public Decimal(double value);

		Construct Decimal values from float and double values.
		If "value" is out of range, NaN, or an infinity, then
		throw an "Overflow_Decimal" exception.

	public static float ToSingle(decimal value);
	public static float ToDouble(decimal value);

		Convert decimal values into either float or double.
		No exceptions are thrown.

	public static decimal Add(decimal x, decimal y);
	public static int Compare(decimal x, decimal y);
	public static decimal Divide(decimal x, decimal y);
	public static decimal Floor(decimal x);
	public static decimal Mod(decimal x, decimal y);
	public static decimal Multiply(decimal x, decimal y);
	public static decimal Negate(decimal x);
	public static decimal Round(decimal x, int decimals);
	public static decimal Subtract(decimal x, decimal y);
	public static decimal Truncate(decimal x);

		Various arithmetic operations on Decimal values.

System.Double:

	public static bool IsNaN(double d);
	public static bool IsInfinity(double d);

		Test for NaN and Infinity values for the double type.

System.ArgIterator:

	public ArgIterator(RuntimeArgumentHandle);
	public ArgIterator(RuntimeArgumentHandle, void *);
	public TypedReference GetNextArg();
	public TypedReference GetNextArg(RuntimeTypeHandle);
	public RuntimeTypeHandle GetNextArgType();

Natives in Platform namespaces:
------------------------------

Platform.DirMethods

	This class contains directory manipulation functions for the filesystem.

	public static PathInfo GetPathInfo();

		Retrieves path character information from the runtime engine.
		i.e. the separators to be used for directories, PATH's, etc.

Platform.PtrSizes

	public static int GetPtrSize();

		Get the size in bytes of a pointer on the runtime platform.
		This will typically return either 4 or 8.

	public static String GetSystemDirectory();

		Get the full pathname of the "System" directory.  This is
		highly Windows-specific.  If the platform does not have
		such a directory, this should return "null", which will
		cause a "NotSupportedException" to be thrown by higher layers.

Platform.SysCharInfo:

	public static UnicodeCategory GetUnicodeCategory(char ch);

		Get the category that a specific Unicode character falls
		within (uppercase, lowercase, digit, space, currency, etc).

		This typically needs to be implemented with a large lookup
		table.  Some systems may have functions to perform this
		lookup already, and other systems may have to provide their
		own implementation.

		Runtime engines on small memory footprint devices may want
		to use a smaller table that is tailored to a particular locale.

		Making this native gives the runtime engine maximum flexibility
		as to how this is implemented, and what trade-offs may apply.

	public static String GetNewLine();

		Get the newline string to be used on this platform.  This
		will typically be either "\n" or "\r\n".  This value is
		cached by "Environment.NewLine", which is the portable way
		to obtain the string.

Platform.TaskMethods

	Contains methods related to tasks, such as processes and threads.

	public static void Exit(int exitCode);

		Exit from the current process.  This will only be called if
		the program has the necessary security permissions, so it is
		safe to exit immediately.

	public static void SetExitCode(int exitCode);

		Set the exit code to use when the current process exits by
		returning from its "Main" method.  The default should be zero.

	public static String[] GetCommandLineArgs();

		Get the command-line arguments for the current process.
		Returns null if the platform does not support command-line
		arguments.  The first returned argument is the name of
		the executable.

Platform.TimeMethods

	public static long GetCurrentTime();

		Get the current time in tenths of a microsecond since
		12:00am 1 Jan 0001.

	public static int GetUpTime();

		Get the number of milliseconds since the system was last rebooted.
		This is typically called "GetTickCount" under Windows.
