
@c -----------------------------------------------------------------------

@node Assembler Syntax, Lexical Tokens, ilasm invocation, Assembler
@section Assembler Syntax
@cindex Assembler Syntax

The following sections describe the syntax of the assembly code that is input
to ilasm.  The following BNF notations are used:

@table @code
@item A => B
The non-terminal @code{A} can be expanded to the sequence @code{B}.

@item @strong{name}
A lexical terminal keyword called @code{name}.  e.g. @code{@strong{public}}.

@item NAME
A lexical terminal symbol called @code{NAME}, used to represent
identifiers, numbers, strings, etc.

@item @{A@}
Zero or more occurrences of @code{A}.

@item (A)+
One or more occurrences of @code{A}.

@item [A]
Zero or one occurrences of @code{A}.  i.e. @code{A} is optional.

@item A | B
Either @code{A} or @code{B}.

@item <abcd>
One of the characters @code{a}, @code{b}, @code{c}, or @code{d}.
This is normally written as @code{[abcd]} when used for
grep(1) regular expressions.

@item <^abcd>
Any character except @code{a}, @code{b}, @code{c}, or @code{d}.

@item <ANY>
Any character.

@item 'c'
The character @code{c}.  This can also be expressed as @code{<c>}.
@end table

@c -----------------------------------------------------------------------

@node Lexical Tokens, Helper Non-Terminals, Assembler Syntax, Assembler
@section Lexical tokens
@cindex Lexical tokens

The syntax uses lexical terminal symbols called @code{IDENT},
@code{INT}, @code{FLOAT}, @code{SQSTRING}, @code{DQSTRING}, and
@code{HEXBYTE}.  Their structure is defined as follows:

@example
IDENT    => IDALPHA @{ IDALPHA | DIGIT @}
INT      => ['-'] (DIGIT)+
          | ['-'] '0' <xX> (<0-9a-fA-F>)+
          | ['-'] '0' @{<0-7>@}
FLOAT    => [<+->] (DIGIT)+ EXPONENT
          | [<+->] @{DIGIT@} '.' (DIGIT)+ [EXPONENT]
          | [<+->] (DIGIT)+ '.' @{DIGIT@} [EXPONENT]
SQSTRING => <'> @{ '\' <ANY> | <^'\> @} <'>
DQSTRING => '"' @{ '\' <ANY> | <^"\> @} '"'
HEXBYTE  => (<0-9a-fA-F>)+
IDALPHA  => <a-zA-Z_$@?>
DIGIT    => <0-9>
EXPONENT => <eE> [<+->] (DIGIT)+
@end example

The syntax is very close to that used by C for identifiers, integer constants,
floating point constants, single-quoted strings, and double-quoted strings.
C-like escape sequences can be used for special characters in strings.
Unlike C, single quotes are used for strings and not character constants.
The @code{HEXBYTE} terminal is used for raw sequences of bytes in some of
the declaration types.

Strings are expected to be in the UTF-8 encoding, ready for translation into
the Unicode strings used by IL binaries.  No other character sets are
supported.  It is the responsibility of the tool that generates IL
assembly code to perform any necessary character set conversions.

Comments can be represented in two ways: single-line and multi-line.
Single-line comments begin with @code{//} and continue to the end of
the current line.  Multi-line comments begin with @code{/*} and continue
until the next occurrence of @code{*/}.  Multi-line comments cannot
be nested.

White space in the input is ignored.  The allowable white space characters
are Space (0x20), Tab (0x09), Vertical Tab (0x0B), Carriage Return (0x0D),
Line Feed (0x0A), Form Feed (0x0C), and Ctrl-Z (0x1A).

The assembly language has a large number of keywords and instruction names
that begin with lower case letters.  If the program uses a keyword
as an identifier for a class, field, method, etc, it must be quoted with
single quotes.  For example, a program identifier called @code{managed}
would need to be written as @code{'managed'} so that it does not conflict
with the @code{managed} keyword.

The easiest method to protect identifiers is to quote anything that begins
with a lower case letter.  If new keywords are added to ilasm in the
future, there will be no need to modify existing compilers that use this
technique.  Compilers can quote only known keywords and instructions if
they wish, but they will not be robust against future changes.

The following is a list of the assembler keywords:

@example
@strong{abstract algorithm alignment ansi any array as assembly assert
at auto autochar beforefieldinit blob blob_object bool boxed
bstr bytearray byvalstr callmostderived carray catch cdecl
cf char cil class clsid compilercontrolled currency custom
date decimal default demand deny disablejitoptimizer
enablejittracking error explicit extends extern false famandassem
family famorassem fastcall fault field filetime filter final
finally fixed float float32 float64 forwardref fromunmanaged
fullorigin handler hidebysig hresult idispatch il implements
implicitcom implicitres import in inf inheritcheck init initonly
instance int int16 int32 int64 int8 interface internalcall
iunknown lasterr lateinit lcid linkcheck literal lpstr lpstruct
lptstr lpvoid lpwstr managed marshal method modopt modreq nan
native nested newslot noappdomain noinlining nomachine nomangle
nometadata noncasdemand noncasinheritance noncaslinkdemand
noprocess not_in_gc_heap notserialized null object objectref ole
opt optil out permitonly pinned pinvokeimpl prejitdeny prejitgrant
preservesig private privatescope public publickey readonly record
reqmin reqopt reqrefuse reqsecobj request retval rtspecialname
runtime safearray sealed sequential serializable specialname
static stdcall storage stored_object stream streamed_object string
struct synchronized syschar sysstring tbstr thiscall tls to true
typedref unicode unmanaged unmanagedexp unsigned userdefined value
valuetype vararg variant vector virtual void wchar winapi with}
@end example

The following is a list of assembler directives:

@example
@strong{.addon .algorithm .assembly .backing .blob .capability .cctor
.class .comtype .config .corflags .ctor .custom .data .emitbyte
.entrypoint .event .exeloc .export .field .file .fire .get .hash
.imagebase .implicitcom .library .line #line .locale .locals .manifestres
.maxstack .method .mime .module .mresource .namespace .originator .os
.other .override .pack .param .permission .permissionset .processor
.property .publickey .publickeytoken .removeon .set .size .subsystem
.title .try .ver .vtable .vtentry .vtfixup .zeroinit}
@end example

The following is a list of the instruction names:

@example
@strong{add add.ovf add.ovf.un and ann.call ann.catch ann.data ann.data.s
ann.dead ann.def ann.hoisted ann.hoisted_call ann.lab ann.live
ann.phi ann.ref ann.ref.s arglist beq beq.s bge bge.s bge.un bge.un.s
bgt bgt.s bgt.un bgt.un.s ble ble.s ble.un ble.un.s blt blt.s blt.un
blt.un.s bne.un bne.un.s box box_old br break brfalse brfalse.s
brinst brinst.s brnull brnull.s br.s brtrue brtrue.s brzero brzero.s
call calli callvirt castclass ceq cgt cgt.un ckfinite clt clt.un
conv.i conv.i1 conv.i2 conv.i4 conv.i8 conv.ovf.i conv.ovf.i1
conv.ovf.i1.un conv.ovf.i2 conv.ovf.i2.un conv.ovf.i4 conv.ovf.i4.un
conv.ovf.i8 conv.ovf.i8.un conv.ovf.i.un conv.ovf.u conv.ovf.u1
conv.ovf.u1.un conv.ovf.u2 conv.ovf.u2.un conv.ovf.u4 conv.ovf.u4.un
conv.ovf.u8 conv.ovf.u8.un conv.ovf.u.un conv.r4 conv.r8 conv.r.un
conv.u conv.u1 conv.u2 conv.u4 conv.u8 cpblk cpobj div div.un dup
endfault endfilter endfinally initblk initobj isinst jmp jmpi ldarg
ldarg.0 ldarg.1 ldarg.2 ldarg.3 ldarga ldarga.s ldarg.s ldc.i4 ldc.i4.0
ldc.i4.1 ldc.i4.2 ldc.i4.3 ldc.i4.4 ldc.i4.5 ldc.i4.6 ldc.i4.7 ldc.i4.8
ldc.i4.m1 ldc.i4.M1 ldc.i4.s ldc.i8 ldc.r4 ldc.r8 ldelema ldelem.i
ldelem.i1 ldelem.i2 ldelem.i4 ldelem.i8 ldelem.r4 ldelem.r8 ldelem.ref
ldelem.u1 ldelem.u2 ldelem.u4 ldelem.u8 ldfld ldflda ldftn ldind.i
ldind.i1 ldind.i2 ldind.i4 ldind.i8 ldind.r4 ldind.r8 ldind.ref
ldind.u1 ldind.u2 ldind.u4 ldind.u8 ldlen ldloc ldloc.0 ldloc.1 ldloc.2
ldloc.3 ldloca ldloca.s ldloc.s ldnull ldobj ldptr ldsfld ldsflda
ldstr ldtoken ldvirtftn leave leave.s localloc mkrefany mul mul.ovf
mul.ovf.un mul.un neg newarr newobj nop not or pop refanytype
refanyval rem rem.un ret rethrow shl shr shr.un sizeof starg starg.s
stelem.i stelem.i1 stelem.i2 stelem.i4 stelem.i8 stelem.r4 stelem.r8
stelem.ref stfld stind.i stind.i1 stind.i2 stind.i4 stind.i8 stind.r4
stind.r8 stind.ref stloc stloc.0 stloc.1 stloc.2 stloc.3 stloc.s
stobj stsfld sub sub.ovf sub.ovf.un switch tail tail. throw unbox
volatile volatile. xor}
@end example

@c -----------------------------------------------------------------------

@node Helper Non-Terminals, Top-Level Declarations, Lexical Tokens, Assembler
@section Helper Non-Terminals
@cindex Helper Non-Terminals

In this section we define a number of non-terminals that will be used
later in the BNF grammar.  They do not necessarily correspond to
useful program constructs on their own.

@cindex Identifier
@cindex Integer32
@cindex Integer64
@cindex Float64
@cindex ComposedString
@cindex QualifiedName
@example
Identifier     => IDENT | SQSTRING
Integer32      => INT      /* 32-bit integer */
Integer64      => INT      /* 64-bit integer */
Float64        => FLOAT
                | @strong{float32} '(' Integer32 ')'
                | @strong{float64} '(' Integer64 ')'
                | @strong{nan}
                | @strong{inf}
                | '-' @strong{inf}
ComposedString => DQSTRING
                | ComposedString '+' DQSTRING
QualifiedName  => Identifier
                | QualifiedName '.' Identifier
@end example

The second and third forms of the Float64 non-terminal can be used to
convert the raw bit representation of a floating-point number into
a floating-point value.  The second form converts the big-endian, 32-bit,
IEEE integer representation of a single-precision value into a 32-bit float.
For example 0x3F800000 represents the value 1.0.  The third form does
the same for 64-bit IEEE integer representations of double-precision values.

The raw bit forms are mainly of use to compilers that wish to output
the exact binary representation of a floating-point constant, rather than
a rounded decimal value.

The ComposedString non-terminal allows long strings to be built up by
appending a sequence of shorter strings.

@c -----------------------------------------------------------------------

@node Top-Level Declarations, Namespace Declarations, Helper Non-Terminals, Assembler
@section Top-Level Declarations
@cindex Top-Level Declarations

The top-most level of the assembly input stream consists of zero or
more declarations:

@cindex TopLevel
@example
TopLevel => @{ Declaration @}
@end example

Declarations at the top-most level cover program items such as
classes, namespaces, global methods, assembly information, manifest
resources, etc:

@cindex Declaration
@example
Declaration => NamespaceDeclaration
             | ClassDeclaration
             | MethodDeclaration
             | DataDeclaration
             | VtableDeclaration
             | VtfixupDeclaration
             | ExternalSourceSpecification
             | FileDeclaration
             | ExeLocationDeclaration
             | AssemblyDeclaration
             | AssemblyRefDeclaration
             | ComTypeDeclaration
             | ManifestResDeclaration
             | ModuleDeclaration
             | SecurityDeclaration
             | CustomAttributeDeclaration
@end example

The assembler does support some additional kinds of declarations
beyond those described in this document.  They are supported for
compatibility with older versions of the assembly syntax, and for
compatibility with tools from other vendors.

The syntax described here is the official syntax, and deviating
from it is not recommended.  Support for other syntax may be
removed in a future version of the assembler.

@c -----------------------------------------------------------------------

@node Namespace Declarations, Class Declarations, Top-Level Declarations, Assembler
@section Namespace Declarations
@cindex Namespace Declarations

Zero or more classes may be grouped together into a namespace, which
prefixes the class name with a particular identifier.

@cindex NamespaceDeclaration
@example
NamespaceDeclaration => @strong{.namespace} QualifiedName
                        '@{' @{ Declaration @} '@}'
@end example

In the following example, classes with names @code{C1} and @code{C2}
will be created within the namespace @code{N}:

@example
.namespace N
@{
    .class C1 @{ ... @}
    .class C2 @{ ... @}
@}
@end example

Note: the following is not the same as above:

@example
.class N.C1 @{ ... @}
.class N.C2 @{ ... @}
@end example

This declares two classes called @code{N.C1} and @code{N.C2}, within
the global namespace.

@c -----------------------------------------------------------------------

@node Class Declarations, Class References, Namespace Declarations, Assembler
@section Class Declarations
@cindex Class Declarations
@cindex Type Declarations

Strictly speaking, IL programs do not support classes at all.  Everything is
a type.  However, for historical reasons, types are declared by means of
a @strong{.class} declaration.

@cindex .class directive
@cindex ClassDeclaration
@cindex ClassAttribute
@cindex Class attributes
@example
ClassDeclaration => @strong{.class} @{ ClassAttribute @} Identifier
          [ @strong{extends} ClassName ]
          [ @strong{implements} ClassName @{ ',' ClassName @} ]
          '@{' @{ ClassMember @} '@}'
ClassAttribute => @strong{public}
                | @strong{private}
                | @strong{value}
                | @strong{unmanaged}
                | @strong{interface}
                | @strong{sealed}
                | @strong{abstract}
                | @strong{auto}
                | @strong{sequential}
                | @strong{explicit}
                | @strong{ansi}
                | @strong{unicode}
                | @strong{autochar}
                | @strong{import}
                | @strong{serializable}
                | @strong{nested public}
                | @strong{nested private}
                | @strong{nested family}
                | @strong{nested assembly}
                | @strong{nested famandassem}
                | @strong{nested famorassem}
                | @strong{beforefieldinit}
                | @strong{specialname}
                | @strong{rtspecialname}
@end example

@table @strong
@cindex public attribute (types)
@item public
Specify that the type is exported from the assembly that declares
it, and is accessible to any other type.  This should not be used on
nested types.  This corresponds to the C# @code{public} access level
on non-nested types.

@cindex private attribute (types)
@item private
Specify that the type is private to the assembly that declares it,
and is accessible only to other types in the same assembly.  This
should not be used on nested types.  This corresponds to the C#
@code{internal} access level on non-nested types.

@cindex nested public attribute (types)
@item nested public
Specify that the type is publicly accessible within the scope of
its nesting parent's accessibility.  The type is accessible to
any other type that can access the nesting parent.  This should
only be used on nested types.  This corresponds to the C# @code{public}
access level on nested types.

@cindex nested private attribute (types)
@item nested private
Specify that the type is private to its nesting parent and cannot
be accessed by any other type.  This should only be used on nested types.
This corresponds to the C# @code{private} access level on nested types.

@cindex nested family attribute (types)
@item nested family
Specify that the type is accessible to its nesting parent and to
any type derived from the nesting parent.  This should only be used
on nested types.  This corresponds to the C# @code{protected}
access level on nested types.

@cindex nested assembly attribute (types)
@item nested assembly
Specify that the type is accessible to any other type in the
assembly that declares it.  This should only be used on nested types.
This corresponds to the C# @code{internal} access level on nested types.

@cindex nested famandassem attribute (types)
@item nested famandassem
Specify that the type is accessible only to types that inherit from
the nesting parent and are also declared in the same assembly as
this type.  This should only be used on nested types.  There is no
C# equivalent to this access level.

@cindex nested famorassem attribute (types)
@item nested famorassem
Specify that the type is accessible only to types that inherit from
the nesting parent or that are declared in the same assembly as this type.
This should only be used on nested types.  This corresponds to the C#
@code{protected internal} access level on nested types.

@cindex value attribute (types)
@item value
Specify that the type is normally used as a value type (C# @code{struct})
instead of as an object reference.

@cindex unmanaged attribute (types)
@item unmanaged
Specify that the type declares an unmanaged value type.

@cindex interface attribute (types)
@item interface
Specify that the type is an interface rather than a regular class or
value type.  Interfaces should also have the @strong{abstract} attribute.

@cindex sealed attribute (types)
@item sealed
Specify that the type cannot be inherited.

@cindex abstract attribute (types)
@item abstract
Specify that the type cannot be instantiated.  This attribute should be
present on interfaces and on any class that has @strong{abstract} methods.

@cindex auto attribute (types)
@item auto
Specify that the fields of the type should be laid out in the most
efficient manner possible, with no user-supplied constraints.  Normally
this will be the same as @strong{sequential}, but it does not have to
be the same.

@cindex sequential attribute (types)
@item sequential
Specify that the fields of the type should be laid out in a manner which
is consistent with the underlying operating system.  Most types will
have this attribute set.

@cindex explicit attribute (types)
@item explicit
Specify that the fields of the type should be laid out using user-supplied
explicit layout rules.  These rules are specified with the @strong{.size}
and @strong{.pack} directives, and with explicit offset information on
each of the fields.

@cindex ansi attribute (types)
@item ansi
Specify that any strings that are marshalled to unmanaged code by this
type should be interpreted using the system's prevailing locale.  If the
type does not marshal strings to unmanaged code, then @strong{ansi} is
the default value.

@cindex unicode attribute (types)
@item unicode
Specify that any strings that are marshalled to unmanaged code by this
type should be interpreted as Unicode.  This attribute only makes sense
on Windows machines.

@cindex autochar attribute (types)
@item autochar
Specify that any strings that are marshalled to unmanaged code by this
type should be interpreted as either Unicode or strings in the prevailing
locale, depending upon the capabilities of the underlying operating system.
This attribute only makes sense on Windows machines.

@cindex import attribute (types)
@item import
Specify that the type was imported from some other module within the
assembly.  This attribute is very rare and can be ignored by most compilers.

@cindex serializable attribute (types)
@item serializable
Specify that the fields of the type can be automatically serialized by
the runtime engine's builtin serialization routines.  Any fields that have
the @strong{not_serialized} attribute will be omitted from the builtin
serialization.

@cindex beforefieldinit attribute (types)
@item beforefieldinit
Specify that the type does not need to be initialized until the first
time that a static method within the type is called.

@cindex specialname attribute (types)
@item specialname
Specify that the type may have special significance to tools other than
the runtime engine.  This is rarely needed on types.

@cindex rtspecialname attribute (types)
@item rtspecialname
Specify that the type may have special significance to the runtime engine.
This is rarely needed on types.
@end table

The type may contain any of the following members:

@cindex ClassMember
@example
ClassMember => MethodDeclaration
             | ClassDeclaration
             | EventDeclaration
             | PropertyDeclaration
             | FieldDeclaration
             | DataDeclaration
             | SecurityDeclaration
             | ExternalSourceSpecification
             | CustomAttributeDeclaration
             | @strong{.size} Integer32
             | @strong{.pack} Integer32
             | ComTypeDeclaration
             | ExportDeclaration
             | OverrideDeclaration
@end example

Most of these will be described in later sections.  The exceptions are
@strong{.size} and @strong{.pack}:

@table @strong
@cindex .size directive
@item .size
Specify the size of the type, in bytes.  This should only be used
with @strong{explicit} layout.  If this declaration is not present,
or specifies the value zero, then the runtime engine will choose the
size of the type.

@cindex .pack directive
@item .pack
Specify the packing size to be used for fields of the type.  This must be
one of the values 0, 1, 2, 4, 8, 16, 32, 64, or 128, and should only be
used with @strong{explicit} layout.  A packing size of zero, or a missing
packing size, indicates that the default size for the underlying operating
system should be used.
@end table

@c -----------------------------------------------------------------------

@node Class References, Type Specifications, Class Declarations, Assembler
@section Class References
@cindex Class References

In many places within the assembly source stream, it is necessary to
refer to other classes within the same source, or in other assemblies.
This section describes the syntax of class references.

In IL, there is a distinction defined, primitive, and composed types.
Defined types are used to define the classes and value types that are
used in the program.  Primitive types are types such as @strong{int32},
@strong{bool}, @strong{float64}, etc.  Composed types are arrays, pointers,
etc, that are built up from defined and primitive types.

In this section, we will treat a "class name" as a reference to a defined
type, even if the type happens to correspond to a value type.  Primitive
and composed types cannot be referred to using class names.

@cindex ClassName
@cindex ImportScope
@cindex Class names
@example
ClassName   => [ '[' ImportScope ']' ]
                  QualifiedName @{ '/' QualifiedName @}
ImportScope => QualifiedName |
             | @strong{.module} QualifiedName
             | @strong{.library}
@end example

Class names begin with an import scope, which specifies where the
defined type is being imported from.  If the import scope is not present,
the type is assumed to be declared in the same assembly stream, or
that the type will be resolved by the linker.

If the import scope is a @code{QualifiedName}, then it indicates that
the defined type is being imported from an assembly.  The assembler
searches for an assembly reference definition with the same name.
If there is no such assembly reference, then it will search for an
assembly definition with the same name.  If an assembly definition is
found, then the interpretation is the same as if the scope was not
supplied at all.  An error occurs if there is no assembly reference
or definition for the name.

If the import scope is prefixed with @strong{.module}, then it indicates
that the defined type is being imported from a module.  This form of
import is deprecated in favour of assembly imports.

If the import scope is @strong{.library}, then it indicates that the
defined type is being imported from the CLI standard library.  This
library is normally in an assembly called @code{mscorlib}, but it is
possible to specify a different name using the @code{--stdlib-name} option
to @code{ilasm}.

Following the import scope, the name consists of one of more components,
separated by slashes.  A name with no slashes indicates a type that
is declared at the global level of the import scope.  A name with
slashes indicates a nested type.  For example, the following refers
to the type @code{HashEntry} which is nested within the standard
@code{System.Enum} type:

@example
[.library]System.Enum/HashEntry
@end example

@c -----------------------------------------------------------------------

@node Type Specifications, Method Declarations, Class References, Assembler
@section Type Specifications
@cindex Type Specifications

Thoughout the assembly source stream, it is necessary to refer to
defined, primitive, and composed types.  This is done using type
specifications, which may either be class names or composed types.

@cindex TypeSpecification
@example
TypeSpecification => ClassName | Type
@end example

Types may be composed from class names, primitive types, and other
composed types as follows:

@cindex Type
@example
Type => @strong{class} ClassName
      | @strong{valuetype} ClassName
      | Type '[' Bounds @{ ',' Bounds @} ']'
      | Type '&'        /* reference */
      | Type '*'        /* pointer */
      | Type @strong{pinned}
      | Type @strong{modreq} '(' ClassName ')'
      | Type @strong{modopt} '(' ClassName ')'
      | @strong{method} [ CallingConventions ] Type '*'
                          '(' [ SignatureArguments ] ')'
      | PrimitiveType
@end example

Every defined type in the program has two forms: class and value type.
The particular form to be used may be specified using the @strong{class}
and @strong{valuetype} prefixes.  If the prefix is not present, then
the assembler will guess the correct form from the type definition.

The assembler supports the following primitive type keywords:

@cindex PrimitiveType
@example
PrimitiveType => @strong{void}
               | @strong{bool}
               | @strong{char}
               | @strong{int8}
               | @strong{unsigned} @strong{int8}
               | @strong{int16}
               | @strong{unsigned} @strong{int16}
               | @strong{int32}
               | @strong{unsigned} @strong{int32}
               | @strong{int64}
               | @strong{unsigned} @strong{int64}
               | @strong{native} @strong{int}
               | @strong{native} @strong{unsigned} @strong{int}
               | @strong{float32}
               | @strong{float64}
               | @strong{native} @strong{float}
               | @strong{string}
               | @strong{object}
               | @strong{typedref}
@end example

The @strong{string} keyword is replaced with a @strong{class} reference
to the library class @code{System.String}.  The @strong{object} keyword
is replaced with a @strong{class} reference to the library class
@code{System.Object}.

Array bounds are specified as follows:

@cindex Bounds
@example
Bounds => /* empty */
        | @strong{...}
        | Integer32
        | Integer32 @strong{...}
        | Integer32 @strong{...} Integer32
@end example

The first two forms indicate an array dimension with no lower or upper bound.
The third form indicates an array dimension with lower bound 0, and the upper
bound as one less than the specified value.  The fourth form indicates
an array dimension with a specified lower bound, but no upper bound.  The
last form indicates an array dimension with both lower and upper bounds
specified.

In certain contexts, types may have marshalling information associated
with them.  This marshalling information provides directions to the
runtime engine when it invokes external methods using the PInvoke
mechanism.

@cindex MarshalledType
@cindex NativeType
@example
MarshalledType => Type [ @strong{marshal} '(' NativeType ')' ]
NativeType     => /* empty */
                | @strong{custom} '(' ComposedString ',' ComposedString ','
                               ComposedString ',' ComposedString ')'
                | @strong{fixed} @strong{sysstring} '[' Integer32 ']'
                | @strong{fixed} @strong{array} '[' Integer32 ']'
                | NativeType '*'
                | NativeType '[' ']'
                | NativeType '[' Integer32 ']'
                | NativeType '[' '+' Integer32 ']'
                | NativeType '[' Integer32 '+' Integer32 ']'
                | @strong{variant}
                | @strong{currency}
                | @strong{syschar}
                | @strong{void}
                | @strong{bool}
                | @strong{int8}
                | @strong{unsigned} @strong{int8}
                | @strong{int16}
                | @strong{unsigned} @strong{int16}
                | @strong{int32}
                | @strong{unsigned} @strong{int32}
                | @strong{int64}
                | @strong{unsigned} @strong{int64}
                | @strong{int}
                | @strong{unsigned }@strong{int}
                | @strong{float32}
                | @strong{float64}
                | @strong{float}
                | @strong{error}
                | @strong{decimal}
                | @strong{date}
                | @strong{bstr}
                | @strong{lpstr}
                | @strong{lpwstr}
                | @strong{lptstr}
                | @strong{objectref}
                | @strong{iunknown}
                | @strong{idispatch}
                | @strong{struct}
                | @strong{interface}
                | @strong{nested} @strong{struct}
                | @strong{byvalstr}
                | @strong{ansi} @strong{bstr}
                | @strong{tbstr}
                | @strong{variant} @strong{bool}
                | @strong{method}
                | @strong{lpvoid}
                | @strong{as} @strong{any}
                | @strong{lpstruct}
@end example

Note: native types are highly system-dependent.  Many of the types above
only make sense on Windows systems.

@c -----------------------------------------------------------------------

@node Method Declarations, Other Declarations, Type Specifications, Assembler
@section Method Declarations
@cindex Method Declarations

@example
MethodDeclaration => @strong{.method} @{ MethodAttribute @}
                     [ CallingConventions ]
                     @{ ParameterAttribute @}
                     MarshalledType MethodName
                     '(' [ SignatureArguments ] ')'
                     @{ ImplementationAttribute @}
                     '@{' @{ MethodMember @} '@}@'
MethodName => @strong{.ctor}
            | @strong{.cctor}
            | QualifiedName
MethodAttribute => @strong{static}
                 | @strong{public}
                 | @strong{private}
                 | @strong{family}
                 | @strong{final}
                 | @strong{specialname}
                 | @strong{virtual}
                 | @strong{abstract}
                 | @strong{assembly}
                 | @strong{famandassem}
                 | @strong{famorassem}
                 | @strong{privatescope}
                 | @strong{hidebysig}
                 | @strong{newslot}
                 | @strong{rtspecialname}
                 | @strong{unmanagedexp}
                 | @strong{pinvokeimpl}
                   '(' [ ComposedString
                            [ @strong{as} ComposedString ] ]
                       @{ PInvokeAttribute @} ')'
PInvokeAttribute => @strong{nomangle}
                  | @strong{ansi}
                  | @strong{unicode}
                  | @strong{autochar}
                  | @strong{ole}
                  | @strong{lasterr}
                  | @strong{winapi}
                  | @strong{cdecl}
                  | @strong{stdcall}
                  | @strong{thiscall}
                  | @strong{fastcall}
CallingConventions => @strong{instance} CallingConventions
                    | @strong{explicit} CallingConventions
                    | @strong{default}
                    | @strong{vararg}
                    | @strong{unmanaged cdecl}
                    | @strong{unmanaged stdcall}
                    | @strong{unmanaged thiscall}
                    | @strong{unmanaged fastcall}
ImplementationAttributes => @strong{native}
                          | @strong{il}
                          | @strong{optil}
                          | @strong{managed}
                          | @strong{unmanaged}
                          | @strong{forwardref}
                          | @strong{ole}
                          | @strong{runtime}
                          | @strong{internalcall}
                          | @strong{synchronized}
                          | @strong{noinlining}
SignatureArguments => SignatureArgument
                      @{ ',' SignatureArgument @}
SignatureArgument  => @strong{...}
                    | @{ ParameterAttribute @}
                      MarshalledType [ Identifier ]
ParameterAttribute => '[' @strong{in} ']'
                    | '[' @strong{out} ']'
                    | '[' @strong{opt} ']'
                    | '[' @strong{lcid} ']'
                    | '[' @strong{retval} ']'
                    | '[' Integer32 ']'
MethodMember => @strong{.emitbyte} Integer32
              | ExceptionBlock
              | @strong{.maxstack} Integer32
              | @strong{.locals} '(' [ SignatureArguments ] ')'
              | @strong{.locals init}
                '(' [ SignatureArguments ] ')'
              | @strong{.entrypoint}
              | @strong{.zeroinit}
              | DataDeclaration
              | Instruction
              | Identifier ':'
              | SecurityDeclaration
              | ExternalSourceSpecification
              | CustomAttributeSpecification
              | @strong{.vtentry} Integer32 ':' Integer32
              | @strong{.override} TypeSpecification
                @strong{::} MethodName
              | '@{' @{ MethodMember @} '@}'
              | @strong{.param} '[' Integer32 ']'
                [ '=' FieldInitialization ]
@end example

@c -----------------------------------------------------------------------

@node Other Declarations, Disassembler, Method Declarations, Assembler
@section Other Declarations
@cindex Other Declarations

This section defines the syntax for a number of other declaration kinds
that provide miscellaneous information that does not fall into any of
the above categories.

@example
VtableDeclaration  => @strong{.vtable} '=' '(' (HEXBYTE)+ ')'
VtfixupDeclaration => @strong{.vtfixup} '[' Integer32 ']'
                      @{ VtfixupAttribute @} @strong{at} Identifier
VtfixupAttribute   => @strong{int32}
                    | @strong{int64}
                    | @strong{fromunmanaged}
                    | @strong{callmostderived}
@end example
