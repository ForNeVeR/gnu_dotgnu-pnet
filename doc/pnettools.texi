\input texinfo	@c -*-texinfo-*-
@c %** start of header
@setfilename pnettools.info
@settitle Portable.NET Development Tools
@setchapternewpage off
@c %** end of header

@ifinfo
The Portable.NET development tools assist with building
and manipulating images in the portable executable format.
development.

Copyright @copyright{} 2001 Southern Storm Software, Pty Ltd
@end ifinfo

@titlepage
@sp 10
@center @titlefont{Portable.NET Development Tools}

@vskip 0pt plus 1fill
@center{Copyright @copyright{} 2001 Southern Storm Software, Pty Ltd}
@end titlepage

@c -----------------------------------------------------------------------

@node Top, Overview, , (dir)
@menu
* Overview::                The tools in brief
* C# Compiler::             C# compiler
* Assembler::               Intermediate language assembler
* Disassembler::            Intermediate language disassembler
* Size::                    Intermediate language size utility
* Native::                  Intermediate language native utility
* Find::                    Intermediate language name find utility
* Resources::               Resource generation and conversion
* ECMA Extensions::         ECMA file format extensions
* Load Errors::             Errors while loading IL binaries
* Index::                   Index of concepts and facilities
@end menu

@c -----------------------------------------------------------------------

@node Overview, C# Compiler, Top, Top
@chapter Overview
@cindex Overview

TO DO

@c -----------------------------------------------------------------------

@node C# Compiler, cscc invocation, Overview, Top
@chapter C# Compiler
@cindex C# Compiler
@cindex cscc

Cscc compiles input source files, typically in the C# (pronounced C-Sharp)
programming language.

The command-line syntax of cscc has been deliberately designed
to match that of C compilers such as gcc(1), to shorten the learning
curve for new users.

@menu
* cscc invocation::         Invoking cscc
* Option Summary::          Brief list of all options, without explainations
* Overall Options::         Controlling input, output, and overall behaviour
* Language Options::        Controlling the variant of C# that is compiled
* Warning Options::         Controlling how warnings are emitted
* Debugging Options::       Symbol tables and other debugging information
* Optimization Options::    Controlling the level of optimization
* Preprocessor Options::    Controlling conditional compilation and macros
* Assembler Options::       Controlling the behaviour of ilasm
* Directory Options::       Where to find include files
* Linker Options::          Controlling the behaviour of the linker
* Other Options::           Other options supported by cscc
* Language Plugins::        Adding other languages to cscc
* Compiling to the JVM::    Compiling source to JVM bytecode
@end menu

@c -----------------------------------------------------------------------

@node cscc invocation, Option Summary, C# Compiler, C# Compiler
@section Invoking cscc
@cindex cscc invocation

The general form of the ildasm syntax is as follows:

@example
cscc [OPTIONS] input ...
@end example

Exit status is 1 if an error occurred while processing the input.
Otherwise the exit status is 0.

@c -----------------------------------------------------------------------

@node Option Summary, Overall Options, cscc invocation, C# Compiler
@section Option summary for cscc
@cindex cscc option summary

@table @asis
@item Overall Options
@ref{Overall Options}@*
-c -S -E -o FILE -pipe -v -vv -x LANGUAGE

@item Language Options
@ref{Language Options}@*
-flatin1-charset -foctal-constants -fdecimal-constants
-fchecked -funchecked -fsyntax-check -funsafe

@item Warning Options
@ref{Warning Options}@*
-Wall -Werror -w -W -Woctal-chars -Woctal-constants
-Wunknown-escapes -Winvalid-utf8 -Wlarge-unicode-chars
-Wmulti-char-constant -Wunsafe -Wempty-input

@item Debugging Options
@ref{Debugging Options}@*
-g

@item Optimization Options
@ref{Optimization Options}@*
-O -O2 -O3 -O0 -fno-peephole

@item Preprocessor Options
@ref{Preprocessor Options}@*
-C -P -DSYMBOL -USYMBOL -undef -dM -dN

@item Assembler Options
@ref{Assembler Options}@*
-fno-short-insns -filasm-path=PATHNAME -mjvm

@item Directory Options
@ref{Directory Options}@*
-IDIR -nostdinc -nostdinc++

@item Linker Options
@ref{Linker Options}@*
-e ENTRYPOINT -LDIR -nostdlib -lLIBRARY
-shared -static -m32bit-only -fresources=RESFILE

@item Other Options
@ref{Other Options}@*
-dumpversion --help -fplugin-KEY-path=PATHNAME
@end table

@c -----------------------------------------------------------------------

@node Overall Options, Language Options, Option Summary, C# Compiler
@section Overall options
@cindex Overall options for cscc

@table @code
@item -c
Compile or assemble the input source files to object files,
but do not link.  The object file corresponding to the input
file @code{FILE.EXT} will be called @code{FILE.obj} unless the
@code{-o} option is supplied.

If the language compiles multiple input source files at a time,
then there will be a single output file.  The name of the output
file will be based on the name of the first input file unless
the @code{-o} option is supplied.

@item -S
Compile the input source files to produce assembly language in
the Intermediate Language format.  The assembly file corresponding
to the input file @code{FILE.EXT} will be called @code{FILE.il}
unless the @code{-o} option is supplied.

If the language compiles multiple input source files at a time,
then there will be a single output file.  The name of the output
file will be based on the name of the first input file unless
the @code{-o} option is supplied.

@item -E
Preprocess the input files and write the preprocessed source
to the output file.  If no output file is supplied, then
the preprocessed source is written to standard output.

@item -o FILE
Specify the name of the file to write the output to.  The default
depends upon how cscc is invoked.  Specifying FILE as @code{-}
indicates that the output should be set to standard output.
Standard output can only be used for pre-processing.

If none of @code{-c}, @code{-S}, or @code{-E} are supplied,
then the default output file is @code{a.out.exe} or @code{a.out.dll}.
The latter is used when the @code{-shared} option is supplied.

@item -pipe
Not used at present.  Provided for compatibility with gcc(1).

@item -v
Print verbose debugging information about the files that are
being compiled.

@item -vv
Print the names of the command-lines that are executed by
cscc to invoke external programs such as language plug-ins
and the assembler, ilasm.

@item -x language
Specify the source language to use to compile all input files.
This is typically not needed, because cscc can guess the
language from the input file's extension.

The options @code{-x cs} and @code{-x csharp} specify
that the language is C#.

@xref{Language Plugins}, for more information on this option.
@end table

Default file extensions typically follow the Windows conventions
of @code{.obj}, @code{.exe}, and @code{.dll} rather than the
Unix conventions of @code{.o}, no extension, and @code{.so}
respectively.  This is due to the Windows nature of IL binaries,
and to prevent confusion with native Unix binaries.  The @code{-o}
option can be used to override the defaults.

@c -----------------------------------------------------------------------

@node Language Options, Warning Options, Overall Options, C# Compiler
@section Language options
@cindex Language options for cscc

Every language supported by cscc has its own set of language,
warning, and other options.  This section describes the options
for C# only.

@table @code
@item -flatin1-charset
The input source file's character set is Latin-1, instead of
the UTF-8 default.

If the source is in a character set other than Latin-1 or UTF-8,
the programmer must arrange for it to be converted into UTF-8
prior to invoking the compiler.

@item -foctal-constants
The C# language standard does not support octal integer constants
by default.  Selecting this option will enable them.

If this option is not present, sequences such as `033' will be
parsed as decimal, and a warning will be displayed.  The
@code{-Wno-octal-constants} or @code{-fdecimal-constants} options
will disable the warning.

@item -fdecimal-constants
Parse character sequences that look like octal integers as
decimal and suppress the warning.  If both @code{-foctal-constants}
and @code{-fdecimal-constants} are supplied, then the former
takes precedence.

@item -fchecked
@itemx -funchecked
Compile arithmetic expressions so that overflow exceptions will
or will not be thrown, respectively.  The default is @code{-fchecked}.
The @code{checked} and @code{unchecked} keywords can be used in
source files to override this setting.

@item -fsyntax-check
Parse the input source file to check its syntax, but don't
go any further with compilation.

@item -funsafe
Permit the use of unsafe C# language constructs in the input
source file.  If this option is not supplied, all unsafe
constructs will result in an error.
@end table

@c -----------------------------------------------------------------------

@node Warning Options, Debugging Options, Language Options, C# Compiler
@section Warning options
@cindex Warning options for cscc

@table @code
@item -Wall
@itemx -W
Enable all warnings that are supported by the compiler.
Individual warnings can be disabled with @code{-Wno-XXX} options.
For example, @code{-Wall -Wno-empty-input} will enable
all warnings except the "empty input file" warning.

@item -Werror
Convert all warnings into errors.

@item -w
Suppress all warnings.

@item -Woctal-chars
Warn if the programmer uses the octal form of a character.
The C# language standard only supports @code{\0}, but this
compiler also supports sequences such as @code{\033}.

@item -Woctal-constants
Warn if the programmer uses a sequence that looks like an
octal integer constant, but which is being parsed as decimal
in accordance with the C# language standard.

@item -Wunknown-escapes
Warn if an unknown escape sequence is used in a string or
character constant.

@item -Winvalid-utf8
Warn if an invalid UTF-8 sequence is encountered in the
input source file.

@item -Wlarge-unicode-chars
Warn if a character constant uses a Unicode character with
a codepoint value greater than 65535.

@item -Wmulti-char-constant
Warn if a character constant contains more than one character.

@item -Wunsafe
Warn when an unsafe construct is used in the program.

@item -Wempty-input
Warn if the input source file does not contain any declarations.
@end table

@c -----------------------------------------------------------------------

@node Debugging Options, Optimization Options, Warning Options, C# Compiler
@section Debugging options
@cindex Debugging options for cscc

@table @code
@item -g
Enable the generation of debug symbol information in the output file.
@end table

@c -----------------------------------------------------------------------

@node Optimization Options, Preprocessor Options, Debugging Options, C# Compiler
@section Optimization options
@cindex Optimization options for cscc

@table @code
@item -O
@item -O2
@item -O3
Enable various levels of optimization.

@item -O0
Disable all optimizations.

@item -fno-peephole
Disable peephole optimization of the code.
@end table

@c -----------------------------------------------------------------------

@node Preprocessor Options, Assembler Options, Optimization Options, C# Compiler
@section Preprocessor options
@cindex Preprocessor options for cscc

@table @code
@item -C
Include comments in pre-processor output.  This option is not yet
supported.

@item -P
Don't use @code{#line} directives in pre-processor output.

@item -DSYMBOL
Define the macro @code{SYMBOL} prior to pre-processing the input.

C# does not support macros with values.  Supplying a command-line
option of @code{-DSYMBOL} will result in a macro called
@code{SYMBOL}, which cannot be tested effectively in C#
source code.

@item -USYMBOL
Undefine the macro @code{SYMBOL} prior to pre-processing the input.

@item -undef
Undefine all standard macros prior to pre-processing the input.

@item -dM
Dump the macros that were defined in the input source instead of
dumping the pre-processor output.  This can only be used with the
@code{-E} option.

@item -dN
Dump both the pre-processor output and the macros that were defined.
This can only be used with the @code{-E} option.
@end table

The standard macro @code{__CSCC__} is defined to indicate that
cscc is being used to compile the source code.

The standard macros @code{DEBUG} or @code{RELEASE} will be defined
to indicate if a debug (@code{-g}) or release version is being built.

The standard macro @code{__JVM__} is defined to indicate that
the output is JVM code instead of IL code.

@c -----------------------------------------------------------------------

@node Assembler Options, Directory Options, Preprocessor Options, C# Compiler
@section Assembler options
@cindex Assembler options for cscc

@table @code
@item -fno-short-insns
Causes the @code{-no-short-insns} command-line option to be
passed to the ilasm assembler.

This alters how the assembler generates the final object code.
You typically don't need to use this option.

@item -filasm-path=PATHNAME
Specifies the full pathname of the ilasm assembler.  By default,
cscc searches for ilasm along the PATH.

@item -mjvm
Compile to JVM bytecode instead of IL bytecode.
@end table

@c -----------------------------------------------------------------------

@node Directory Options, Linker Options, Assembler Options, C# Compiler
@section Directory options
@cindex Directory options for cscc

@table @code
@item -IDIR
Specify the name of a directory in which the compiler should search
for included files.

@item -fnostdinc
Don't use standard include directories.

@item -fnostdinc++
Don't use standard C++ include directories.
@end table

These options are not currently used by the C# compiler.  They are
provided for future language plug-ins that may use include files.

@c -----------------------------------------------------------------------

@node Linker Options, Other Options, Directory Options, C# Compiler
@section Linker options
@cindex Linker options for cscc

@table @code
@item -e ENTRYPOINT
Specify the name of the entry point for the program.  This may
either be a class name (e.g. @code{MainClass}) or a method
name (e.g. @code{MainClass.Main}).  If this option is not supplied,
the linker will search for any class with a static method called
@code{Main}.

@item -LDIR
Specify the name of a directory in which the compiler should search
for libraries that the program will be linked against.

@item -nostdlib
Don't use standard library directories and libraries.

@item -lLIBRARY
Link against the specified library.  For example, specifying
@code{-lSystem.XML} will search for the library @code{System.XML.dll}
along the library search path.

Unless @code{-nostdlib} is supplied, the library @code{mscorlib}
is implicitly assumed to always be linked against.

Libraries can also be specified by listing their filenames explicitly
on the command-line.  For example: @code{/usr/local/lib/cscc/System.XML.dll}
would have the same effect as @code{-lSystem.XML}.

@item -shared
Create a shared library (.dll) instead of an executable (.exe).

@item -static
Link statically against the supplied libraries.  This will incorporate
the object file data for the libraries into the program being built.

You normally will not need to use this option, unless you are concerned
that a foreign host may not have all of the libraries that are required
to execute the program.

This option will never statically link against a library that has
native, internalcall, or PInvoke methods.  In particular, @code{mscorlib.dll}
will never be linked statically.

@item -m32bit-only
Mark the final output file as only suitable to be executed on 32-bit
platforms.  Use of this option is severely discouraged as it makes
the resultant program less portable.

@item -fresources=RESFILE
Specify the name of a resource file to be linked with the final
library or executable.  Multiple @code{-fresources} options
may be used to specify multiple resource files.
@end table

@c -----------------------------------------------------------------------

@node Other Options, Language Plugins, Linker Options, C# Compiler
@section Other options
@cindex Other options for cscc

@table @code
@item -dumpversion
Dump the version of cscc to standard error and then exit.

@item --help
Print a usage message about the supported options and then exit.

@item -fplugin-KEY-path=PATHNAME
Specify the @code{PATHNAME} of a language plug-in to be used to compile
the language identified by @code{KEY}.
@end table

@xref{Language Plugins}, for more information on plug-ins.

@c -----------------------------------------------------------------------

@node Language Plugins, Compiling to the JVM, Other Options, C# Compiler
@section Language plugins
@cindex Language plugins

The compiler can support plug-ins for other programming languages, allowing
the same front-end to be used to service multiple language back-ends.
Using a plug-in allows you to avoid most of the work involved in building
a compiler.  The minimum you must provide is a translator between the
source language and IL assembly code.  The cscc front-end takes care of
assembly and linking for you.

A plug-in must be a regular Unix executable with the name @code{cscc-KEY}
or @code{cscc-KEY-s} where @code{KEY} is either the file extension or a
language name.  e.g. to create a plug-in for a hypothetical @code{superc}
language, that uses @code{.sc} as its primary file extension, create an
executable called @code{cscc-superc}, and a symbolic link called
@code{cscc-sc} that points at the executable.

When cscc searches for an extension, it will first look for an exact case
match.  If that doesn't succeed, it will normalize the extension to lower
case and try again.  Thus, the @code{cscc-sc} plug-in will be passed any file
with an extension of @code{.sc}, @code{.Sc}, @code{.sC}, or @code{.SC}.
If @code{.SC} is a different language, then a separate plug-in must
be supplied.

A language name may be specified using the -x option.  For example:

@example
cscc -x superc -o hello.obj -c hello.c
@end example

Use this when the extension is not the same as the primary extension for
the language type.  Note: @code{-x sc} could also have been used.

The C# compiler is itself implemented as a plug-in called @code{cscc-cs},
with a symbolic link to it called @code{cscc-csharp}.

If the name of the executable ends in @code{-s}, then it indicates a
"single file" language, rather than the default "multiple file" language.

Single file languages are those that must be compiled one file at a time.
C is an example of such a language: each source file is logically
independent.  The plugin is executed once for each source file on
the @code{cscc} command-line.

Multiple file languages are those that must be compiled multiple files
at a time because each file may depend on definitions in the others.
C# is such a language.  All files with a matching extension are passed
to a single execution of the plugin.  The plugin will output a
single assembly stream that contains the compiled versions of all
of the files.

The executable is located as follows:

@itemize @bullet
@item
Look for a @code{-fplugin-KEY-path=XXX} command-line option.  If it is
present, then @code{XXX} is used as the plug-in executable.  For example,
@code{-fplugin-cs-path=../../../pnet/cscc/cscc-cs} is used in the
compilation of the system library to ensure that the current version
of the compiler is used, even if a previous version is already installed.

@item
Look in the directories specified by the @code{CSCC_PLUGINS_PATH}
environment variable for a file called @code{cscc-KEY}.

@item
Look in the installation @code{plugins} directory, which is normally
something like @code{/usr/local/lib/cscc/plugins} or
@code{/usr/lib/cscc/plugins}.

@item
Look in the same directory from which @code{cscc} was loaded, by
inspecting the argv[0] value.

@item
Search the PATH for the name.
@end itemize

The cscc front-end passes the following options down to the plug-in:

@table @code
@item -E
Preprocess instead of compiling.  If the plug-in's language does not support
preprocessing, then it should print an error message to standard error
and exit with a status of 1.

@item -pipe
If the plug-in invokes other tools during compilation, then attempt to
use pipes rather than temporary files.  If it is difficult for the plug-in
to conform with this option, then it can be safely ignored.

@item -o NAME
Specify the name of the output file.  The default is standard output.

The plug-in should write preprocessed data to the output file if @code{-E}
is supplied, or IL assembly code otherwise.

@item -g
Output debug information.

@item -O
@itemx -O2
@itemx -O3
@itemx -O0
Set the optimization level to 1, 2, 3, and 0 respectively.

@item -DSYMBOL
@itemx -DSYMBOL=VALUE
Define a symbol within the plug-in language's preprocessor.  The second
form can be used if the language supports values for preprocessor symbols.
C# itself does not support values for preprocessor symbols.

@item -USYMBOL
Undefine a symbol within the plug-in language's preprocess.

@item -undef
Undefine all pre-defined preprocessor symbols that the language may support.

The cscc front-end will always pass down pre-defined
symbols such as @code{__CSCC__} and @code{DEBUG}, unless
@code{-undef} was supplied on its command-line.

@item -IDIR
Specify an include directory that originated on the cscc command-line.

@item -JDIR
@itemx -KDIR
Specify a system include directory, or a C++ system include directory.
The front-end adds @code{-J} options for each of the system include
directories that it knows about.  The front-end adds @code{-K} options for
each of the C++ system include directories that it knows about.

Plug-ins can use this information, or ignore it and use their own notion
of system include directories.

The @code{-J} options will not appear if the @code{-nostdinc} option
is present.  The @code{-K} options will not appear if the
@code{-nostdincpp} option is present.

@item -nostdinc
@itemx -nostdincpp
Don't use any system include directories, or C++ system include directories,
that the plug-in is aware of.

@item -LDIR
Specify a library directory that originated on the cscc command-line.

@item -MDIR
Specify a system library directory.  The front-end adds @code{-M} options
for each of the system library directories that it knows about.  This
option will not appear if the @code{-nostdlib} option is present.

@item -lLIBRARY
Specify the name of a library that is being linked against.

The last three options are provided for informational purposes only.
The plug-in is responsible for compiling and not linking.  However, some
languages (e.g. C#) require information from system libraries to be able to
compile successfully.  These options are supplied to help such compilers.

It is unlikely that @code{-l} options will be seen by the plug-in unless
the program is being compiled and linked in one step.  e.g.

@example
cscc -o testing.exe testing.sc -lSystem
@end example

@item -Wall
Enable all warnings.

@item -w
Suppress the display of all warnings.

@item -Werrror
Treat warning messages as errors.

@item -WNAME, -Wno-NAME
Enable or disable the warning called @code{NAME}.

@item -fNAME
Activate or deactive that compiler extension feature called @code{NAME}.

@item -mNAME
Activate or deactive that machine extension feature called @code{NAME}.

In gcc(1), the @code{-m} options are used to control machine-dependent
features.  Since IL is a platform-independent language, these options
will rarely be required by plug-ins.

Plug-ins can choose to ignore @code{-m} options, or can treat them as a
separate set of compiler extension flags that complement the @code{-f}
options.

The cscc front-end does support some @code{-m} options for controlling
the output of the assembler.  For example, @code{-m32bit-only} is used to
force the generation of IL binaries that can only run on 32-bit systems.

@item -dM
@itemx -dN
Debugging flags used with languages that support preprocessing.

@item -P
Don't output @code{#line} directives in preprocessor output.

@item -C
Include comments in the preprocessor output.

@item -v
Provide verbose messages for debugging purposes.  This can be safely
ignored if the plug-in does not have a verbose mode.

@item -mjvm
Compile to JVM assembly code instead of IL assembly code.  If the plug-in
does not know how to compile to JVM assembly code, it should print a message
to standard error and exit with a status of 1.  All plug-ins must support
this option, even if only to report an error.
@end table

The options are followed by the name of the input file, which may be
@code{-} for stdin.  Standard input is only used for preprocessing.
Multiple file languages may have more than one input file supplied
on the command-line.

Any options that are not understood by the plug-in should be ignored.
In particular, @code{-W}, @code{-f}, and @code{-m} options may not always
be understood by the plug-in, because they are intended for a different
language plug-in, cscc itself, ilasm, or the linker.  If the option is
understood, but it has an incorrect value, then the plug-in should
print a message to standard error and exit with a status of 1.

The plug-in is only used for compilation and pre-processing tasks.
It is not used for assembling or linking.  It is expected that the
output is an IL assembly code stream suitable for input to ilasm.
The plug-in does not need to be concerned with generating IL bytecode
directly, or with calling ilasm itself: cscc takes care
of the rest.

The following is an example of invoking cscc for a plug-in language,
and the plug-in command-line that results:

@example
cscc -fno-short-insns -O2 -g -I../include \
    -o hello.obj -c hello.sc

cscc-sc -f no-short-insns -O2 -g -I ../include \
    -J /usr/local/lib/cscc/include \
    -K /usr/local/lib/cscc/cpp-include \
    -D __CSCC__ -D DEBUG -o hello.il hello.sc
@end example

This is followed by a call to ilasm:

@example
ilasm --debug --no-short-insns \
    --format obj -o hello.obj hello.il
@end example

Note: in this case, the @code{-fno-short-insns} flag is intended for the
assembler, rather than the plug-in.  The plug-in silently ignores any
@code{-f} options that it doesn't understand.  It may also ignore options
like @code{-O2} if it does not support code optimization.

Any non-zero status return from the plug-in will cause cscc to exit
with the same status code.  If the plug-in exits with a signal, then
cscc will exit with a status code of 1 after reporting the signal
to standard error.

@c -----------------------------------------------------------------------

@node Compiling to the JVM, Assembler, Language Plugins, C# Compiler
@section Compiling to the JVM
@cindex Compiling to the JVM

The C# compiler supports compiling to either Intermediate Language
(IL) bytecode, or to Java Virtual Machine (JVM) bytecode.  The
@code{-mjvm} command-line option to cscc selects the JVM mode.

C# programs are typically compiled many classes at a time, with all
classes ending up in the same binary image.  The cscc compiler therefore
converts C# source code into Java @code{.jar} files, which can contain
multiple classes.  It can also compile to the @code{.class} format, but
only if the input source contains one class definition.

Compiling to JVM modifies the behaviour of some command-line options.
The file extension @code{.jar} is used instead of @code{.obj}, @code{.dll},
or @code{.exe}.  The file extension @code{.jl} is used instead of
@code{.il} for assembly code streams.  IL-specific options such as
@code{-m32bit-only} and @code{-fno-short-insns} are ignored.

The ilasm assembler supports dual bytecode formats.  A method with
the @code{java} implementation attribute will be assembled using the
Java instruction set instead of the IL instruction set.  For example:

@example
.method public instance int32 foo(int32 x) java
@{
    iload_0
    ireturn
@}
@end example

The rest of the assembly code stream is identical to IL.  The ilasm
program will convert from IL to JVM conventions on the fly.  IL-specific
features, such as module references and assembly definitions, will
be ignored.

This approach makes it relatively easy to support JVM in language
plug-ins that already support IL.  Only the bodies of methods need
to be compiled differently.

@c -----------------------------------------------------------------------

@node Assembler, Disassembler, Compiling to the JVM, Top
@chapter Intermediate language assembler
@cindex Assembler
@cindex ilasm

TO DO

@c -----------------------------------------------------------------------

@node Disassembler, ildasm invocation, Assembler, Top
@chapter Intermediate language disassembler
@cindex Disassembler
@cindex ildasm

Ildasm converts IL object files (.obj), IL executables (.exe),
and IL dynamic link libraries (.dll) into Intermediate Language (IL)
assembly code.  The output is suitable for input to ilasm.

Ildasm is useful for diagnosing problems with compilers and other
development tools.  It is rarely useful to regular users or programmers.

@menu
* ildasm invocation::       Invoking ildasm
@end menu

@c -----------------------------------------------------------------------

@node ildasm invocation, Size, Disassembler, Disassembler
@section Invoking ildasm
@cindex ildasm invocation

The general form of the ildasm syntax is as follows:

@example
ildasm [OPTIONS] INPUT ...
@end example

@table @code
@item -o FILE
@itemx --output FILE
Specify the name of the file to write the assembler output to.  The
default is standard output.  Specifying FILE as @code{-} also indicates that
the output should be set to standard output.

@item -d
@itemx --dump-sections
Dump the contents of the IL program sections in hexadecimal instead
of as IL assembly code.  This may be useful for diagnosing problems
with badly formatted IL binaries.

@item -r
@itemx --real-offsets
By default, ildasm prints "relative virtual addresses", or RVA's,
when dumping IL program sections in hexadecimal, and when dumping the
names of labels within methods.  The @code{-r} option informs ildasm
to use real file offsets instead.  This may assist in locating data within
the file with separate tools.

@item -t
@itemx --show-tokens
Show the token codes of program elements within the disassembly output.

@item -q
@itemx --quote-names
Quote all identifiers within the disassembly output so that they are not
confused with reserved words.  This is useful if the output will be fed
into ilasm.

@item -w
@itemx --whole-file
Dump the contents of the whole input file in hexadecimal.  If the
file is not otherwise recognized by ildasm as an IL binary,
this may be the only way to inspect the contents to determine what
the problem is.

@item --help
Print a usage message for the ildasm program.

@item -v
@itemx --version
Print the version of the ildasm program.

@item --
Marks the end of the command-line options, and the beginning of
the input filenames.  You may need to use this if your filename
begins with @code{-}.  e.g. @code{ildasm -- -input.obj}.  This is
not needed if the input is stdin: @code{ildasm -} is perfectly valid.
@end table

Exit status is 1 if an error occurred while processing the input.
Otherwise the exit status is 0.  @xref{Load Errors}, for a
complete list of errors that may occur when loading an IL image file.

@c -----------------------------------------------------------------------

@node Size, ilsize invocation, ildasm invocation, Top
@chapter Intermediate language size utility
@cindex Size
@cindex ilsize

Ilsize lists size information for each of the sections within an IL object
file (.obj), an IL executable (.exe), or an IL dynamic link library (.dll).
The output is similar to that produced by size(1).

@menu
* ilsize invocation::       Invoking ilsize
@end menu

@c -----------------------------------------------------------------------

@node ilsize invocation, Native, Size, Size
@section Invoking ilsize
@cindex ilsize invocation

The general form of the ilsize syntax is as follows:

@example
ilsize [OPTIONS] input ...
@end example

@table @code
@item --radix NUM
Set the radix for displaying size values within the output.  The default
value is 10.  Legal values are 8, 10, and 16.

@item -d
Set the radix to 10.  Same as @code{--radix 10}.

@item -o
Set the radix to 8.   Same as @code{--radix 8}.

@item -x
Set the radix to 16.  Same as @code{--radix 16}.

@item -D
@itemx --detailed
Use a more detailed output that also includes the number of classes,
fields, methods, etc.

@item --help
Print a usage message for the ilsize program.

@item -v
@itemx -V
@itemx --version
Print the version of the ilsize program.

@item --
Marks the end of the command-line options, and the beginning of
the input filenames.  You may need to use this if your filename
begins with @code{-}.  e.g. @code{ilsize -- -input.obj}.  This is
not needed if the input is stdin: @code{ilsize -} is perfectly valid.
@end table

Exit status is 1 if an error occurred while processing the input.
Otherwise the exit status is 0.  @xref{Load Errors}, for a
complete list of errors that may occur when loading an IL image file.

Ilsize does not currently understand the format of ".a" or ".lib" archive
libraries, so it cannot display information about archive contents like
size(1) can.

@c -----------------------------------------------------------------------

@node Native, ilnative invocation, ilsize invocation, Top
@chapter Intermediate language native utility
@cindex Native
@cindex ilnative

Ilnative lists the native methods that are used within an IL object file
(.obj), an IL executable (.exe), or an IL dynamic link library (.dll).
This can aid developers who are building programs that use native methods,
or developers who are attempting to discover which native methods a
third party program requires.

@menu
* ilnative invocation::     Invoking ilnative
@end menu

@c -----------------------------------------------------------------------

@node ilnative invocation, Find, Native, Native
@section Invoking ilnative
@cindex ilnative invocation

The general form of the ilnative syntax is as follows:

@example
ilnative [OPTIONS] INPUT ...
@end example

@table @code
@item -n
@itemx --names-only
Only print the names of the methods, and not the type information.

@item --help
Print a usage message for the ilnative program.

@item -v
@itemx --version
Print the version of the ilnative program.

@item --
Marks the end of the command-line options, and the beginning of
the input filenames.  You may need to use this if your filename
begins with @code{-}.  e.g. @code{ilnative -- -input.obj}.
This is not needed if the input is stdin: @code{ilnative -}
is perfectly valid.
@end table

The exit status is 1 if an error occurred while processing the input.
Otherwise the exit status is 0.  @xref{Load Errors}, for a
complete list of errors that may occur when loading an IL image file.

@c -----------------------------------------------------------------------

@node Find, ilfind invocation, ilnative invocation, Top
@chapter Intermediate language name find utility
@cindex Find
@cindex ilfind

Ilfind searches for a pattern within the supplied input files.  Each input
file must be an IL object file (.obj), an IL executable (.exe), or an
IL dynamic link library (.dll).

For each assembly, namespace, class, field, method, event, or property
whose name matches the pattern, a line is written to standard output
describing the match.

@menu
* ilfind invocation::       Invoking ilfind
@end menu

@c -----------------------------------------------------------------------

@node ilfind invocation, Resources, Find, Find
@section Invoking ilfind
@cindex ilfind invocation

The general form of the ilfind syntax is as follows:

@example
ilfind [OPTIONS] PATTERN INPUT ...
@end example

@table @code
@item -w
@itemx --whole-string
Match the whole pattern string against names in the input files.
This is the default.  For example, the pattern @code{ABC} will match
classes, fields, and methods called @code{ABC}, but will not match
items called @code{ABCD}.

@item -s
@itemx --sub-string
Match the pattern against sub-strings of names in the input files.
For example, the pattern @code{ABC} will match any item that contains
@code{ABC} within its name.

@item -f
@itemx --file-regex
Use a file-like regular expression matching scheme.  This is the
default.  Patterns can use `?' and `*' to match a single character
or multiple characters.  Patterns can use the characters `[' and `]'
to group a set of alternative characters.  This pattern syntax
is similar to that used to match filenames in shells such as
sh(1) and csh(1).

@item -g
@item --grep-regex
Use a regular expression matching scheme similar to grep(1).
Note: the `^' and `$' characters will be implicitly prepended and
appended to the pattern if whole string matching is enabled
(@code{-w}).

@item -n
@itemx --no-regex
Do not use regular expression matching.  This will perform a simple
identity check against names (@code{-w}) or a simple sub-string check
(@code{-s}).

@item -i
@itemx --ignore-case
Ignore case when matching names against the pattern.

@item --help
Print a usage message for the ilfind program.

@item -v
@itemx --version
Print the version of the ilfind program.

@item --
Marks the end of the command-line options.  The next argument is
the pattern.  You may need to use this if your pattern
begins with @code{-}.  e.g. @code{ilfind -- -name input.obj}.
@end table

The exit status is 1 if an error occurred while processing the input.
Otherwise the exit status is 0.  @xref{Load Errors}, for a
complete list of errors that may occur when loading an IL image file.

Ilfind assumes a POSIX-style regular expression package is being used.
If this is not the case, then the results may not always be as expected,
especially when both @code{--grep-regex} and @code{--ignore-case} are used.

The GNU regex package has POSIX support.  It is recommended that you
re-compile ilfind against that library if your system does not
support POSIX regular expressions natively.

@c -----------------------------------------------------------------------

@node Resources, ECMA Extensions, ilfind invocation, Top
@chapter Resource generation and conversion
@cindex Resources
@cindex resgen

TO DO

@c -----------------------------------------------------------------------

@node ECMA Extensions, Object Files, Resources, Top
@chapter ECMA file format extensions
@cindex ECMA Extensions

The ECMA Partition II specification for IL binaries is missing some
capabilities that a full development toolchain requires.  This chapter
describes extensions to the ECMA file formats that our development
tools use.  This information is provided to assist interoperation
between free software projects that manipulate IL binaries.

@menu
* Object Files::            Object file format extensions
* Debug Symbols::           Debug symbol extensions
@end menu

@c -----------------------------------------------------------------------

@node Object Files, Debug Symbols, ECMA Extensions, ECMA Extensions
@section Object file format extensions
@cindex Object Files

The ECMA specifications on IL binaries do not define an object
file format for incremental compilations.  Tools from other vendors
typically take an entire set of source files and compile them to either
a .exe or .dll in one hit.

Because we wish to support incremental compilation of programs and libraries
through the cscc compiler, we have defined an object file format
for IL binaries, which is similar to the PE/COFF .obj format on Windows
systems.

IL object files are PE/COFF images with the following properties:

@itemize @bullet
@item
There is no MS-DOS stub program or PE signature.

@item
The machine type in the PE/COFF header is always 0x014C (386), which
also acts as the "magic number" to detect whether a file is an object
or an executable/DLL.

@item
There is no optional header after the main PE/COFF header, and the
"characteristics" field is set to zero.

@item
The IL runtime header, code, resources, metadata, etc are placed in
a read-only section called @code{.text$il} instead of @code{.text}.
The IL runtime header begins at the start of the section.

@item
Other PE/COFF sections such as @code{.text}, @code{.rsrc}, and @code{.reloc},
can be omitted.  If present, they provide information about native code which
is outside the scope of this specification.
@end itemize

The IL data in the @code{.text$il} section is formatted in accordance with
the normal ECMA conventions for DLL's.  At link time, the metadata can be used
to combine multiple object files into a single DLL or executable.

This format was designed to be as compatible as possible with regular
PE/COFF object files.  The main distinguishing characteristic is the
use of @code{.text$il} to tag the file as containing IL data.

@c -----------------------------------------------------------------------

@node Debug Symbols, Load Errors, Object Files, ECMA Extensions
@section Debug symbol extensions
@cindex Debug Symbols

The assembler syntax defined in the ECMA specification allows for line
number and local variable name information to be inserted into the
assembly code stream.  This information is typically used by source-level
debuggers.

However, ECMA does not specify a standard way to represent this
debug information in the final IL binary.  It leaves it instead
to the specific implementations.

The following sections describe the format used by our development tools
for representing debug information within the IL binary.

@subsection Requirements

The following requirements were identified for the debug format:

@itemize @bullet
@item
It must be easy to strip from an image file.

@item
It should not impact runtime engines and tools that are
unaware of how to handle the debug information.

@item
It must be extensible to new debug data in the future,
while retaining forwards and backwards compatibility.

@item
It should be efficient to locate all debug information
that is relevant to a metadata token.
@end itemize

@subsection The @code{.ildebug} section

All debug information for an IL image is placed into a read-only,
discardable, data section called @code{.ildebug}.

The contents of @code{.ildebug} should be the last section within
the PE/COFF image file.  This allows the debug information to be easily
stripped by truncating the image, removing the @code{.ildebug}
entry from the PE/COFF section table, and reducing the total image size
in the PE/COFF headers.

The section begins with a header consisting of the following fields:

@table @asis
@item Magic
4-byte magic number string @code{ILDB}.

@item Version
32-bit value indicating the version.  This must be 1.

@item IndexOffset
32-bit offset from the start of this header to the beginning
of the token index.

@item NumIndexEntries
32-bit value that indicates the number of entries in the
token index.

@item StringOffset
32-bit offset from the start of this header to the beginning
of the string table.

@item StringLength
32-bit value that indicates the length of the string table.
@end table

Unless otherwise stated, all numeric quantities will be assumed to be
in little-endian order.

@subsection Token index

The token index consists of 8-byte entries of the following form:<p>

@table @asis
@item Token
32-bit token value.

@item Offset
32-bit offset from the start of the debug section to
a block of debug information that is associated with
the token.
@end table

The token index must be sorted into ascending order of "Token",
and should be aligned on a 4-byte boundary.  There may be multiple
entries in the index for the same token.  Use the following algorithm
to locate all debug information for a token:

@itemize @bullet
@item
Perform a binary search within the index for the token.

@item
Scan backwards in the index until the first entry for the token is found.

@item
Scan forwards in the index until the last entry for the token is found.
@end itemize

Because the token index is sorted, multiple debug information blocks
for the same token could be in any order.  Tools should not rely upon
the blocks being in any particular order, and are free to change the
order when modifying the debug section.

All of the debug information in this document refers to a specific
metadata token.  However, in the future it may be possible for
debug information to pertain to the entire image, or to objects
other than metadata tokens.  To store debug information for non-tokens,
it is first necessary to construct a pseudo-token using the following
algorithm:

@itemize @bullet
@item
Pick a unique 4-character string for the item.
e.g. @code{ABCD}.  The last character must be 7-bit ASCII.

@item
Convert the string into a little-endian value, where the
first character is assumed to be the least significant
byte.  e.g. @code{0x44434241}.

@item
Set the high bit of the value to 1.  e.g. @code{0xC4434241}.
@end itemize

The result is the pseudo-token value.  Because regular metadata
tokens cannot have their high bit set, this will result in a value
that won't conflict with regular tokens.

As an additional requirement, standard pseudo-tokens will use
upper case characters in their names.  e.g. @code{ABCD}.
Private pseudo-tokens will use lower case characters.
e.g. @code{abcd}.  There are no standard pseudo-tokens
at present.

@subsection String table

The string table stores NUL-terminated strings that are referenced
by the debug information.  In the current version of this document,
the strings will typically be filenames and local variable names.

Strings are referenced by their index, which is an offset from the
beginning of the string table.  The string value begins at that offset
and continues until the next zero byte is encountered.  The last byte
in the string table must be zero, which means that the string table
can never be empty.

This document does not specify any particular character set for
the strings.

@subsection Debug information blocks

Each entry in the token index contains an offset of the debug
information that is associated with that entry.  This debug
information begins with the following header:

@table @asis
@item Type
The type of debug information.

@item Length
The number of bytes of debug information that follow this header.
@end table

The "Type" and "Length" values are encoded with the same multi-byte
"compressed" format used in metadata to encode unsigned 32-bit values:

@table @asis
@item 0-127
Encode as the byte itself.

@item 128-16383
Encode as (0x80 | (value >> 8)), (value & 0xFF).
Note: 16383 is (2^14 - 1).

@item 16384-536870911
Encode as (0xC0 | (value >> 24)), ((value >> 16) & 0xFF),
((value >> 8) & 0xFF), (value & 0xFF).
Note: 536870911 is (2^29 - 1).

@item 536870912-4294967295
Encode as 0xE0, ((value >> 24) & 0xFF),
((value >> 16) & 0xFF), ((value >> 8) & 0xFF), (value & 0xFF).
@end table

The following debug types are supported, which are further
described in the following sections:

@table @asis
@item 1
Line number block.

@item 2
Line number and offsets block.

@item 3
Local variables block.

@item 4
Local variables and offsets block.
@end table

If a debug block type is not understood, it should be silently ignored.
This allows future versions of this specification to extend the set
of debug block types without affecting existing implementations

All of the values described below are encoded using the above multi-byte
compressed format.

@subsection Line number block

This block begins with an index into the string table that indicates
the name of the file.  The rest of the block consists of line number
values.

This block type is typically used for metadata tokens, other than methods,
to indicate the line in the source file where the token was declared.

@subsection Line number and offsets block

This block begins with an index into the string table that indicates
the name of the file.  The rest of the block consists of pairs
of line number and offset values.

This block type is typically used for method tokens, to indicate which
source file line corresponds to which offset within the method's code.

@subsection Local variables block

This block consists of pairs of name and index values.  The name value
is an offset into the string table and indicates the name of the local
variable.  The index is the number assigned to the local variable with
the method's code.

This block type is typically used for method tokens whose local variables
extend for the entire scope of the method's body.

@subsection Local variables and offsets block

This block begins with two offset values, indicating the start and end
of a region of code.  The rest of the block consists of pairs of name
and index values for the local variables.

This block is typically used for method tokens where some of the local
variables have a scope that does not extend for the entire length of the
method's body.  Thus, it is possible for the same local variable name
to refer to different indices at different points within the code.

Multiple local variable blocks for a method do not need to be ordered in
any particular way.  Debug tools may need to sort the blocks so that names
in inner scopes override those in outer scopes.

@c -----------------------------------------------------------------------

@node Load Errors, Index, Debug Symbols, Top
@appendix Errors while loading IL binaries
@cindex Load Errors

@table @samp
@item filename: truncated image
The input file is truncated in some way that prevents it from being
read as an IL image.

@item filename: not a valid PE/COFF image
The input file is not a PE/COFF file.  That is, it is not formatted
as a Windows executable or dynamic link library, and is also not
formatted as an object file.  @xref{Object Files}, for details
on the object file format.

@item filename: image does not contain IL data (may be an ordinary Windows executable)
The input file is a valid PE/COFF file, but it does not contain
an IL binary within it.  It is probably an ordinary native Windows
executable that cannot be processed by the development tools.

@item filename: incorrect IL version
The input file is a valid PE/COFF file that contains a valid IL binary,
but the IL data is for an unsupported version.

@item filename: required sections in reverse order
There was something wrong with the order of sections within the file
that caused the loader to need to seek backwards.  This will normally
only happen for IL binaries that have been incorrectly generated or
corrupted in some way.

@item filename: not enough memory to load image
The IL binary was so large that it could not be loaded into memory
prior to processing.

@item filename: bad addresses in image
The PE/COFF file or IL binary within the file contained a "relative
virtual address", or RVA, that was invalid.  This will normally only
happen for IL binaries that have been incorrectly generated or
corrupted in some way.

@item filename: invalid metadata in image
The metadata section was invalid in some way.  Usually this indicates
a corrupted IL binary.

@item filename: uses undocumented metadata feature
The metadata section was mostly valid, but it used features for which
we do not have sufficient documentation to parse successfully.

@item filename: unresolved external references
The metadata section was valid, but it referred to types in another
file that could not be fully resolved.

@item metadata error: ...
Depending on how the development tools were built, errors of this kind
may appear in addition to the other errors listed above.  They provide
additional diagnostics that mainly of interest to the authors.  If you
come across a file that produces such an error, then contact the authors.
@end table

In addition, any of the usual filesystem-related errors may be
produced.  For example, @samp{filename: No such file or directory}.

@c -----------------------------------------------------------------------

@node Index, , Load Errors, Top
@unnumbered Index

@printindex cp

@contents
@bye
