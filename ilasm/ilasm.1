.\" Copyright (c) 2001 Southern Storm Software, Pty Ltd.
.\"
.\" This program is free software; you can redistribute it and/or modify
.\" it under the terms of the GNU General Public License as published by
.\" the Free Software Foundation; either version 2 of the License, or
.\" (at your option) any later version.
.\"
.\" This program is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public License
.\" along with this program; if not, write to the Free Software
.\" Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
.TH ilasm 1 "19 July 2001" "Southern Storm Software" "Portable.NET Development Tools"
.SH NAME
ilasm \- the Intermediate Language (IL) assembler
.SH SYNOPSIS
.ll +8
.B ilasm
[ options ]
.I "input.il"
\&...
.SH DESCRIPTION
.B Ilasm
converts Intermediate Language (IL) assembly code input
into an IL object file (.obj), an IL executable (.exe),
or an IL dynamic link library (.dll).

You normally won't need to invoke \fBilasm\fR directly, because it is
invoked automatically by the \fBcscc\fR(1) compiler.  However, if you
are building your own compiler for the Portable.NET platform, then you
may need to invoke this program.

\fBIlasm\fR reads the supplied input files, assembles them, and writes
the output to the file specified by the `-o' option, or to a default
filename derived from the name of the first input file.  If any
of the input filenames are `-', then the standard input stream will
be used.  If `-' is specified multiple times, then standard input
will be parsed only once.

Specifying multiple input files is exactly the same as specifying
one input file which is the concatenation of all of the files.
Only one output file is created.  \fBIlasm\fR must be invoked multiple
times to assemble multiple input files into multiple output files.
.SH OPTIONS
.TP
.B \-o FILE, \-\-output FILE
Specify the name of the file to write the assembler output to.  The
default is "input.EXT" where "EXT" is one of "io", "exe", or "dll",
depending on the value of the
.B \-\-format
option.  If there are multiple input files, then the name of the output
file is based on the name of the first input file.  If the first
input file is `-', then the output is written to standard output.
If FILE is `-', then the output is written to standard output.
.TP
.B \-j, \-\-format obj
Write a ".obj" file as output, instead of an executable or dynamic
link library.  This is the default value.
.TP
.B \-e, \-\-format exe
Write an executable file as output, instead of a ".obj" file or dynamic
link library.
.TP
.B \-d, \-\-format dll
Write a dynamic link library file as output, instead of a ".obj" file or
executable.
.TP
.B \-g, \-\-debug
Enable the generation of debug symbol information to the output file.
.TP
.B \-n, \-\-no\-debug
Disable the generation of debug symbol information to the output file.
This is the default value.
.TP
.B \-s, \-\-short\-insns
Always use the shortest version of an instruction when creating the
output.  Some instructions have multiple versions.  e.g. "br" and "br.s"
for long and short versions of the branch instruction.  The assembler
will attempt to "squash" the instructions to occupy as little space
as possible.  This is the default value.

When this option is in force, the compiler does not need to concern
itself with choosing the most compact form of an instruction, because
the assembler will do the work.  Long instructions will be converted
into shorter versions whenever possible, and short instructions will
be converted into longer versions if required.  Compiler code generators
can therefore be much simpler.
.TP
.B \-l, \-\-no\-short\-insns
Always use the stated version of an instruction when creating the output.
For example, "br" will always generate a 5-byte branch instruction,
and "br.s" will always generate a 2-byte branch instruction.  If the
branch is too long, then using "br.s" will result in an error.

The only reason to use this is to ensure that the form of instruction
that is output by the \fBildasm\fR(1) disassembler is the same as the
form of instruction that was input to \fBilasm\fR.  This may be helpful
when attempting to diagnose compiler problems.
.TP
.B \-3, \-\-32bit\-only
Tag the output file so that it can only be executed on 32-bit platforms.
.TP
.B \-c, \-\-cui\-subsystem
Tag the output file so that it can run within the command-line subsystem
under Windows.  This is the default.
.TP
.B \-G, \-\-gui\-subsystem
Tag the output file so that it can run within the GUI subsystem
under Windows.
.TP
.B \-m, \-\-old\-metadata
Output an older metadata format used by the Beta 1 and earlier releases
of the Microsoft .NET Framework SDK.  This should only be used for
debugging purposes.
.TP
.B \-\-help
Print a usage message for the \fBilasm\fR program.
.TP
.B \-v, \-\-version
Print the version of the \fBilasm\fR program.
.TP
.B \-\-
Marks the end of the command-line options, and the beginning of
the input filenames.  You may need to use this if your filename
begins with '-'.  e.g. "ilasm -- -input.il".  This is not needed
if the input is stdin: "ilasm -" is perfectly valid.
.SH "OWNERSHIP OF OUTPUT"
The source code for
.B ilasm
is covered by the GNU General Public License (GPL).  Any modifications to
the source must be redistributed under the terms of the GPL.

There is a special exception for the output of the assembler.  If you use
\fBilasm\fR to assemble your own program, then you also own the object file,
executable, or dynamic link library that is output.  You may redistribute
the output in any way you see fit.  This does not give you ownership over
\fBilasm\fR itself: only the output.

Authors of non-free software can use \fBilasm\fR to assemble their programs,
without being forced to release their source code.  However, if authors of
non-free software modify \fBilasm\fR and then assemble their program with
the modified version, they must redistribute their modifications to
\fBilasm\fR under the terms of the GPL.

Contact the authors if you have any questions on the ownership of
your programs when \fBilasm\fR is used to assemble them.
.SH SYNTAX
This section describes the syntax of the assembly code that is input
to \fBilasm\fR.  The following BNF notations are used:
.TP 10
\fCA => B\fR
The non-terminal A can be expanded to the sequence B.
.TP 10
\fBname\fR
A lexical terminal keyword called name.  e.g. \fBpublic\fR.
.TP
\fCNAME\fR
A lexical terminal symbol called NAME, used to represent identifiers,
numbers, strings, etc.
.TP 10
\fC{A}\fR
Zero or more occurrences of \fCA\fR.
.TP 10
\fC(A)+\fR
One or more occurrences of \fCA\fR.
.TP 10
\fC[A]\fR
Zero or one occurrences of \fCA\fR.  i.e. \fCA\fR is optional.
.TP 10
\fCA | B\fR
Either A or B
.TP 10
\fC<abcd>\fR
One of the characters '\fCa\fR', '\fCb\fR', '\fCc\fR', or '\fCd\fR'.
This is normally written as \fC[abcd]\fR when used for \fBgrep\fR(1)
regular expressions.
.TP 10
\fC<^abcd>\fR
Any character except '\fCa\fR', '\fCb\fR', '\fCc\fR', or '\fCd\fR'.
.TP 10
\fC<ANY>\fR
Any character.
.TP
\fC'c'\fR
The character '\fCc\fR'.  This can also be expressed as \fC<c>\fR.
.PP
.SS LEXICAL ANALYSIS
The syntax uses lexical terminal symbols called \fCIDENT\fR, \fRINT\fC,
\fCFLOAT\fR, \fCSQSTRING\fR, \fCDQSTRING\fR, and \fCHEXBYTE\fR.
Their structure is defined as follows:
.RS
.nf
\fC
IDENT    => IDALPHA { IDALPHA | DIGIT }
INT      => ['\-'] (DIGIT)+ |
          | ['\-'] '0' <xX> (<0\-9a\-fA\-F>)+
          | ['\-'] '0' {<0\-7>}
FLOAT    => [<+\->] (DIGIT)+ EXPONENT
          | [<+\->] {DIGIT} '.' (DIGIT)+ [EXPONENT]
          | [<+\->] (DIGIT)+ '.' {DIGIT} [EXPONENT]
SQSTRING => <'> { '\\' <ANY> | <^'\\> } <'>
DQSTRING => '"' { '\\' <ANY> | <^"\\> } '"'
HEXBYTE  => (<0\-9a\-fA\-F>)+
IDALPHA  => <a\-zA\-Z_$@?>
DIGIT    => <0\-9>
EXPONENT => <eE> [<+\->] (DIGIT)+
\fR
.fi
.RE
The syntax is very close to that used by C for identifiers, integer constants,
floating point constants, single-quoted strings, and double-quoted strings.
C-like escape sequences can be used for special characters in strings.
Unlike C, single quotes are used for strings and not character constants.
The HEXBYTE terminal is used for raw sequences of bytes in some of
the declaration types.

Strings are expected to be in the UTF-8 encoding, ready for translation into
the Unicode strings used by IL binaries.  No other character sets are
supported.  It is the responsibility of the tool that generates IL
assembly code to perform any necessary character set conversions.

Comments can be represented in two ways: single-line and multi-line.
Single-line comments begin with '\fC//\fR' and continue to the end of
the current line.  Multi-line comments begin with '\fC/*\fR' and continue
until the next occurrence of '\fC*/\fR'.  Multi-line comments cannot
be nested.

White space in the input is ignored.  The allowable white space characters
are Space (0x20), Tab (0x09), Vertical Tab (0x0B), Carriage Return (0x0D),
Line Feed (0x0A), Form Feed (0x0C), and Ctrl\-Z (0x1A).

The assembly language has a large number of keywords and instruction names
that begin with lower case letters.  If the program uses a keyword
as an identifier for a class, field, method, etc, it must be quoted with
single quotes.  For example, a program identifier called "\fCmanaged\fR"
would need to be written as "\fC'managed'\fR" so that it does not conflict
with the \fBmanaged\fR keyword.

The easiest method to protect identifiers is to quote anything that begins
with a lower case letter.  If new keywords are added to \fBilasm\fR in the
future, there will be no need to modify existing compilers that use this
technique.  Compilers can quote only known keywords and instructions if
they wish, but they will not be robust against future changes.

The following is a list of the assembler keywords:
.IP
.hy 0
.na
\fBabstract algorithm ansi any array as assembly assert at auto
autochar blob blob_object bool bstr bytearray byvalstr callmostderived
carray catch cdecl cf char class clsid currency custom date decimal
default demand deny error explicit extends extern famandassem family
famorassem fastcall fault field filetime filter final finally fixed
float float32 float64 forwardref fromunmanaged fullorigin handler
hidebysig hresult idispatch il implements implicitcom implicitres
import in inf inheritcheck init initonly instance int int16 int32
int64 int8 interface internalcall iunknown lasterr lateinit lcid
linkcheck literal lpstr lpstruct lptstr lpvoid lpwstr managed marshal
method modopt modreq nan native nested newslot noappdomain noinlining
nomachine nomangle nometadata noncasdemand noncasinheritance noncaslinkdemand
noprocess not_in_gc_heap notserialized null objectref ole opt optil out
permitonly pinned pinvokeimpl prejitdeny prejitgrant private privatescope
ptr public readonly record reqmin reqopt reqrefuse request retval
rtspecialname runtime safearray sealed sequential serializable specialname
static stdcall storage stored_object stream streamed_object struct
synchronized syschar sysstring tbstr thiscall tls to typedref unicode
unmanaged unmanagedexp unsigned userdefined value vararg variant vector
virtual void wchar winapi with\fR
.ad b
.hy 1
.PP
The following is a list of assembler directives:
.IP
.hy 0
.na
\fB#line .addon .algorithm .assembly .backing .blob .capability .cctor .class .comtype .config .corflags .ctor .custom .data .emitbyte .entrypoint .event .exeloc .export .field .file .fire .get .hash .implicitcom .line .locale .locals .manifestres .maxstack .method .mime .module .namespace .originator .os .other .override .pack .param .permission .processor .property .removeon .set .size .subsystem .title .try .ver .vtable .vtentry .vtfixup .zeroinit\fR
.ad b
.hy 1
.PP
The following is a list of the instruction names:
.IP
.hy 0
.na
\fBadd add.ovf add.ovf.un and ann.call ann.catch ann.data ann.data.s ann.dead
ann.def ann.hoisted ann.hoisted_call ann.lab ann.live ann.phi ann.ref
ann.ref.s arglist beq beq.s bge bge.s bge.un bge.un.s bgt bgt.s bgt.un
bgt.un.s ble ble.s ble.un ble.un.s blt blt.s blt.un blt.un.s bne.un bne.un.s
box br br.s break brfalse brfalse.s brinst brinst.s brnull brnull.s brtrue
brtrue.s brzero brzero.s call calli callvirt castclass ceq cgt cgt.un
ckfinite clt clt.un conv.i conv.i1 conv.i2 conv.i4 conv.i8 conv.ovf.i
conv.ovf.i.un conv.ovf.i1 conv.ovf.i1.un conv.ovf.i2 conv.ovf.i2.un
conv.ovf.i4 conv.ovf.i4.un conv.ovf.i8 conv.ovf.i8.un conv.ovf.u conv.ovf.u.un
conv.ovf.u1 conv.ovf.u1.un conv.ovf.u2 conv.ovf.u2.un conv.ovf.u4
conv.ovf.u4.un conv.ovf.u8 conv.ovf.u8.un conv.r.un conv.r4 conv.r8
conv.u conv.u1 conv.u2 conv.u4 conv.u8 cpblk cpobj div div.un dup
endfault endfilter endfinally initblk initobj isinst jmp ldarg ldarg.0
ldarg.1 ldarg.2 ldarg.3 ldarg.s ldarga ldarga.s ldc.i4 ldc.i4.0 ldc.i4.1
ldc.i4.2 ldc.i4.3 ldc.i4.4 ldc.i4.5 ldc.i4.6 ldc.i4.7 ldc.i4.8 ldc.i4.M1
ldc.i4.m1 ldc.i4.s ldc.i8 ldc.r4 ldc.r8 ldelem.i ldelem.i1 ldelem.i2
ldelem.i4 ldelem.i8 ldelem.r4 ldelem.r8 ldelem.ref ldelem.u1 ldelem.u2
ldelem.u4 ldelem.u8 ldelema ldfld ldflda ldftn ldind.i ldind.i1 ldind.i2
ldind.i4 ldind.i8 ldind.r4 ldind.r8 ldind.ref ldind.u1 ldind.u2 ldind.u4
ldind.u8 ldlen ldloc ldloc.0 ldloc.1 ldloc.2 ldloc.3 ldloc.s ldloca
ldloca.s ldnull ldobj ldptr ldsfld ldsflda ldstr ldtoken ldvirtftn leave
leave.s localloc mkrefany mul mul.ovf mul.ovf.un mul.un neg newarr newobj
nop not or pop refanytype refanyval rem rem.un ret rethrow shl shr
shr.un sizeof starg starg.s stelem.i stelem.i1 stelem.i2 stelem.i4
stelem.i8 stelem.r4 stelem.r8 stelem.ref stfld stind.i stind.i1 stind.i2
stind.i4 stind.i8 stind.r4 stind.r8 stind.ref stloc stloc.0 stloc.1 stloc.2
stloc.3 stloc.s stobj stsfld sub sub.ovf sub.ovf.un switch tail tail.
throw unbox volatile volatile.  xor\fR
.ad b
.hy 1
.PP
It is not the purpose of this document to explain how these instructions
operate.  This document only explains their assembler syntax.  See
the ECMA specification "\fICommon Language Infrastructure (CLI), Part
3: IL Instruction Set\fR" for further information on the instructions.
.SS HELPER NON\-TERMINALS
In this section we define a number of non\-terminals that will be used
later in the BNF grammar.  They do not necessarily correspond to
useful program constructs on their own.
.RS
.nf
\fC
Identifier     => IDENT | SQSTRING
Integer32      => INT      /* 32-bit integer */
Integer64      => INT      /* 64-bit integer */
Float64        => FLOAT
                | \fBfloat32\fR\fC '(' Integer32 ')'
                | \fBfloat64\fR\fC '(' Integer64 ')'
                | \fBfloat32\fR\fC '[' Integer32 ']'
                | \fBfloat64\fR\fC '[' Integer64 ']'
                | \fBnan\fR\fC
                | \fBinf\fR\fC
                | '-' \fBinf\fR\fC
ComposedString => DQSTRING
                | ComposedString '+' DQSTRING
QualifiedName  => Identifier
                | QualifiedName '.' Identifier
\fR
.fi
.RE
The second and third forms of the Float64 non-terminal can be used to coerce
integer values into floating-point values.

The fourth and fifth forms of the Float64 non-terminal can be used to
convert the raw bit representation of a floating-point number into
a floating-point value.  The fourth form converts the big-endian, 32-bit,
IEEE integer representation of a single-precision value into a 32-bit float.
For example 0x3F800000 represents the value 1.0.  The fifth form does
the same for 64-bit IEEE integer representations of double-precision values.

The raw bit forms are mainly of use to compilers that wish to output
the exact binary representation of a floating-point constant, rather than
a rounded decimal value.

The ComposedString non-terminal allows long strings to be built up by
appending a sequence of shorter strings.
.SS TOP\-LEVEL DECLARATIONS
The top\-most level of the assembly input stream consists of zero or
more declarations:
.RS
.nf
\fC
TopLevel => { Declaration }
\fR
.fi
.RE
Declarations at the top\-most level cover program items such as
classes, namespaces, global methods, assembly information, manifest
resources, etc:
.RS
.nf
\fC
Declaration => NamespaceDeclaration
             | ClassDeclaration
             | MethodDeclaration
             | DataDeclaration
             | VtableDeclaration
             | VtfixupDeclaration
             | ExternalSourceSpecification
             | FileDeclaration
             | ExeLocationDeclaration
             | AssemblyDeclaration
             | AssemblyRefDeclaration
             | ComTypeDeclaration
             | ManifestResDeclaration
             | ModuleDeclaration
             | SecurityDeclaration
             | CustomAttributeDeclaration
             | SubsystemDeclaration
             | CorFlagsDeclaration
\fR
.fi
.RE
.SS NAMESPACE DECLARATIONS
.RS
.nf
\fC
NamespaceDeclaration => \fB.namespace\fR\fC QualifiedName
                        '{' { Declaration } '}'
\fR
.fi
.RE
.SS CLASS DECLARATIONS
.RS
.nf
\fC
ClassDeclaration => \fB.class\fR\fC { ClassAttribute } Identifier
          [ \fBextends\fR\fC ClassName ]
          [ \fBimplements\fR\fC ClassName { ',' ClassName } ]
          '{' { ClassMember } '}'
ClassAttribute => \fBpublic\fR\fC
                | \fBprivate\fR\fC
                | \fBvalue\fR\fC
                | \fBunmanaged\fR\fC
                | \fBnot_in_gc_heap\fR\fC
                | \fBinterface\fR\fC
                | \fBsealed\fR\fC
                | \fBabstract\fR\fC
                | \fBauto\fR\fC
                | \fBsequential\fR\fC
                | \fBexplicit\fR\fC
                | \fBansi\fR\fC
                | \fBunicode\fR\fC
                | \fBautochar\fR\fC
                | \fBimport\fR\fC
                | \fBserializable\fR\fC
                | \fBnested\fR \fBpublic\fR\fC
                | \fBnested\fR \fBprivate\fR\fC
                | \fBnested\fR \fBfamily\fR\fC
                | \fBnested\fR \fBassembly\fR\fC
                | \fBnested\fR \fBfamandassem\fR\fC
                | \fBnested\fR \fBfamorassem\fR\fC
                | \fBlateinit\fR\fC
                | \fBspecialname\fR\fC
                | \fBrtspecialname\fR\fC
ClassName      => [ '[' (QualifiedName |
                         \fB.module\fR\fC QualifiedName) ']' ]
                  QualifiedName { '/' QualifiedName }
\fR
.fi
.RE
.RS
.nf
\fC
ClassMember => MethodDeclaration
             | ClassDeclaration
             | EventDeclaration
             | PropertyDeclaration
             | FieldDeclaration
             | DataDeclaration
             | SecurityDeclaration
             | ExternalSourceSpecification
             | CustomAttributeDeclaration
             | \fB.size\fR\fC Integer32
             | \fB.pack\fR\fC Integer32
             | ComTypeDeclaration
             | ExportDeclaration
             | OverrideDeclaration
\fR
.fi
.RE
.SS METHOD DECLARATTIONS
.RS
.nf
\fC
MethodDeclaration => \fB.method\fR\fC { MethodAttribute }
                     [ CallingConventions ]
                     { ParameterAttribute }
                     MarshalledType MethodName
                     '(' [ SignatureArguments ] ')'
                     { ImplementationAttribute }
                     '{' { MethodMember } '}'
MethodName => \fB.ctor\fR\fC
            | \fB.cctor\fR\fC
            | QualifiedName
MethodAttribute => \fBstatic\fR\fC
                 | \fBpublic\fR\fC
                 | \fBprivate\fR\fC
                 | \fBfamily\fR\fC
                 | \fBfinal\fR\fC
                 | \fBspecialname\fR\fC
                 | \fBvirtual\fR\fC
                 | \fBabstract\fR\fC
                 | \fBassembly\fR\fC
                 | \fBfamandassem\fR\fC
                 | \fBfamorassem\fR\fC
                 | \fBprivatescope\fR\fC
                 | \fBhidebysig\fR\fC
                 | \fBnewslot\fR\fC
                 | \fBrtspecialname\fR\fC
                 | \fBunmanagedexp\fR\fC
                 | \fBpinvokeimpl\fR\fC
                   '(' [ ComposedString
                            [ \fBas\fR\fC ComposedString ] ]
                       { PInvokeAttribute } ')'
PInvokeAttribute => \fBnomangle\fR\fC
                  | \fBansi\fR\fC
                  | \fBunicode\fR\fC
                  | \fBautochar\fR\fC
                  | \fBole\fR\fC
                  | \fBlasterr\fR\fC
                  | \fBwinapi\fR\fC
                  | \fBcdecl\fR\fC
                  | \fBstdcall\fR\fC
                  | \fBthiscall\fR\fC
                  | \fBfastcall\fR\fC
CallingConventions => \fBinstance\fR\fC CallingConventions
                    | \fBexplicit\fR\fC CallingConventions
                    | \fBdefault\fR\fC
                    | \fBvararg\fR\fC
                    | \fBunmanaged\fR\fC \fBcdecl\fR\fC
                    | \fBunmanaged\fR\fC \fBstdcall\fR\fC
                    | \fBunmanaged\fR\fC \fBthiscall\fR\fC
                    | \fBunmanaged\fR\fC \fBfastcall\fR\fC
MarshalledType => Type [ \fB.marshal\fR\fC '(' NativeType ')' ]
ImplementationAttributes => \fBnative\fR\fC
                          | \fBil\fR\fC
                          | \fBoptil\fR\fC
                          | \fBmanaged\fR\fC
                          | \fBunmanaged\fR\fC
                          | \fBforwardref\fR\fC
                          | \fBole\fR\fC
                          | \fBruntime\fR\fC
                          | \fBinternalcall\fR\fC
                          | \fBsynchronized\fR\fC
                          | \fBnoinlining\fR\fC
SignatureArguments => SignatureArgument
                      { ',' SignatureArgument }
SignatureArgument  => \fB...\fR\fC
                    | { ParameterAttribute }
                      MarshalledType [ Identifier ]
ParameterAttribute => '[' \fBin\fR\fC ']'
                    | '[' \fBout\fR\fC ']'
                    | '[' \fBopt\fR\fC ']'
                    | '[' \fBlcid\fR\fC ']'
                    | '[' \fBretval\fR\fC ']'
                    | '[' Integer32 ']'
MethodMember => \fB.emitbyte\fR\fC Integer32
              | ExceptionBlock
              | \fB.maxstack\fR\fC Integer32
              | \fB.locals\fR\fC '(' [ SignatureArguments ] ')'
              | \fB.locals\fR\fC \fBinit\fR\fC
                '(' [ SignatureArguments ] ')'
              | \fB.entrypoint\fR\fC
              | \fB.zeroinit\fR\fC
              | DataDeclaration
              | Instruction
              | Identifier ':'
              | SecurityDeclaration
              | ExternalSourceSpecification
              | CustomAttributeSpecification
              | \fB.vtentry\fR\fC Integer32 ':' Integer32
              | \fB.override\fR\fC TypeSpecification
                \fB::\fR\fC MethodName
              | '{' { MethodMember } '}'
              | \fB.param\fR\fC '[' Integer32 ']'
                [ '=' FieldInitialization ]
\fR
.fi
.RE
.SS OTHER DECLARATIONS
This section defines the syntax for a number of other declaration kinds
that provide miscellaneous information that does not fall into any of
the above categories.
.RS
.nf
\fC
VtableDeclaration  => \fB.vtable\fR\fC '=' '(' (HEXBYTE)+ ')'
VtfixupDeclaration => \fB.vtfixup\fR\fC '[' Integer32 ']'
                      { VtfixupAttribute } \fBat\fR\fC Identifier
VtfixupAttribute   => \fBint32\fR\fC
                    | \fBint64\fR\fC
                    | \fBfromunmanaged\fR\fC
                    | \fBcallmostderived\fR\fC
\fR
.fi
.RE
.SS DIFFERENCES TO THE ECMA SYNTAX
The following summarises the differences between our assembler syntax
and the one in the ECMA specifications:
.IP
The keywords \fBnan\fR, \fBinf\fR, and \-\fBinf\fR have been introduced
to represent the floating-point constants "not a number", "positive
infinity", and "negative infinity" respectively.

The raw bit representations of floating-point constants were introduced.

The instruction aliases \fBmul.un\fR, \fBtail\fR, and \fBvolatile\fR
have been introduced for \fBmul.ovf.un\fR, \fBtail.\fR, and \fBvolatile.\fR.
.PP
.SH "OBJECT FILE FORMAT"
The ECMA specifications on IL binaries do not define an object
file format for incremental compilations.  Tools from other vendors
typically take an entire set of source files and compile them to either
a .exe or .dll in one hit.

Because we wish to support incremental compilation of programs and libraries
through the \fBcscc\fR(1) compiler, we have defined an object file format
for IL binaries, which is similar to the PE/COFF .obj format on Windows
systems.

IL object files are PE/COFF images with the following properties:
.TP
1.
There is no MS-DOS stub program or PE signature.
.TP
2.
The machine type in the PE/COFF header is always 0x014C (386), and
also acts as the "magic number" to detect whether a file is an object
or an executable/DLL.
.TP
3.
There is no optional header after the main PE/COFF header, and the
"characteristics" field is set to zero.
.TP
4.
The IL runtime header, code, resources, metadata, etc are placed in
a read-only section called ".text$il" instead of ".text".  The IL runtime
header begins at the start of the section.
.TP
5.
Other PE/COFF sections such as ".text", ".rsrc", and ".reloc", can be
omitted.  If present, they provide information about native code which
is outside the scope of this specification.
.PP
The IL data in the ".text$il" section is formatted in accordance with the
normal conventions for DLL's.  At link time, the metadata can be used
to combine multiple object files into a single DLL or executable.

This format was designed to be as compatible as possible with regular
PE/COFF object files.  The main distinguishing characteristic is the
use of ".text$il" to tag the file as containing IL data.
.SH "AUTHOR"
Written by Southern Storm Software, Pty Ltd.

http://www.southern-storm.com.au/
.SH "SEE ALSO"
ildasm(1), cscc(1)
.SH "DIAGNOSTICS"
Exit status is 1 if an error occurred while processing the input.
Otherwise the exit status is 0.
.SH "BUGS"
The parser is fairly unforgiving of errors and will bail out at the
first sign of trouble.  This is not expected to be a problem because
\fBilasm\fR will normally be processing the output of a compiler
such as \fBcscc\fR(1).  Compilers are presumed to be aware of how to
generate correct IL assembly code.

\fBIlasm\fR uses the host's native C types `float' and `double' to
handle floating point numbers.  If the host does not have a strict
IEEE floating point implementation, then the values of floating point
constants may not be exactly what was expected.  The problem can be
avoided by using the raw bit forms, which are guaranteed to produce exact
IEEE-compliant values.
